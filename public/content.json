{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://bin-playground.top/blog"},"pages":[],"posts":[{"title":"前端不定期刊(1)","slug":"frontend-undated-periodical-1","date":"2016-04-10T15:17:50.000Z","updated":"2016-04-12T01:45:20.987Z","comments":true,"path":"2016/04/10/frontend-undated-periodical-1/","link":"","permalink":"http://bin-playground.top/blog/2016/04/10/frontend-undated-periodical-1/","excerpt":"","keywords":null,"text":"自己的RSS已经订阅了很多博客了，里面不乏一些Javascript Weekly之类的订阅，想到自己每天也看到很多不错的博客，也可以通过类似的方式分享出来，所以开设了这么一个东西。就像标题一样这个分享是不定期的，不想用一个时间把自己限定死，只要看到的好文章积累到足够的时候就会发出来跟大家分享，尽量保证文章的质量，今天是第一期，总共九篇文章。 Functional Programming for Javascript Peoplehttps://medium.com/@chetcorcos/functional-programming-for-javascript-people-1915d8775504#.ctixu2ipj介绍Javascript函数式编程的一个文章，讲的比较通俗，也不是很深入，可以作为入门 深入理解GraphGLhttp://taobaofed.org/blog/2016/03/10/graphql-in-depth/淘宝前端团队介绍GraphQL的系列文章，这篇是第一篇，大家可以关注下上面的文章，毕竟大厂文章质量还是有保障的，大家也可以了解下GraphQL，平时开发的时候可以借鉴下 Canvas vs SVG: Choosing the Right Tool for the Jobhttp://www.sitepoint.com/canvas-vs-svg-choosing-the-right-tool-for-the-job/对SVG和Canvas做了一个对比，分别说了对应的应用场景，在做动画的时候可以考虑一下 前端文本截断http://efe.baidu.com/blog/text-truncating/总结了前端开发过程中解决文本截断的方法，文本截断是平时开发过程中经常会遇到的问题，视觉设计稿经常只是给出了字符定宽的情况下显示的效果，我们在开发过程中还要考虑文本超长的情况，这篇文章给出了很好的解决方法。 Why Everyone is Talking About Isomorphic/Universal Javascript and Why it Mattershttps://medium.com/capital-one-developers/why-everyone-is-talking-about-isomorphic-universal-javascript-and-why-it-matters-38c07c87905同构应用越来越多的被大家提到，前后端同用一套代码，同时可以利用后端渲染在加速首页的加载，这篇文章介绍了同构应用的由来以及解决的问题。 Exploring Angular 1.5:Lifecycle Hookshttp://blog.thoughtram.io/angularjs/2016/03/29/exploring-angular-1.5-lifecycle-hooks.htmlAngular1.5作为一个向Angular2过渡的版本，里面加入了许多Angular2的特性，比如Component。这篇文章主要介绍Angular1.5中引入的组件生命周期相关的钩子，虽然Angular2相比较Angular1.X变化很大，但我觉得这并不会影响Angular2普及的速度 Top 10 ReactJS Articles From Last Monthhttps://medium.mybridge.co/top-10-reactjs-articles-from-last-month-98978b无意中在Medium上看到了这个Top 10的系列，每个月都会发各种Top 10的Web开发博客，大家可以关注下，另外Medium上的文章质量都不错 揭秘微信红包：架构、抢红包算法、高并发和降级方案http://www.infoq.com/cn/articles/2016-hongbao-weixin-archtecture这篇文章中整体架构上介绍了微信红包如何抗住除夕全天80.8亿个红包的，作为前端可以简单的了解一下 CSS Modules 详解及 React 中实践https://github.com/camsong/blog/issues/5CSS Modules是最近比较火的CSS模块化方案，为了解决CSS模块化组件化过程中遇到的问题，有兴趣的可以看看这篇介绍：CSS Modules:Welcome to the Future","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Github装逼指南——Travis CI 和 Codecov","slug":"use-travis-ci-and-codecov-with-github","date":"2016-02-03T16:00:09.000Z","updated":"2016-03-14T01:20:18.971Z","comments":true,"path":"2016/02/04/use-travis-ci-and-codecov-with-github/","link":"","permalink":"http://bin-playground.top/blog/2016/02/04/use-travis-ci-and-codecov-with-github/","excerpt":"好久没写博客了，趁着年前空闲的时间来一篇轻松点的东西。最近工作中积累了一些Angular组件打算整一整把他们开源了，既然要开源那么代码可靠性就很重要了，单测不能少，为了保证每次提交的代码都能很好的运行，持续集成不能少。之前看到很多开源项目介绍中都有一些单测覆盖率和build结果的图标，就像这样：","keywords":null,"text":"好久没写博客了，趁着年前空闲的时间来一篇轻松点的东西。最近工作中积累了一些Angular组件打算整一整把他们开源了，既然要开源那么代码可靠性就很重要了，单测不能少，为了保证每次提交的代码都能很好的运行，持续集成不能少。之前看到很多开源项目介绍中都有一些单测覆盖率和build结果的图标，就像这样： 觉得挺酷的。打算在自己的开源组件中也整一套。经过Google决定使用TravisCI来进行持续集成，Codecov来统计单测覆盖率。 Travis CITravis CI是国外新兴的开源持续集成构建项目，支持Github项目。使用十分方便。 使用Github账号登录Travis CI； 登录之后会自动同步Github项目，选择需要使用Travis CI的项目 在项目的根目录新增.travis.yml文件，内容如下： 1234567891011121314#指定运行环境language: node_js#指定nodejs版本，可以指定多个node_js: - 0.12.5#运行的脚本命令script: - npm run ci#指定分支，只有指定的分支提交时才会运行脚本branches: only: - master 更多语法请看这里。使用起来非常方便，这样当你每次向github push代码的时候，Travis CI就会自动运行.travis.yml里面的script。自动进行编译以及运行单测。由于Travis CI每次build之前都会运行npm install安装项目依赖的npm包，所以在提交代码的时候要保证把所有依赖的包都已经在package.json中声明了，否则build就会失败。 CodecovCodecov是一个开源的测试结果展示平台，将测试结果可视化。Github上许多开源项目都使用了Codecov来展示单测结果。Codecov跟Travis CI一样都支持Github账号登录，同样会同步Github中的项目。在nodejs环境下使用Codecov需要安装对于的npm包，运行下面这个命令进行安装：1npm install codecov --save-dev 这个包的作用是将我们运行单测产生的结果文件上传到Codecov上进行可视化展示。同时codecov支持的结果文件类型为cobertura。所以需要保证单测执行的结果文件的类型为cobertura。前端项目进行单元测试推进karma + ‘jasmine’的组合。这两个具体是什么东西大家Google一下就知道。使用karma可以通过简单的配置来运行单测。下面是我一个项目中的配置文件，供大家参考：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// Karma configuration// Generated on Mon Feb 01 2016 21:34:22 GMT+0800 (中国标准时间)module.exports = function(config) &#123; config.set(&#123; // base path that will be used to resolve all patterns (eg. files, exclude) basePath: '', // frameworks to use // available frameworks: https://npmjs.org/browse/keyword/karma-adapter // 使用的测试框架jasmine, requirejs支持模块化加载 frameworks: ['jasmine', 'requirejs'], // list of files / patterns to load in the browser files: [ // karma中用到进行requirejs配置的文件 'test/test-main.js', // 测试中需要用到的文件，includeed设为false表示在页面加载的时候不会加载相应的js文件，也就是可以通过requirejs进行异步加载 &#123;pattern: 'node_modules/jquery/dist/jquery.min.js', included: false&#125;, &#123;pattern: 'node_modules/angular/angular.min.js', included: false&#125;, &#123;pattern: 'node_modules/angular-mocks/angular-mocks.js', included: false&#125;, &#123;pattern: 'src/bg-single-selector.js', included: false&#125;, &#123;pattern: 'test/selector.spec.js', included: false&#125; ], // list of files to exclude exclude: [ ], // preprocess matching files before serving them to the browser // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor // 针对bg-single-selector.js生成单测覆盖率结果 preprocessors: &#123; 'src/bg-single-selector.js': 'coverage' &#125;, // test results reporter to use // possible values: 'dots', 'progress' // available reporters: https://npmjs.org/browse/keyword/karma-reporter // 测试结果的几种输出方式 reporters: ['progress', 'coverage', 'verbose'], // 测试结果报告的类型 coverageReporter:&#123; reporters: [&#123; type:'text-summary' &#125;, &#123; type: 'html', dir: 'test/coverage' &#125;, &#123; // 这就是Codecov支持的文件类型 type: 'cobertura', subdir: '.', dir: 'test/coverage' &#125;] &#125;, // web server port port: 9876, // enable / disable colors in the output (reporters and logs) colors: true, // level of logging // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG logLevel: config.LOG_INFO, // enable / disable watching file and executing tests whenever any file changes autoWatch: true, // start these browsers // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher browsers: ['PhantomJS'], // 运行测试依赖的插件 plugins: [ 'karma-jasmine', 'karma-coverage', 'karma-verbose-reporter', 'karma-phantomjs-launcher', 'karma-requirejs' ], // Continuous Integration mode // if true, Karma captures browsers, runs the tests and exits singleRun: true &#125;)&#125; 通过karma进行单元测试，将命令写到.travis.yml中就可以在每次build的时候运行单测，同时运行codecov [cobertura-coverage.xml路径]就会把单测结果上传到Codecov。在本地运行codecov会失败，需要将这个过程加入到Travis CI的build脚本中，才能成功上传。因为在本地运行就会被作为私有项目，对于私有项目在上传结果时需要加上Codecov提供的token。 在github中加入图标到了最后一步，Travis CI和Codecov都提供图标链接来展示结果。我们只需要将图标链接加入到项目的README中就可以看到结果了。对于Travis CI来说，点击下图中的图标： 就会弹出图标的地址。对于Codecov来说，打开项目的设置列表就会看到，如下： 最后只需要将对应的链接加到README文件中就可以了。下面是最后的效果： 是不是很赞！项目地址：BGSingleSelector，欢迎大家试用提意见，同时不要吝啬Star。 最后的最后，做一个广告。百度告警平台。这是一个智能的告警平台，提供实时精确的告警送达，故障的协作处理能力。再也不需要担心遗漏监控报警，解放运维人力。","raw":null,"content":null,"categories":[],"tags":[{"name":"github","slug":"github","permalink":"http://bin-playground.top/blog/tags/github/"},{"name":"ci","slug":"ci","permalink":"http://bin-playground.top/blog/tags/ci/"},{"name":"codecov","slug":"codecov","permalink":"http://bin-playground.top/blog/tags/codecov/"}]},{"title":"看看 Grunt 的源码（三）：grunt 任务注册相关源码解析","slug":"grunt-source-code-3","date":"2015-04-20T01:28:32.000Z","updated":"2016-03-14T01:29:26.823Z","comments":true,"path":"2015/04/20/grunt-source-code-3/","link":"","permalink":"http://bin-playground.top/blog/2015/04/20/grunt-source-code-3/","excerpt":"上一篇分享了关于grunt中任务运行相关源码的解析，这一篇来分享grunt中跟任务注册相关的源码解析，废话不多说，开始吧。","keywords":null,"text":"上一篇分享了关于grunt中任务运行相关源码的解析，这一篇来分享grunt中跟任务注册相关的源码解析，废话不多说，开始吧。跟任务注册相关的两个方法是 grunt.registerTask 和grunt.registerMultiTask 。这两个方法都位于 lib/grunt/task.js 文件中。首先来看看 grunt.registerTask 方法的实现，这个方法还涉及到了 lib/util/task.js 文件中的 registerTask 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//lib/grunt/task.jstask.registerTask = function(name) &#123; // 将任务加入到registry中 registry.tasks.push(name); // 调用parent的registerTask方法注册任务 parent.registerTask.apply(task, arguments); // 调用parent.registerTask方法之后，任务会被加入到_tasks缓存中 var thisTask = task._tasks[name]; // 复制任务的元数据 thisTask.meta = grunt.util._.clone(registry.meta); // 对注册的任务函数进行封装 // 在真实函数执行之前进行一些预处理 var _fn = thisTask.fn; thisTask.fn = function(arg) &#123; // 缓存任务名称 var name = thisTask.name; // 初始化任务的errorcount errorcount = grunt.fail.errorcount; // 返回任务运行期间的errorcount Object.defineProperty(this, 'errorCount', &#123; enumerable: true, get: function() &#123; return grunt.fail.errorcount - errorcount; &#125; &#125;); // 将task.requires方法添加到this对象中 this.requires = task.requires.bind(task); // 将grunt.config.requires方法添加到this对象中 this.requiresConfig = grunt.config.requires; // options方法返回任务的相关option参数，可以通过参数覆盖默认的配置 this.options = function() &#123; var args = [&#123;&#125;].concat(grunt.util.toArray(arguments)).concat([ grunt.config([name, 'options']) ]); var options = grunt.util._.extend.apply(null, args); grunt.verbose.writeflags(options, 'Options'); return options; &#125;; // 初始化log输出工作 var logger = _fn.alias || (thisTask.multi &amp;&amp; (!arg || arg === '*')) ? 'verbose' : 'log'; grunt[logger].header('Running \"' + this.nameArgs + '\"' + (this.name !== this.nameArgs ? ' (' + this.name + ')' : '') + ' task'); grunt[logger].debug('Task source: ' + thisTask.meta.filepath); // 运行真实注册的任务函数 return _fn.apply(this, arguments); &#125;; return task;&#125;;//lib/util/task.js// 注册任务Task.prototype.registerTask = function(name, info, fn) &#123; // 如果没有传递info，调整参数 // 比如grunt.registerTask('taskName',function()&#123;&#125;)的情况 // 这时候info为function函数，所以把info赋值给fn if (fn == null) &#123; fn = info; info = null; &#125; // 如果fn是字符串或者字符串数组 // 比如grunt.registerTask('task',['task1','task2','task3'])的情况 var tasks; if (typeof fn !== 'function') &#123; // 针对上面的情况，这时候tasks=['task1','task2','task3'] tasks = this.parseArgs([fn]); // 将任务的函数改为将每个子任务添加到任务队列中 // 也就是分别将task1,task2和task3加入任务队列中 fn = this.run.bind(this, fn); fn.alias = true; // 这种情况下task相当于task1,task2和task3任务组合的别名 if (!info) &#123; info = 'Alias for \"' + tasks.join('\", \"') + '\" task' + (tasks.length === 1 ? '' : 's') + '.'; &#125; &#125; else if (!info) &#123; info = 'Custom task.'; &#125; // 将任务加入到缓存中 this._tasks[name] = &#123;name: name, info: info, fn: fn&#125;; // 返回任务对象，支持链式调用 return this;&#125;; 在 registerTask 方法中，首先会调用 lib/util/task.js 中的 registerTask 方法，而在这个方法中会修正方法的参数，然后将任务对象加入到任务缓存中；接着回到 registerTask 方法中对注册的函数进行封装，在封装的函数中会在函数执行前进行一些初始化工作，最后再执行注册函数。 下面来看看 grunt.registerMultiTask 方法的实现。这个方法是针对具有多个target的任务的注册。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 组成含有多target的tasktask.registerMultiTask = function(name, info, fn) &#123; // 针对grunt.registerMultiTask('taskName',function()&#123;&#125;)的情况 if (fn == null) &#123; fn = info; info = 'Custom multi task.'; &#125; var thisTask; task.registerTask(name, info, function(target) &#123; var name = thisTask.name; // 获得除了任务名以外的参数 this.args = grunt.util.toArray(arguments).slice(1); // 如果没有指定target或者指定为*，那么运行所以target if (!target || target === '*') &#123; return task.runAllTargets(name, this.args); &#125; else if (!isValidMultiTaskTarget(target)) &#123; // 如果存在不合法的target则抛出错误 throw new Error('Invalid target \"' + target + '\" specified.'); &#125; // 判断是否存在对应target的配置 this.requiresConfig([name, target]); // options方法返回任务的相关option参数，可以通过参数覆盖默认的配置 this.options = function() &#123; var targetObj = grunt.config([name, target]); var args = [&#123;&#125;].concat(grunt.util.toArray(arguments)).concat([ grunt.config([name, 'options']), grunt.util.kindOf(targetObj) === 'object' ? targetObj.options : &#123;&#125; ]); var options = grunt.util._.extend.apply(null, args); grunt.verbose.writeflags(options, 'Options'); return options; &#125;; // 将target添加到this对象中 this.target = target; // 为this对象添加flags属性，并且初始化flags对象 // flags对象用来记录参数列表中是否存在对象的参数 // 如果存在值为true this.flags = &#123;&#125;; this.args.forEach(function(arg) &#123; this.flags[arg] = true; &#125;, this); // 将target的对于配置添加到this对象中 // 这个配置也就是我们通过initConfig定义的配置 this.data = grunt.config([name, target]); // 将封装之后的files对象添加到this对象中 this.files = task.normalizeMultiTaskFiles(this.data, target); // 将src的相关值添加到this的filesSrc属性中 Object.defineProperty(this, 'filesSrc', &#123; enumerable: true, get: function() &#123; return grunt.util._(this.files).chain().pluck('src').flatten().uniq().value(); &#125;.bind(this) &#125;); // 调用任务注册函数，传入相应参数 return fn.apply(this, this.args); &#125;); // 缓存任务 thisTask = task._tasks[name]; // 将任务标记为多任务 thisTask.multi = true;&#125;; 在 registerMultiTask 方法中会调用 registerTask 方法注册任务，而在注册的函数中首先会根据传入的target执行相应操作，如果没有传入target或者传入 * 那么就调用 runAllTargets 方法将所有target都加入任务队列中，否则执行对应的target，接着获取target的相应配置，调用 normalizeMultiTaskFiles 方法将配置数据转换为内部的file对象（PS：这个过程是grunt比较方便的一个地方，它有多种形式来定义文件路径之间的映射，并且支持多种表达式，file对象也是我一开始看grunt的东西，觉得这很神奇。后面我会说到这个方法），最后调用任务实际注册的函数。 下面我们就来看看 normalizeMultiTaskFiles 方法的具体实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152task.normalizeMultiTaskFiles = function(data, target) &#123; var prop, obj; var files = []; if (grunt.util.kindOf(data) === 'object') &#123; if ('src' in data || 'dest' in data) &#123; /* *Compact Format的情况，比如： *'bar' : &#123; * 'src' : ['a.js','b.js'] , * 'dest' : 'c.js' *&#125; */ obj = &#123;&#125;; // 将除了options以外的配置复制到obj对象中 for (prop in data) &#123; if (prop !== 'options') &#123; obj[prop] = data[prop]; &#125; &#125; files.push(obj); &#125; else if (grunt.util.kindOf(data.files) === 'object') &#123; /* *Files Object Format的情况，比如： *'bar' : &#123; * 'files' : &#123; * 'c.js' : ['a.js','b.js'] * &#125; *&#125; */ for (prop in data.files) &#123; files.push(&#123;src: data.files[prop], dest: grunt.config.process(prop)&#125;); &#125; &#125; else if (Array.isArray(data.files)) &#123; /* *Files Array Format的情况，比如： *'bar' : &#123; * 'files' : [ * &#123;'src':['a.js','b.js'],'dest':'c.js'&#125;, * &#123;'src':['a.js','b.js'],'dest':'d.js'&#125; * ] *&#125; */ grunt.util._.flatten(data.files).forEach(function(obj) &#123; var prop; if ('src' in obj || 'dest' in obj) &#123; files.push(obj); &#125; else &#123; for (prop in obj) &#123; files.push(&#123;src: obj[prop], dest: grunt.config.process(prop)&#125;); &#125; &#125; &#125;); &#125; &#125; else &#123; /* *Older Format的情况，比如： *'bar' : ['a.js','b.js'] */ files.push(&#123;src: data, dest: grunt.config.process(target)&#125;); &#125; // 如果没找到合法的文件配置对象，那么返回空的文件数组 if (files.length === 0) &#123; grunt.verbose.writeln('File: ' + '[no files]'.yellow); return []; &#125; // 对需要扩展的文件对象进行扩展 files = grunt.util._(files).chain().forEach(function(obj) &#123; // 调整obj.src属性，使其成为一维数组 // 如果不存在src属性，则直接返回不需要进行任何操作 if (!('src' in obj) || !obj.src) &#123; return; &#125; // 如果obj.src是数组则压缩成一维数组，否则直接转换为数组 if (Array.isArray(obj.src)) &#123; obj.src = grunt.util._.flatten(obj.src); &#125; else &#123; obj.src = [obj.src]; &#125; &#125;).map(function(obj) &#123; // 在obj的基础上创建对象，移除不需要的属性，处理动态生成src到dest的映射 var expandOptions = grunt.util._.extend(&#123;&#125;, obj); delete expandOptions.src; delete expandOptions.dest; // 利用expand中的配置，扩展文件映射关系，并返回扩展后的file对象 if (obj.expand) &#123; return grunt.file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) &#123; // 将obj对象复制为result对象 var result = grunt.util._.extend(&#123;&#125;, obj); // 将obj对象复制为result的orig属性 result.orig = grunt.util._.extend(&#123;&#125;, obj); // 如果src或dest为模板，则解析为真正的路径 result.src = grunt.config.process(mapObj.src); result.dest = grunt.config.process(mapObj.dest); // 移除不需要的属性 ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function(prop) &#123; delete result[prop]; &#125;); return result; &#125;); &#125; // 复制obj对象，并且向副本添加一个orig属性，属性的值也是obj对象的一个副本 // 保存一个obj的副本orig是因为在后面可能会对result中的属性进行修改 // orig使得result中可以访问到原始的file对象 var result = grunt.util._.extend(&#123;&#125;, obj); result.orig = grunt.util._.extend(&#123;&#125;, obj); if ('src' in result) &#123; // 如果result对象中具有src属性，那么给src属性添加一个get方法， // 方法中对src根据expand进行扩展 Object.defineProperty(result, 'src', &#123; enumerable: true, get: function fn() &#123; var src; if (!('result' in fn)) &#123; src = obj.src; // 将src转换为数组 src = Array.isArray(src) ? grunt.util._.flatten(src) : [src]; // 根据expand参数扩展src属性，并把结果缓存在fn中 fn.result = grunt.file.expand(expandOptions, src); &#125; return fn.result; &#125; &#125;); &#125; if ('dest' in result) &#123; result.dest = obj.dest; &#125; return result; &#125;).flatten().value(); // 如果命令行带有--verbose参数，则在log中输出文件路径 if (grunt.option('verbose')) &#123; files.forEach(function(obj) &#123; var output = []; if ('src' in obj) &#123; output.push(obj.src.length &gt; 0 ? grunt.log.wordlist(obj.src) : '[no src]'.yellow); &#125; if ('dest' in obj) &#123; output.push('-&gt; ' + (obj.dest ? String(obj.dest).cyan : '[no dest]'.yellow)); &#125; if (output.length &gt; 0) &#123; grunt.verbose.writeln('Files: ' + output.join(' ')); &#125; &#125;); &#125; return files;&#125;; grunt提供了多种格式来进行文件参数的配置，normalizeMultiTaskFiles方法会将相应target的配置转换为一个files数组，这个数组中存放的是每对文件的源地址和目的地址，该方法还负责对expand属性相关参数进行解析，最后生成多个源地址和目的地址对存在在files数组中。这个方法大大方便了grunt中关于文件的操作和配置。 到这里 grunt 源码的解析就差不多了，更多的东西需要不断在实践中去理解，关于源码的详细注释请看 这里。","raw":null,"content":null,"categories":[],"tags":[{"name":"grunt","slug":"grunt","permalink":"http://bin-playground.top/blog/tags/grunt/"}]},{"title":"看看 Grunt 的源码（二）：grunt 任务运行相关源码解析","slug":"grunt-source-code-2","date":"2015-04-19T01:26:13.000Z","updated":"2016-03-14T01:28:13.082Z","comments":true,"path":"2015/04/19/grunt-source-code-2/","link":"","permalink":"http://bin-playground.top/blog/2015/04/19/grunt-source-code-2/","excerpt":"上一篇分享了关于grunt-cli的源码解析，这篇开始grunt核心部分代码的解析，还是从上一篇结束部分开始。 12//调用grunt执行任务require(gruntpath).cli(); gruntpath是通过解析得到的grunt.js的文件路径，通过require方法加载grunt模块然后调用模块的cli方法来运行命令行最后运行命令行中的任务。","keywords":null,"text":"上一篇分享了关于grunt-cli的源码解析，这篇开始grunt核心部分代码的解析，还是从上一篇结束部分开始。 12//调用grunt执行任务require(gruntpath).cli(); gruntpath是通过解析得到的grunt.js的文件路径，通过require方法加载grunt模块然后调用模块的cli方法来运行命令行最后运行命令行中的任务。 我们先从大体上看看grunt从输入命令行到任务运行完毕整个过程中都经过了哪些步骤。下图是我根据源码得出的一个流程图。 首先，我们输入命令行之后调用require(gruntpath).cli()方法，在cli方法中会初始化命令行的默认参数列表，解析输入命令行的参数以及任务名称 然后调用grunt.tasks方法，将任务参数和名称传入。在grunt.tasks方法中，会进一步对参数进行解析，初始化log功能，如果参数带有version或者help选项那么直接执行相应的函数，否则就解析任务名称。 接着调用task.init方法。加载Gruntfile.js文件，注册任务信息以及配置信息。 接着调用task.run方法。task.run方法并不会运行任务，而是把任务相关信息添加到任务队列中。 最后才是调用task.start方法来依次运行任务队列中的任务。 下面来一步步解析grunt核心源码。首先，来看看lib/grunt/cli.js文件中的代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 执行命令行时执行的函数var cli = module.exports = function(options, done) &#123; // 利用传递的参数设置cli.options对象，但是不覆盖命令行的参数 if (options) &#123; Object.keys(options).forEach(function(key) &#123; if (!(key in cli.options)) &#123; // 如果输入的命令行中不存在这个参数，那么把它加入到cli的options属性中 cli.options[key] = options[key]; &#125; else if (cli.optlist[key].type === Array) &#123; // 如果输入的命令行中存在这个参数，并且参数的类型是数组，那么把它加入到数组尾部 [].push.apply(cli.options[key], options[key]); &#125; &#125;); &#125; // 运行任务 grunt.tasks(cli.tasks, cli.options, done);&#125;;// 默认的参数选项列表var optlist = cli.optlist = &#123; help: &#123; short: 'h', info: 'Display this help text.', type: Boolean &#125;, base: &#123; info: 'Specify an alternate base path. By default, all file paths are relative to the Gruntfile. ' + '(grunt.file.setBase) *', type: path &#125;, color: &#123; info: 'Disable colored output.', type: Boolean, negate: true &#125;, gruntfile: &#123; info: 'Specify an alternate Gruntfile. By default, grunt looks in the current or parent directories ' + 'for the nearest Gruntfile.js or Gruntfile.coffee file.', type: path &#125;, debug: &#123; short: 'd', info: 'Enable debugging mode for tasks that support it.', type: [Number, Boolean] &#125;, stack: &#123; info: 'Print a stack trace when exiting with a warning or fatal error.', type: Boolean &#125;, force: &#123; short: 'f', info: 'A way to force your way past warnings. Want a suggestion? Don\\'t use this option, fix your code.', type: Boolean &#125;, tasks: &#123; info: 'Additional directory paths to scan for task and \"extra\" files. (grunt.loadTasks) *', type: Array &#125;, npm: &#123; info: 'Npm-installed grunt plugins to scan for task and \"extra\" files. (grunt.loadNpmTasks) *', type: Array &#125;, write: &#123; info: 'Disable writing files (dry run).', type: Boolean, negate: true &#125;, verbose: &#123; short: 'v', info: 'Verbose mode. A lot more information output.', type: Boolean &#125;, version: &#123; short: 'V', info: 'Print the grunt version. Combine with --verbose for more info.', type: Boolean &#125;, completion: &#123; info: 'Output shell auto-completion rules. See the grunt-cli documentation for more information.', type: String &#125;,&#125;;// 利用optlist列表初始化aliases和known对象// 传递给nopt模块进行命令行参数解析// nopt是一个用来解析命令行参数的第三方模块var aliases = &#123;&#125;;var known = &#123;&#125;;Object.keys(optlist).forEach(function(key) &#123; var short = optlist[key].short; if (short) &#123; aliases[short] = '--' + key; &#125; known[key] = optlist[key].type;&#125;);var parsed = nopt(known, aliases, process.argv, 2);// 获取命令行中的任务名称cli.tasks = parsed.argv.remain;// 获得命令行中的参数cli.options = parsed;delete parsed.argv;// 初始化类型为数组但是还没被初始化的参数，比如npm和taskObject.keys(optlist).forEach(function(key) &#123; if (optlist[key].type === Array &amp;&amp; !(key in cli.options)) &#123; cli.options[key] = []; &#125;&#125;); 这段代码相对比较简单，主要功能就是解析任务名和参数然后传递给grunt.tasks方法进行调用。下面来看看grunt.js中关于grunt.tasks方法的代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// 这个tasks方法一般只在grunt内部调用// tasks方法用来将任务添加到任务队列中，并且运行任务grunt.tasks = function(tasks, options, done) &#123; // option模块对命令行参数进行包装 // init方法对参数进行了初始化，在方法内部判断传入参数是否为空 // 如果为空则初始化为空对象否则使用传入的对象进行初始化 option.init(options); var _tasks, _options; // option方法接受可变属性的参数， // 如果传入一个参数则在参数对象中找出对于的参数， // 如果传入两个参数则根据这两个参数设置key-value键值对，并value // 同时方法内部会用正则匹配no-color、no-write的情况， // 如果出现则设置option['color']或option['write']为false，并返回false if (option('version')) &#123; // 如果带有version参数 // 输出版本信息 log.writeln('grunt v' + grunt.version); if (option('verbose')) &#123; // //输出详细信息，包括grunt的路径 verbose.writeln('Install path: ' + path.resolve(__dirname, '..')); grunt.log.muted = true; // 初始化任务系统，解析gruntfile以便输出所有可用的任务 grunt.task.init([], &#123;help: true&#125;); grunt.log.muted = false; // 输出可用的任务信息 _tasks = Object.keys(grunt.task._tasks).sort(); verbose.writeln('Available tasks: ' + _tasks.join(' ')); // 输出所有可用参数的详细信息 _options = []; Object.keys(grunt.cli.optlist).forEach(function(long) &#123; var o = grunt.cli.optlist[long]; _options.push('--' + (o.negate ? 'no-' : '') + long); if (o.short) &#123; _options.push('-' + o.short); &#125; &#125;); verbose.writeln('Available options: ' + _options.join(' ')); &#125; return; &#125; // 初始化log的着色功能 log.initColors(); // 如果参数带有help则输出帮助信息 if (option('help')) &#123; help.display(); return; &#125; // 根据option输出命令行参数，flags方法会过滤掉值为空的参数 verbose.header('Initializing').writeflags(option.flags(), 'Command-line options'); // 判断是否有传入tasks参数并且任务长度大于0 var tasksSpecified = tasks &amp;&amp; tasks.length &gt; 0; //将传入参数进行转换，转换为任务数组，如果没有传入有效的任务那么使用默认default任务 tasks = task.parseArgs([tasksSpecified ? tasks : 'default']); // 根据传入的tasks参数初始化任务 // 在方法中加载gruntfile.js文件，进行任务注册和配置的解析 // 也就是加载我们编写的任务代码 task.init(tasks, options); verbose.writeln(); if (!tasksSpecified) &#123; verbose.writeln('No tasks specified, running default tasks.'); &#125; verbose.writeflags(tasks, 'Running tasks'); // 注册异常处理函数，输出异常信息 var uncaughtHandler = function(e) &#123; fail.fatal(e, fail.code.TASK_FAILURE); &#125;; process.on('uncaughtException', uncaughtHandler); task.options(&#123; error: function(e) &#123; fail.warn(e, fail.code.TASK_FAILURE); &#125;, done: function() &#123; // 当任务完成之后移除异常监听函数，减少多余的开销 process.removeListener('uncaughtException', uncaughtHandler); // 输出最后的运行结果，失败或者成功 fail.report(); if (done) &#123; // 如果存在done函数的话，当完成任务时执行done函数 done(); &#125; else &#123; // 如果没有done函数直接结束进程 util.exit(0); &#125; &#125; &#125;); // 将任务依次加入内部的任务队列中，run方法并不会运行任务，只是加入到队列中 tasks.forEach(function(name) &#123; task.run(name); &#125;); // 开始运行任务队列中的任务 task.start(&#123;asyncDone:true&#125;);&#125;; 在grunt.tasks代码中，首先会进行参数的初始化，接着判断参数是否带有version或者help选项，如果带有这两个选项就进行相应的工作而不运行任务任务，否则解析任务名进行任务初始化并添加到任务队列中，最后运行任务。在grunt.tasks方法中比较重要的三个方法就是task.init，task.run和task.start方法。下面看看task.init方法的具体实现。这个方法位于lib/grunt/task.js文件中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 初始化任务task.init = function(tasks, options) &#123; if (!options) &#123; options = &#123;&#125;; &#125; // 拥有init方法说明task是初始化任务，比如第三方插件 var allInit = tasks.length &gt; 0 &amp;&amp; tasks.every(function(name) &#123; var obj = task._taskPlusArgs(name).task; return obj &amp;&amp; obj.init; &#125;); // 获取gruntfile.js路径，如果有指定路径那么直接使用否则在当前目录及父目录中查找 var gruntfile, msg; if (allInit || options.gruntfile === false) &#123; gruntfile = null; &#125; else &#123; gruntfile = grunt.option('gruntfile') || grunt.file.findup('Gruntfile.&#123;js,coffee&#125;', &#123;nocase: true&#125;); msg = 'Reading \"' + (gruntfile ? path.basename(gruntfile) : '???') + '\" Gruntfile...'; &#125; // 如果参数中将gruntfile设为false，那么说明任务是一个插件或者库 // 不做任何操作 if (options.gruntfile === false) &#123; // Grunt was run as a lib with &#123;gruntfile: false&#125;. &#125; else if (gruntfile &amp;&amp; grunt.file.exists(gruntfile)) &#123; // 如果存在gruntfile grunt.verbose.writeln().write(msg).ok(); // 修改进程的操作目录，如果有指定base那么使用base目录否则就使用gruntfile所在的目录 process.chdir(grunt.option('base') || path.dirname(gruntfile)); // 在verbose情况下输出Registering Gruntfile tasks信息 loadTasksMessage('Gruntfile'); // 加载gruntfile中的任务 loadTask(gruntfile); &#125; else if (options.help || allInit) &#123; // 如果没找到grunt但是有help参数的话，那么不做任何操作 &#125; else if (grunt.option('gruntfile')) &#123; // 如果指定了gruntfile参数但是找不到文件那么输出错误信息 grunt.log.writeln().write(msg).error(); grunt.fatal('Unable to find \"' + gruntfile + '\" Gruntfile.', grunt.fail.code.MISSING_GRUNTFILE); &#125; else if (!grunt.option('help')) &#123; grunt.verbose.writeln().write(msg).error(); grunt.log.writelns( 'A valid Gruntfile could not be found. Please see the getting ' + 'started guide for more information on how to configure grunt: ' + 'http://gruntjs.com/getting-started' ); grunt.fatal('Unable to find Gruntfile.', grunt.fail.code.MISSING_GRUNTFILE); &#125; // 加载用户指定的npm包 (grunt.option('npm') || []).forEach(task.loadNpmTasks); // 加载用户指定的任务 (grunt.option('tasks') || []).forEach(task.loadTasks);&#125;; 在初始化任务之后grunt.tasks方法会调用task.run方法，将任务添加到任务队列中等待执行。下面是task.run方法的代码，它也是位于lib/util/task.js文件中。123456789101112131415161718192021222324252627282930313233343536373839404142// 将任务加入到队列中Task.prototype.run = function() &#123; // 将参数转换为数组并且根据参数构建任务对象 var things = this.parseArgs(arguments).map(this._taskPlusArgs, this); // 找出无法构建的任务 var fails = things.filter(function(thing) &#123; return !thing.task; &#125;); if (fails.length &gt; 0) &#123; // 如果存在无法构建的任务，抛出错误并返回 this._throwIfRunning(new Error('Task \"' + fails[0].nameArgs + '\" not found.')); return this; &#125; // 将任务加入到任务队列相应的位置 this._push(things); // 支持链式调用 return this;&#125;;// 将任务名分离为真实运行的任务名和参数的对象，比如：// 'foo' ==&gt; 任务名为foo，没有参数// 'foo:bar:baz' ==&gt; 如果'foo:bar:baz'任务存在，那么任务名为'foo:bar:baz'，没有参数// ==&gt; 如果'foo:bar'任务存在，那么任务名为'foo:bar'，参数为'baz'// ==&gt; 如果'foo'任务存在，那么任务名为'foo'，参数为'bar'和'baz'Task.prototype._taskPlusArgs = function(name) &#123; // 将传入的任务名根据冒号转换为数组 var parts = this.splitArgs(name); // 从数组最后开始遍历数组 var i = parts.length; var task; do &#123; // 将0到i的数组转换为任务名，用冒号隔开 // 然后根据得到的任务名从任务缓存中得到相应的任务 task = this._tasks[parts.slice(0, i).join(':')]; // 如果相应任务不存在，那么i减1，知道i等于0 &#125; while (!task &amp;&amp; --i &gt; 0); // 除了任务名以外的部分属于参数 var args = parts.slice(i); // 根据参数列表，得到相应的boolean型标记 var flags = &#123;&#125;; args.forEach(function(arg) &#123; flags[arg] = true; &#125;); // 返回构建的任务对象，包括任务名和任务参数 return &#123;task: task, nameArgs: name, args: args, flags: flags&#125;;&#125;; 在task.run方法中，首先将参数进行分离，分隔出任务名和参数，然后利用任务名和参数构建一个任务对象，最后将这个对象放入任务队列中，参数分离的实现方法为_taskPlusArgs。调用task.run之后，grunt.tasks方法马上就会调用task.start方法运行任务队列中的任务。task.start方法的实现也在lib/util/task.js文件中，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 开始运行任务队列中的任务Task.prototype.start = function(opts) &#123; //初始化opts对象 if (!opts) &#123; opts = &#123;&#125;; &#125; // 如果任务正在运行则退出 if (this._running) &#123; return false; &#125; // 通过nextTask依次运行队列中的任务 var nextTask = function() &#123; // 用来保存从队列中取出的任务对象 var thing; // 取出队列中的元素，直到取出的元素不是placeholder和marker // placeholder用来处理嵌套任务的情况 do &#123; //取出队列中的任务对象 thing = this._queue.shift(); &#125; while (thing === this._placeholder || thing === this._marker); // 如果队列为空，那么完成任务，执行可选的done函数并返回 if (!thing) &#123; this._running = false; if (this._options.done) &#123; this._options.done(); &#125; return; &#125; // 向队列中插入一个placeholder this._queue.unshift(this._placeholder); // 使用取出的任务对象构造任务函数的上下文对象 var context = &#123; // 任务名称:target名称:参数 nameArgs: thing.nameArgs, // 任务名称 name: thing.task.name, // 任务参数，这个参数包括了除了任务名以外的东西，包括target名称和参数 args: thing.args, // 以args为键的键值对，值为true flags: thing.flags &#125;; // 运行任务的注册函数，上下文设置为上面构造的context函数 this.runTaskFn(context, function() &#123; return thing.task.fn.apply(this, this.args); &#125;, nextTask, !!opts.asyncDone); &#125;.bind(this); // 把任务标记为正在运行 this._running = true; // 运行任务队列中的下一个任务 nextTask();&#125;;// 运行任务的注册函数Task.prototype.runTaskFn = function(context, fn, done, asyncDone) &#123; // 标记是否异步 var async = false; // 执行函数完成之后的工作，更新任务状态，执行done函数也就是运行下一个任务 var complete = function(success) &#123; var err = null; if (success === false) &#123; // 任务运行失败，创建错误对象 err = new Error('Task \"' + context.nameArgs + '\" failed.'); &#125; else if (success instanceof Error || &#123;&#125;.toString.call(success) === '[object Error]') &#123; // 如果传入的是错误对象，表示任务执行失败 err = success; success = false; &#125; else &#123; // 任务运行成功 success = true; &#125; // 任务结束后重置当前运行任务 this.current = &#123;&#125;; // 记录任务执行结构 this._success[context.nameArgs] = success; // 如果任务失败则调用错误处理函数 if (!success &amp;&amp; this._options.error) &#123; this._options.error.call(&#123;name: context.name, nameArgs: context.nameArgs&#125;, err); &#125; // 如果指定了异步执行，那么使用node自带的nextTick来运行done // 否则直接运行done if (asyncDone) &#123; process.nextTick(function() &#123; done(err, success); &#125;); &#125; else &#123; done(err, success); &#125; &#125;.bind(this); // 用来支持异步任务，也就是this.async()方法的实现， // 返回函数在异步任务完成时被调用执行complete方法 context.async = function() &#123; async = true; // 返回的函数在任务中的异步工作完成后被调用 return function(success) &#123; setTimeout(function() &#123; complete(success); &#125;, 1); &#125;; &#125;; // 记录当前正在运行的任务上下文 this.current = context; try &#123; // 执行任务的注册函数 var success = fn.call(context); // 如果没有使用this.async // 也就是说async标记为false时在任务完成之后直接调用complete方法 if (!async) &#123; complete(success); &#125; &#125; catch (err) &#123; complete(err); &#125;&#125;; 在task.start方法中定义了一个nextTask方法，方法的作用是依次执行任务队列中的任务，从任务队列中取出任务对象，利用任务对象构建一个上下文对象，然后在这个上下文中执行任务的注册函数，执行完注册函数之后执行队列中的下一个任务。执行注册函数的功能有task.runTaskFn方法实现。在这个方法中定义了一个complele方法，会在任务注册函数执行完成后备调用，进行错误处理工作。同时在task.runTaskFn方法中还向上下文对象context中添加了一个async方法，这个方法就是当我们需要在任务中进行一些异步操作是首先需要调用的方法，调用这个方法之后会返回一个函数，这个函数会异步执行complete方法，如果没有async方法，那么在我们任务中的异步操作还未返回时，grunt内部就会调用complete方法，这样就会造成错误。有了async方法，我们就可以确保complete方法是在我们任务完成之后才被调用。 上面所涉及到的几个方法就是grunt中运行任务过程中主要的几个方法。大家肯定还觉得少了点什么，想要运行任务首先需要在gruntfile.js中注册任务，所以下一次我将和大家分享任务注册相关的源码解析，敬请期待。","raw":null,"content":null,"categories":[],"tags":[{"name":"grunt","slug":"grunt","permalink":"http://bin-playground.top/blog/tags/grunt/"}]},{"title":"看看 Grunt 的源码（一）：grunt-cli 源码解析","slug":"grunt-source-code-1","date":"2015-04-07T01:24:16.000Z","updated":"2016-03-14T01:25:48.159Z","comments":true,"path":"2015/04/07/grunt-source-code-1/","link":"","permalink":"http://bin-playground.top/blog/2015/04/07/grunt-source-code-1/","excerpt":"由于将来工作需要最近学习了Grunt，至于Grunt是什么大家百度下就好了，我就不多说了。对于它内部的实现比较感兴趣，所以看了看源码。今天先来说说grunt命令行工具grunt-cli的实现。 grunt-cli是建立在grunt基础上的命令行工具，通过它可以很方便的使用grunt进行一些自动化任务。grunt-cli的处理过程主要分为下面几步： 加载必须的模块，这其中包括第三方模块和grunt-cli内部的模块 获取命令行参数执行相应的操作 查找grunt.js文件并执行任务","keywords":null,"text":"由于将来工作需要最近学习了Grunt，至于Grunt是什么大家百度下就好了，我就不多说了。对于它内部的实现比较感兴趣，所以看了看源码。今天先来说说grunt命令行工具grunt-cli的实现。 grunt-cli是建立在grunt基础上的命令行工具，通过它可以很方便的使用grunt进行一些自动化任务。grunt-cli的处理过程主要分为下面几步： 加载必须的模块，这其中包括第三方模块和grunt-cli内部的模块 获取命令行参数执行相应的操作 查找grunt.js文件并执行任务 下面的grunt-cli的主要代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/env node'use strict';process.title = 'grunt';//加载文件查找模块,findup用于向上查找var findup = require('findup-sync');//加载路径解析模块var resolve = require('resolve').sync;//加载grunt-cli内部的cli模块//cli模块利用nopt第三方库来获取grunt命令中的参数值var options = require('../lib/cli').options;//加载grunt-cli内部的completion模块//completion模块用来打印自动补全的脚本//这样就可以通过eval \"$(grunt --completion=bash)\"来执行脚本支持自动补全//completion.js内部就是通过参数查找文件最后输出var completion = require('../lib/completion');//加载grunt-cli内部的info模块//用来输出版本信息以及帮助信息的模块//info.js内部主要就是几个输出grunt信息的方法var info = require('../lib/info');//加载node自带的路径解析模块var path = require('path');//获取当前路径var basedir = process.cwd();//grunt.js文件的路径var gruntpath;//判断命令行参数进行相应操作if ('completion' in options) &#123;//如果grunt命令带有--completion参数，则打印相应的自动补全脚本//grunt --completion=bash这个命令基本上只会在设置自动补全的使用//在自动化工作中并不会用到completion.print(options.completion);&#125; else if (options.version) &#123;//如果grunt命令带有--version参数，则打印版本信息info.version();&#125; else if (options.base &amp;&amp; !options.gruntfile) &#123;//如果在grunt命令中指定了base文件夹//那么所有操作都会基于这个文件路径进行basedir = path.resolve(options.base);&#125; else if (options.gruntfile) &#123;//如果grunt命令中指定了gruntfile，那么就会执行这个文件中的任务，同时文件夹切换到对于目录下//默认情况下grunt会在当前目录以及父目录中查找Gruntfile.js或者Gruntfile.coffee文件basedir = path.resolve(path.dirname(options.gruntfile));&#125;try &#123;//得到grunt.js的地址gruntpath = resolve('grunt', &#123;basedir: basedir&#125;);&#125; catch (ex) &#123;//如果在当前路径没找到，向父目录继续查找gruntpath = findup('lib/grunt.js');// No grunt install found!if (!gruntpath) &#123; //无法找到目录 if (options.version) &#123; //如果查询版本信息，由于找不到grunt所以直接退出 process.exit(); &#125; if (options.help) &#123; //显示帮助信息 info.help(); &#125; info.fatal('Unable to find local grunt.', 99);&#125;&#125;//调用grunt执行任务，精彩从这里开始require(gruntpath).cli(); 整个过程比较简单，真正有意思的工作在grunt.js中，后续我会跟大家分享这方面的内容。","raw":null,"content":null,"categories":[],"tags":[{"name":"grunt","slug":"grunt","permalink":"http://bin-playground.top/blog/tags/grunt/"}]},{"title":"[译] 为什么原型继承很重要","slug":"why-prototype-important","date":"2015-03-14T01:34:07.000Z","updated":"2016-03-29T01:58:56.856Z","comments":true,"path":"2015/03/14/why-prototype-important/","link":"","permalink":"http://bin-playground.top/blog/2015/03/14/why-prototype-important/","excerpt":"五天之前我写了一个关于ES6标准中Class的文章。在里面我介绍了如何用现有的Javascript来模拟类并且介绍了ES6中类的用法，其实它只是一个语法糖。感谢Om Shakar以及Javascript Room中的各位，我的编程风格从那时候开始发生了改变；就像Dougla Crockford2006年做的一样，我也学习了很多来完全理解基于原型的编程方式。","keywords":null,"text":"五天之前我写了一个关于ES6标准中Class的文章。在里面我介绍了如何用现有的Javascript来模拟类并且介绍了ES6中类的用法，其实它只是一个语法糖。感谢Om Shakar以及Javascript Room中的各位，我的编程风格从那时候开始发生了改变；就像Dougla Crockford2006年做的一样，我也学习了很多来完全理解基于原型的编程方式。 Javascript是一个多样化的编程语言。它拥有面向对象和函数式的编程特点，你可以使用任何一种风格来编写代码。然而这两个编程风格并不能很好的融合。例如，你不无法同时使用new(典型的面向对象的特点)和apply(函数式编程的特点).原型继承一直都作为连接这两种风格的桥梁。 基于类继承的问题大部分Javascript程序员会告诉你基于类的继承不好。然而它们中只有很少一部分知道其中的原因。事实实际上是基于类的基础并没有什么不好。Python是基于类继承的，并且它是一门很好的编程语言。但是，基于类的继承并不适合用于Javascript。Python正确的使用了类，它们只有简单的工厂方法不能当成构造函数使用。而在Javascript中任何函数都可以被当成构造函数使用。 Javascript中的问题是由于每个函数都可以被当成构造函数使用，所以我们需要区分普通的函数调用和构造函数调用；我们一般使用new关键字来进行区别。然而，这样就破坏了Javascript中的函数式特点，因为new是一个关键字而不是函数。因而函数式的特点无法和对象实例化一起使用。 1234function Person(firstname,lastname)&#123; this.firstname = firstname ; this.lastname = lastname ;&#125; 考虑上面这段程序。你可以通过new关键字来调用Person方法来创建一个函数Person的实例： 1var author = new Person('Aadit','Shah') ; 然而，没有任何办法来使用apply方法来为构造函数指定参数列表： 1var author = new Person.apply(null,['Aadit','Shah']);//error 但是，如果new是一个方法那么上面的需求就可以通过下面这种方式实现了： 1var author = Person.new.apply(Person,['Aadit','Shah']) ; 幸运的是，因为Javascript有原型继承，所以我们可以实现一个new的函数： 1234567Function.prototype.new = function () &#123; function functor() &#123; return constructor.apply(this, args); &#125; var args = Array.prototype.slice.call(arguments); functor.prototype = this.prototype; var constructor = this; return new functor;&#125;; 在像Java这样对象只能通过new关键字来实例化的语言中，上面这种方式是不可能实现的。 下面这张表列出了原型继承相比于基于类的基础的优点： 基于类的继承 原型继承 类是不可变的。在运行时，你无法修改或者添加新的方法 原型是灵活的。它们可以是不可变的也可以是可变的 类可能会不支持多重继承 对象可以继承多个原型对象 基于类的继承比较复杂。你需要使用抽象类，接口和final类等等 原型继承比较简洁。你只有对象，你只需要对对象进行扩展就可以了 不要再使用关键词new了到现在你应该知道为什么我觉得new关键字是不会的了吧—你不能把它和函数式特点混合使用。然后，这并不代表你应该停止使用它。new关键字有合理的用处。但是我仍然建议你不要再使用它了。new关键字掩盖了Javascript中真正的原型继承，使得它更像是基于类的继承。就像Raynos说的: new是Javascript在为了获得流行度而加入与Java类似的语法时期留下来的一个残留物 Javascript是一个源于Self的基于原型的语言。然而，为了市场需求，Brendan Eich把它当成Java的小兄弟推出： 并且我们当时把Javascript当成Java的一个小兄弟，就像在微软语言家庭中Visual Basic相对于C++一样。 这个设计决策导致了new的问题。当人们看到Javascript中的new关键字，他们就想到类，然后当他们使用继承时就遇到了傻了。就像Douglas Crockford说的： 这个间接的行为是为了使传统的程序员对这门语言更熟悉，但是却失败了，就像我们看到的很少Java程序员选择了Javascript。Javascript的构造模式并没有吸引传统的人群。它也掩盖了Javascript基于原型的本质。结果就是，很少的程序员知道如何高效的使用这门语言 因此我建议停止使用new关键字。Javascript在传统面向对象假象下面有着更加强大的原型系统。然大部分程序员并没有看见这些还处于黑暗中。 理解原型继承原型继承很简单。在基于原型的语言中你只有对象。没有类。有两种方式来创建一个新对象—“无中生有”对象创建法或者通过现有对象创建。在Javascript中Object.create方法用来创建新的对象。新的对象之后会通过新的属性进行扩展。 “无中生有”对象创建法Javascript中的Object.create方法用来从0开始创建一个对象，像下面这样: 1var object = Object.create(null) ; 上面例子中新创建的object没有任何属性。 克隆一个现有的对象Object.create方法也可以克隆一个现有的对象，像下面这样: 123456var rectangle = &#123; area : function()&#123; return this.width * this.height ; &#125;&#125; ;var rect = Object.create(rectangle) ; 上面例子中rect从rectangle中继承了area方法。同时注意到rectangle是一个对象字面量。对象字面量是一个简洁的方法用来创建一个Object.prototype的克隆然后用新的属性来扩展它。它等价于: 1234var rectangle = Object.create(Object.prototype) ;rectangle.area = function()&#123; return this.width * this.height ;&#125; ; 扩展一个新创建的对象上面的例子中我们克隆了rectangle对象命名为rect，但是在我们使用rect的area方法之前我们需要扩展它的width和height属性，像下面这样: 123rect.width = 5 ;rect.height = 10 ;alert(rect.area()) ; 然而这种方式来创建一个对象的克隆然后扩展它是一个非常傻缺的方法。我们需要在每个rectangle对象的克隆上手动定义width和height属性。如果有一个方法能够为我们来完成这些工作就很好了。是不是听起来有点熟悉？确实是。我要来说说构造函数。我们把这个函数叫做create然后在rectangle对象上定义它: 12345678910111213var rectangle = &#123; create : function(width,height)&#123; var self = Object.create(this) ; self.height = height ; self.width = width ; return self ; &#125; , area : function()&#123; return this.width * this.height ; &#125;&#125; ;var rect = rectangle.create(5,10) ;alert(rect.area()) ; 构造函数 VS 原型等等。这看起来很像Javascript中的正常构造模式: 123456789101112function Rectangle(width, height) &#123; this.height = height; this.width = width;&#125; ;Rectangle.prototype.area = function () &#123; return this.width * this.height;&#125;;var rect = new Rectangle(5, 10);alert(rect.area()); 是的，确实很像。为了使得Javascript看起来更像Java原型模式被迫屈服于构造模式。因此每个Javascript中的函数都有一个prototype对象然后可以用来作为构造器(这里构造器的意思应该是说新的对象是在prototype对象的基础上进行构造的)。new关键字允许我们把函数当做构造函数使用。它会克隆构造函数的prototype属性然后把它绑定到this对象中，如果没有显式返回对象则会返回this。 原型模式和构造模式都是平等的。因此你也许会怀疑为什么有人会困扰于是否应该使用原型模式而不是构造模式。毕竟构造模式比原型模式更加简洁。但是原型模式相比构造模式有许多优势。具体如下： 构造模式 原型模式 函数式特点无法与new关键字一起使用 函数式特点可以与create结合使用 忘记使用new会导致无法预期的bug并且会污染全局变量 由于create是一个函数，所以程序总是会按照预期工作 使用构造函数的原型继承比较复杂并且混乱 使用原型的原型继承简洁易懂 最后一点可能需要解释一下。使用构造函数的原型继承相比使用原型的原型继承更加复杂，我们先看看使用原型的原型继承: 123456var square = Object.create(rectangle);square.create = function (side) &#123; return rectangle.create.call(this, side, side);&#125; ;var sq = square.create(5) ;alert(sq.area()) ; 上面的代码很容易理解。首先我们创建一个rectangle的克隆然后命名为square。接着我们用新的create方法重写square对象的create方法。最终我们从新的create方法中调用rectangle的create函数并且返回对象。相反的，使用构造函数的原型继承像下面这样: 1234567891011function Square()&#123; Rectangle.call(this,side,side) ;&#125; ;Square.prototype = Object.create(Rectangle.prototype) ;Square.prototype.constructor = Square ;var sq = new Square(5) ;alert(sq.area()) ; 当然，构造函数的方式更简单。然后这样的话，向一个不了解情况的人解释原型继承就变得非常困难。如果想一个了解类继承的人解释则会更加困难。 当使用原型模式时一个对象继承自另一个对象就变得很明显。当使用方法构造模式时就没有这么明显，因为你需要根据其他构造函数来考虑构造继承。 对象创建和扩展相结合在上面的例子中我们创建一个rectangle的克隆然后命名为square。然后我们利用新的create属性扩展它，重写继承自rectangle对象的create方法。如果把这两个操作合并成一个就很好了，就像对象字面量是用来创建Object.prototype的克隆然后用新的属性扩展它。这个操作叫做extend，可以像下面这样实现: 123456789101112Object.prototype.extend = function(extension)&#123; var hasOwnProperty = Object.hasOwnProperty ; var object = Object.create(this) ; for(var property in extension)&#123; if(hasOwnProperty.call(extension,property) || typeof obejct[property] === 'undefined') //这段代码有问题，按照文章意思，这里应该使用深复制，而不是简单的浅复制,deepClone(extension[property],object[property]),deepClone的实现可以看我之前关于继承的博客 object[properyty] = extension[property] ; &#125; return object ;&#125; ; 译者注：我觉得博主这里的实现有点不符合逻辑，正常extend的实现应该是可以配置当被扩展对象和用来扩展的对象属性重复时是否覆盖原有属性，而博主的实现就只是简单的覆盖。同时博主的实现在if判断中的做法个人觉得是值得学习的，首先判断extension属性是否是对象自身的，如果是就直接复制到object上，否则再判断object上是否有这个属性，如果没有那么也会把属性复制到object上，这种实现的结果就使得被扩展的对象不仅仅只扩展了extension中的属性，还包括了extension原型中的属性。不难理解，extension原型中的属性会在extension中表现出来，所以它们也应该作为extension所具有的特性而被用来扩展object。所以我对这个方法进行了改写: 12345678910111213141516 Object.prototype.extend = function(extension,override)&#123; var hasOwnProperty = Object.hasOwnProperty ; var object = Object.create(this) ; for(var property in extension)&#123; if(hasOwnProperty.call(extension,property) || typeof object[property] === 'undefined')&#123; if(object[property] !== 'undefined')&#123; if(override)&#123; deepClone(extension[property],object[property]) ; &#125; &#125;else&#123; deepClone(extension[property],object[property]) ; &#125; &#125; &#125;&#125;; 利用上面的extend方法，我们可以重写square的代码: 12345678var square = rectangle.extend(&#123; create : function(side)&#123; return rectangle.create.call(this,side,side) ; &#125;&#125;) ;var sq = square.create(5) ;alert(sq.area()) ; extend方法是原型继承中唯一需要的操作。它是Object.create函数的超集，因此它可以用在对象的创建和扩展上。因此我们可以用extend来重写rectangle，使得create函数更加结构化看起来就像模块模式。 1234567891011var rectangle = &#123; create : function(width,height)&#123; return this.extend(&#123; height : height , width : width &#125;) ; &#125;&#125; ;var rect = rectangle.create(5,10) ;alert(rect.area()) ; 原型继承的两种方法一些人可能已经注意到extend函数返回的对象实际上是继承了两个对象的属性，一个是被扩展的对象，另一个是用来扩展的对象。另外从两个对象继承属性的方式也不一样。第一种情况下是通过委派来继承属性(也就是使用Object.create()来继承属性)，第二种情况下使用合并属性的方式来继承属性。 委派(差异化继承)很多Javascript程序员对于差别继承比较熟悉。维基百科是这么解释的: 大部分对象是从其他更一般的对象中得到的，只是在一些很小的地方进行了修改。每个对象通常在内部维护一个指向其他对象的引用列表，这些对象就是该对象本身进行差异化继承的对象。 Javascript中的原型继承是基于差异化继承的。每个对象都有个内部指针叫做[[proto]] (在大部分浏览器中可以通过\\__proto\\__属性访问)，这个指针指向对象的原型。多个对象之间通过内部[[proto]]属性链接起来形成了原型链，链的最后指向null。 当你试图获取一个对象的属性时Javascript引擎会首先查找对象自身的属性。如果在对象上没找到该属性，那么它就会去对象的原型中去查找。以此类推，它会沿着原型链一直查找知道找到或者到原型链的末尾。 12345678function get(object,property)&#123; if(!Object.hasOwnProperty.call(object,property))&#123; var prototype = Object.getPrototypeOf(object) ; if(prototype) return get(prototype,property) ; &#125;else&#123; return object[property] ; &#125;&#125; ; Javascript中属性查找的过程就像上面的程序那样。 克隆(合并式继承)大多数Javascript程序员会觉得复制一个对象的属性到另一个对象上并不是一个正确的继承的方式，因为任何对原始对象的修改都不会反映在克隆的对象上。五天前我会同意这个观点。然而现在我相信合并式继承是原型继承的一种正确方式。对于原始对象的修改可以发送到它的副本来实现真正的原型继承。 合并式继承和代理有他们的优点和缺点。下表列出了它们的优缺点: 代理 合并 任何对于原型的修改都会反映在所有副本上 任何对于原型的修改都需要手动更新到副本中 属性查找效率较低因为需要进行原型链查找 属性查找更搞笑因为继承的属性是通过复制的方式附加在对象本身的 使用Object.create()方法只能继承单一对象 对象可以从任意数量的对象中通过复制继承属性 从多个原型继承上表中最后一点告诉我们对象可以通过合并的方式从多个原型中继承属性。这是一个重要的特点因为这证明原型继承比Java中的类继承更强大并且与C++中的类继承一样强大。为了实现多重继承，你只需要修改extend方法来从多个原型中复制属性。 123456789101112131415161718Object.prototype.extend = function()&#123; var hasOwnProperty = Object.hasOwnProperty ; var object = Object.create(this) ; var length = arguments.length ; var index = length ; while(index)&#123; var extension = arguments[length - (index--)] ; for(var property in extension)&#123; if(hasOwnProperty.call(extension,property)|| typeof object[property] === 'undefined')&#123; //这里同样应该使用深复制 object[property] = extension[property] ; &#125; &#125; &#125; return object;&#125; ; 多重继承是非常有用的因为它提高了代码的可重用性和模块化。对象通过委派继承一个原型对象然后通过合并继承其他属性。比如说你有一个事件发射器的原型，像下面这样： 1234567891011121314151617181920var eventEmitter = &#123; on : function(event,listener)&#123; if(typeof this[event] !== 'undefined') this[event].push(listener) ; else this[event] = [listener] ; &#125; , emit : function(event)&#123; if(typeof this[event] !== 'undefined')&#123; var listeners = this[event] ; var length = listeners.length,index = length ; var args = Array.prototype.slice.call(arguments,1) ; while(index)&#123; var listener = listeners[length - (index--)] ; listener.apply(this,args) ; &#125; &#125; &#125;&#125; ; 现在你希望square表现得像一个事件发射器。因为square已经通过委派的方式继承了rectangle，所以它必须通过合并的方式继承eventEmitter。这个修改可以很容易地通过使用extend方法实现： 1234567891011121314151617var square = rectangle.extend(eventEmitter,&#123; create : function(side)&#123; return rectangle.create.call(this,side,side) ; &#125; , resize : function(newSize)&#123; var oldSize = this.width ; this.width = this.height = newSize ; this.emit('resize',oldSize,newSize) ; &#125;&#125;) ;var sq = square.create(5) ;sq.on('resize',function(oldSize,newSize)&#123; alert('sq resized from ' + oldSize + 'to' + newSize + '.') ;&#125;) ;sq.resize(10) ;alert(sq.area()) ; 在Java中是不可能实现上面的程序的，因为它不支持多重继承。相应的你必须另外再创建一个EventEmitter类或者使用一个EventEmitter接口并且在每个实现该接口的类中分别实现on和emit方法。当然你在C++中不需要面对这个问题。我们都知道Java sucks(呵呵呵)。 Mixin的蓝图(Buleprint)在上面的例子中你肯定注意到eventEmitter原型并没有一个create方法。这是因为你不应该直接创建一个eventEmitter对象。相反eventEmitter是用来作为其他原型的原型。这类原型称为mixin。它们等价于抽象类。mixin用来通过提供一系列可重用的方法来扩展对象的功能。 然而有时候mixin需要私有的状态。例如eventEmitter如果能够把它的事件监听者列表放在私有变量中而不是放在this对象上会安全得多。但是mixin没有create方法来封装私有状态。因此我们需要为mixin创建一个蓝图(blueprint)来创建闭包。蓝图(blueprint)看起来会像是构造函数但是它们并不用像构造函数那样使用。例如： 1234567891011121314151617function eventEmitter()&#123; var evnets = Object.create(null) ; this.on = function(event,listener)&#123; if(typeof events[event] !== 'undefined') events[event].push(listener) ; else events[event] = [listener] ; &#125; ; this.emit = function(event)&#123; if(typeof events[event] !== 'undefined')&#123; var listeners = events[event] ; var length = listeners.length ,index = length ; var args = Array.prototype.slice.call(arguments,1) ; &#125; &#125; ;&#125; ; 一个蓝图用来在一个对象创建之后通过合并来扩展它(我觉得有点像装饰者模式)。Eric Elliot把它们叫做闭包原型。我们可以使用蓝图版本的eventEmitter来重写square的代码，如下： 123456789101112131415161718192021var square = rectangle.extend(&#123; create : function(side)&#123; var self = rectangle.create.call(this,side,side) ; eventEmitter.call(self) ; return self ; &#125; , resize : function(newSize)&#123; var oldSize = this.width ; this.width = this.height = newSize ; this.emit('resize',oldSize,newSize) ; &#125;&#125;) ;var sq = square.create(5) ;sq.on('resize',function(oldSize,newSize)&#123; alert('sq resized from ' + oldSize + 'to' + newSize + '.') ;&#125;) ;sq.resize(10) ;alert(sq.area()) ; 蓝图在Javascript中是独一无二的。它是一个很强大的特性。然而它们也有自己的缺点。下表列出了mixin和蓝图的优缺点： Mixin 蓝图 它们用来扩展对象的原型。因此对象共享同一个原型 它们用来扩展新创建的对象。因此每个对象都是在自己对象本身进行修改 因为缺少封装方法所以不存在私有状态 它们是函数，所以可以封装私有状态 它们是静态原型并且不能被自定义 它们可以传递参数来自定义对象，可以向蓝图函数传递一些用来自定义的参数 修复instanceof操作许多Javascript程序员会觉得使用原型模式来继承违背了语言的精髓。他们更偏向于构造模式因为他们觉得通过构造函数创建的对象才是真正的实例，因为instanceof操作会返回true。然而，这个争论是没有意义的，因为instanceof操作可以像下面这样实现： 12345678Object.prototype.instanceof = function(prototype)&#123; var object = this ; do&#123; if(object === prototype) return true ; var object = Object.getPrototypeOf(object) ; &#125;while(object) ; return false ;&#125; 这个instanceof方法现在可以被用来测试一个对象是否是通过委派从一个原型继承的。例如： 1sq.instanceof(square) ; 然而还是没有办法判断一个对象是否是通过合并的方式从一个原型继承的，因为实例的关联信息丢失了。为了解决这个问题我们将一个原型的所有克隆的引用保存在原型自身中，然后使用这个信息来判断一个对象是否是一个原型的实例。这个可以通过修改extend方法来实现： 1234567891011121314151617181920212223Object.prototype.extend = function()&#123; var hasOwnProperty = Object.hasOwnProperty ; var object = Object.create(this) ; var length = arguments.lenght ; var index = length ; while(index)&#123; var extension = arguments[length - (index--)] ; for(var property in extension)&#123; if(property !== 'clones' &amp;&amp; hasOwnProperty.call(extension,property) || typeof object[property] === 'undefined') object[property] = extension[property] ; if(hasOwnProperty.call(extension,'clones')&#125;) extension.clones.unshift(object) ; else extension.clones = [object] ; &#125; &#125; return object;&#125; ; 通过合并继承自原型的对象形成了一个克隆树，这些树从根对象开始然后向下一直到叶子对象。一个克隆链是一个从根对象到叶子对象的单一路径，这跟遍历原型链很相似。我们可以使用这个信息来判断一个对象是否是通过合并继承自一个原型。 1234567891011121314Object.prototype.instanceof = function(prototype)&#123; if (Object.hasOwnProperty.call(prototype, \"clones\")) var clones = prototype.clones; var object = this; do &#123; if (object === prototype || clones &amp;&amp; clones.indexOf(object) &gt;= 0) return true; var object = Object.getPrototypeOf(o bject); &#125; while (object); return false;&#125; ; 这个instanceof方法现在可以用来判断一个对象是否是通过合并继承自一个原型。例如: 1sq.instanceof(eventEmitter); 在上面的程序中instanceof会返回true如果我妈使用mixin版本的eventEmitter。然而如果我们使用蓝图版本的eventEmitter它会返回false。为了解决这个问题我创建了一个蓝图函数，这个函数接收一个蓝图作为参数，向它添加一个clones属性然后返回一个记录了它的克隆的新蓝图： 1234567891011121314151617181920212223242526272829function blueprint(f)&#123; var g = function()&#123; f.apply(this,arguments) ; g.clones.unshift(this) ; &#125; ; g.clones = [] ; return g ;&#125; ;var eventEmitter = blueprint(function()&#123; var events = Object.create(null); this.on = function (event, listener) &#123; if (typeof events[event] !== \"undefined\") events[event].push(listener); else events[event] = [listener]; &#125;; this.emit = function (event) &#123; if (typeof events[event] !== \"undefined\") &#123; var listeners = events[event]; var length = listeners.length, index = length; var args = Array.prototype.slice.call(arguments, 1); while (index) &#123; var listener = listeners[length - (index--)]; listener.apply(this, args); &#125; &#125; &#125;;&#125;) ; 向原型发送变化上面例子中的clones属性有双重作用。它可以用来判断一个对象是否是通过合并继承自一个原型的，然后他可以用来发送原型改变给所有它的克隆。原型继承相比类继承最大的优势就是你可以修改一个原型在它创建之后。为了使克隆可以继承对于原型的修改，我们创建了一个叫做define的函数： 1234567891011121314Object.prototype.define = function (property, value) &#123; this[property] = value; if (Object.hasOwnProperty.call(this, \"clones\")) &#123; var clones = this.clones; var length = clones.length; while (length) &#123; var clone = clones[--length]; if (typeof clone[property] === \"undefined\") clone.define(property, value); &#125; &#125;&#125;; 现在我们可以修改原型然后这个修改会反映在所有的克隆上。例如我们可以创建创建一个别名addEventListener针对eventEmitter上的on方法： 12345678910111213141516171819202122var square = rectangle.extend(eventEmitter, &#123; create: function (side) &#123; return rectangle.create.call(this, side, side); &#125;, resize: function (newSize) &#123; var oldSize = this.width; this.width = this.height = newSize; this.emit(\"resize\", oldSize, newSize); &#125;&#125;);var sq = square.create(5);eventEmitter.define(\"addEventListener\", eventEmitter.on);sq.addEventListener(\"resize\", function (oldSize, newSize) &#123; alert(\"sq resized from \" + oldSize + \" to \" + newSize + \".\");&#125;);sq.resize(10);alert(sq.area()); 蓝图需要特别注意。尽管对于蓝图的修改会被发送到它的克隆，但是蓝图的新的克隆并不会反映这些修改。幸运的是这个问题的解决方法很简单。我们只需要对blueprint方法进行小小的修改，然后任何对于蓝图的修改就会反映在克隆上了。 12345678910111213141516function blueprint(f) &#123; var g = function () &#123; f.apply(this, arguments); g.clones.unshift(this); var hasOwnProperty = Object.hasOwnProperty; for (var property in g) if (property !== \"clones\" &amp;&amp; hasOwnProperty.call(g, property)) this[property] = g[property]; &#125;; g.clones = []; return g;&#125;; 结论恭喜你。如果你读完了整篇文章并且理解了我所说的东西，你现在就了解了 原型继承并且为什么它很重要。很感谢你们看完了这篇文章。我希望这个博客能帮到你们。原型继承是强大的并且值得更多的信任。然后大部分人从来不明白这个因为Javascript中的原型继承被构造模式所掩盖了。 译者注这篇文章针对几种继承方式进行了对比。文章中说到的几种扩展的方法我觉得是比较有用的。蓝图(blueprint，这个实在不知道该怎么翻译)的扩展方式比较像设计模式中的装饰者模式，通过函数对对象进行扩展，这个是一种比较好玩的扩展方式，可以跟原型继承配合使用。另外文中提到了new关键字的弊端，个人觉得主要的原因还是new关键字的出现掩盖了Javascript本身原型继承的特点，人们自然而然就会想到传统的类继承，这样就无法发挥原型继承的最大威力。最后说到的属性修改传播的问题也挺有意思的，应该会有相应的应用场景。总之，我觉得原型继承相比于传统的类继承提供了更大的灵活性，可以给我们开发者提供很大的发挥空间，不过不管怎样，到最后还是要涉及到基本的原型继承的原理上，所以掌握了原型继承的原理就可以根据不同的应用场景使用各种各样的扩展方式。 原文地址：http://aaditmshah.github.io/why-prototypal-inheritance-matters/","raw":null,"content":null,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://bin-playground.top/blog/tags/javascript/"}]},{"title":"angularjs实践过程中的心得总结","slug":"some-angular-practice","date":"2015-03-10T01:42:58.000Z","updated":"2016-04-01T01:44:29.279Z","comments":true,"path":"2015/03/10/some-angular-practice/","link":"","permalink":"http://bin-playground.top/blog/2015/03/10/some-angular-practice/","excerpt":"利用寒假的时间给我家女神做了一个WebApp作为情人节礼物，一为表表忠心，二为练练手，在过程中也发现一些问题，在此总结总结。这里面除了angular方面的问题，还有一些单页面应用开发过程中的问题。","keywords":null,"text":"利用寒假的时间给我家女神做了一个WebApp作为情人节礼物，一为表表忠心，二为练练手，在过程中也发现一些问题，在此总结总结。这里面除了angular方面的问题，还有一些单页面应用开发过程中的问题。 加载优化WebApp第一个版本完成之后兴高采烈的打开浏览器测试，结果Chrome的加载时间让我大跌眼镜，整整用了八秒钟的时间首页在显示出来，这明显是不可接受的。所以必须进行拆分加载。整个WebApp分为一个首页和三个功能模块，所以很自然把三个模块拆分出来，优先加载首页，在点击导航的时候再依次加载对应模块代码。功能模块的延迟加载实际上就是与功能有关的控制器，服务和路由的延迟加载，所以在拆分加载中遇到的问题就是来自这些方面。首先常用的module.controller的controller定义方式无法满足App启动之后的controller动态定义，也就是说如果在angular启动了App之后再使用module.controller的方式定义controller是无效的，仍然会报controller undefined的错误。这时候就需要使用$controllerProvider的register方法来动态定义controller。功能模块的异步加载自然而然想到了requirejs,具体实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var meng = angular.module('meng',['ionic','ngRoute']) ;//异步加载功能模块var resolveController = function(names)&#123; return &#123; loadController : ['$q','$rootScope',function($q,$rootScope)&#123; var defer = $q.defer() ; require(names,function()&#123; defer.resolve() ; $rootScope.$apply() ; &#125;) ; return defer.promise ; &#125;] &#125;&#125; ;//route configmeng.config( ['$routeProvider','$controllerProvider','$provide','$compileProvider', function($routeProvider,$controllerProvider,$provide,$compileProvider)&#123; meng.register = &#123; controller: $controllerProvider.register, factory: $provide.factory, directive: $compileProvider.directive &#125;; $provide.decorator('$route',function($delegate)&#123; var $route = $delegate ; $route.when = function( path, route ) &#123; $routeProvider.when( path, route ); return this ; &#125;; return $route ; &#125;) ; $routeProvider .when('/',&#123; templateUrl : 'views/main.html' &#125;) .when('/info',&#123; templateUrl : 'views/info.html' &#125;) .when('/task',&#123; templateUrl : 'views/task/task.html', controller : 'taskController', resolve : resolveController(['TaskModule']) &#125;) .when('/wallet',&#123; templateUrl : 'views/wallet/wallet.html', controller : 'walletController', resolve : resolveController(['WalletModule']) &#125;) .when('/note',&#123; templateUrl : 'views/note/note_list.html', controller : 'noteController', resolve : resolveController(['NoteModule']) &#125;) .otherwise('/');&#125;]) ; 上面的实现的关键就是resolveController方法，它在路由过程中利用require方法去加载功能对应的模块代码，在代码加载完成后进行路由跳转。上面省略了require的配置部分，TaskModule，WalletModule，NoteModule分别对于task.js，wallet.js和note.js三个文件。上面代码中还解决了延迟加载中的另一个问题，angular中路由配置是通过$routeProvider完成的，但是这个服务在config的时候才能获取，在App启动之后是无法获取进行路由配置的，而$route对象是随时都可以获取的，所以这里在config过程中对利用angular提供的装饰方法对$route进行了扩展，增加了一个when方法指向$routeProvider的when方法，这样就可以在其他地方对路由进行配置。通过上面的方法进行加载拆分有一个问题，它并没有很好的利用angular中模块化的特性，为了延迟加载功能不得不把原来分为三个module的代码都合并到一个module中，这样破坏了模块的独立性，如何在angular的module上进行延迟加载我还在寻找方法。 ##数据缓存高响应是单页面应用的一大优势，这是因为单页面应用会尽可能少的刷新页面。除了通过减少刷新来提高响应以外，减少不必要的数据交互也是一个关键。而为了减少不必要的数据交互，对数据进行缓存是很有必要的。在首次请求数据返回之后，将数据缓存下来，在下一次请求数据是先在缓存中查找，如果没有再去请求服务器数据，在这个过程中我们必须要保证缓存的数据与服务器数据保持同步，所以在进行增删改的时候需要同时对本地和服务器的数据进行增删改。而我在开发过程中把这部分功能实现放在Model中，这样向上隐藏内部的数据层实现。在数据缓存这方面大家如果有更好的办法，欢迎交流。 ##离线存储HTML5中的ApplicationCache离线存储是一个很好的提高App加载速度的途径，但是它也会给开发过程中带来一些不便，经常出现更新资源但是没有更新manifest文件带来的失误，而且希望更新生效需要进行两次页面刷新，这是比较不方便的。所以这个东西好用确实好用，只是加入离线存储应该放在开发过程的最后，在完成功能实现的前提下再把ApplicationCache加上去，这样可以避免它给开发过程中带来的不便。 ##小结上面所说的三个问题只是目前遇到的主要的三个问题，App还在改进中。对于angular的使用还不够熟练，对于单页面中的组织结构划分和模块化的理解还不够透彻，除了上面所说的问题以外还有几个问题有待继续钻研，比如如何更高效的处理数据缓存，移动设备上点击的击穿现象，还有CSS动画的问题，总之就是多动手多思考少吃零食多睡觉。PS:做了这个App之后发现自己真是不适合做设计，改了又改界面才勉强达到我家女神的要求，再接再厉吧。","raw":null,"content":null,"categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://bin-playground.top/blog/tags/angular/"}]},{"title":"再谈Javascript原型继承","slug":"talk-about-javascript-prototype-inheritance","date":"2014-11-09T01:46:24.000Z","updated":"2016-04-01T01:50:11.638Z","comments":true,"path":"2014/11/09/talk-about-javascript-prototype-inheritance/","link":"","permalink":"http://bin-playground.top/blog/2014/11/09/talk-about-javascript-prototype-inheritance/","excerpt":"真正意义上来说Javascript并不是一门面向对象的语言，没有提供传统的继承方式，但是它提供了一种原型继承的方式，利用自身提供的原型属性来实现继承。Javascript原型继承是一个被说烂掉了的话题，但是自己对于这个问题一直没有彻底理解，今天花了点时间又看了一遍《Javascript模式》中关于原型实现继承的几种方法，下面来一一说明下，在最后我根据自己的理解提出了一个关于继承比较完整的实现，如果大家有不同意见，欢迎建议。","keywords":null,"text":"真正意义上来说Javascript并不是一门面向对象的语言，没有提供传统的继承方式，但是它提供了一种原型继承的方式，利用自身提供的原型属性来实现继承。Javascript原型继承是一个被说烂掉了的话题，但是自己对于这个问题一直没有彻底理解，今天花了点时间又看了一遍《Javascript模式》中关于原型实现继承的几种方法，下面来一一说明下，在最后我根据自己的理解提出了一个关于继承比较完整的实现，如果大家有不同意见，欢迎建议。 原型与原型链说原型继承之前还是要先说说原型和原型链，毕竟这是实现原型继承的基础。在Javascript中，每个函数都有一个原型属性prototype指向自身的原型，而由这个函数创建的对象也有一个__proto__属性指向这个原型，而函数的原型是一个对象，所以这个对象也会有一个__proto__指向自己的原型，这样逐层深入直到Object对象的原型，这样就形成了原型链。下面这张图很好的解释了Javascript中的原型和原型链的关系。 每个函数都是Function函数创建的对象，所以每个函数也有一个__proto__属性指向Function函数的原型。这里需要指出的是，真正形成原型链的是每个对象的__proto__属性，而不是函数的prototype属性，这是很重要的。 原型继承基本模式123456789101112131415161718var Parent = function()&#123; this.name = 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : 1&#125; ;var Child = function()&#123; this.name = 'child' ;&#125; ;Child.prototype = new Parent() ;var parent = new Parent() ;var child = new Child() ;console.log(parent.getName()) ; //parentconsole.log(child.getName()) ; //child 这种是最简单实现原型继承的方法，直接把父类的对象赋值给子类构造函数的原型，这样子类的对象就可以访问到父类以及父类构造函数的prototype中的属性。 这种方法的原型继承图如下： 这种方法的优点很明显，实现十分简单，不需要任何特殊的操作；同时缺点也很明显，如果子类需要做跟父类构造函数中相同的初始化动作，那么就得在子类构造函数中再重复一遍父类中的操作：123456789101112131415161718var Parent = function(name)&#123; this.name = name || 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : 1&#125; ;var Child = function(name)&#123; this.name = name || 'child' ;&#125; ;Child.prototype = new Parent() ;var parent = new Parent('myParent') ;var child = new Child('myChild') ;console.log(parent.getName()) ; //myParentconsole.log(child.getName()) ; //myChild 上面这种情况还只是需要初始化name属性，如果初始化工作不断增加，这种方式是很不方便的。因此就有了下面一种改进的方式。 借用构造函数123456789101112131415161718var Parent = function(name)&#123; this.name = name || 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : 1&#125; ;var Child = function(name)&#123; Parent.apply(this,arguments) ;&#125; ;Child.prototype = new Parent() ;var parent = new Parent('myParent') ;var child = new Child('myChild') ;console.log(parent.getName()) ; //myParentconsole.log(child.getName()) ; //myChild 上面这种方法在子类构造函数中通过apply调用父类的构造函数来进行相同的初始化工作，这样不管父类中做了多少初始化工作，子类也可以执行同样的初始化工作。但是上面这种实现还存在一个问题，父类构造函数被执行了两次，一次是在子类构造函数中，一次在赋值子类原型时，这是很多余的，所以我们还需要做一个改进：123456789101112131415161718var Parent = function(name)&#123; this.name = name || 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : 1&#125; ;var Child = function(name)&#123; Parent.apply(this,arguments) ;&#125; ;Child.prototype = Parent.prototype ;var parent = new Parent('myParent') ;var child = new Child('myChild') ;console.log(parent.getName()) ; //myParentconsole.log(child.getName()) ; //myChild 这样我们就只需要在子类构造函数中执行一次父类的构造函数，同时又可以继承父类原型中的属性，这也比较符合原型的初衷，就是把需要复用的内容放在原型中，我们也只是继承了原型中可复用的内容。上面这种方式的原型图如下： 临时构造函数模式(圣杯模式)上面借用构造函数模式最后改进的版本还是存在问题，它把父类的原型直接赋值给子类的原型，这就会造成一个问题，就是如果对子类的原型做了修改，那么这个修改同时也会影响到父类的原型，进而影响父类对象，这个肯定不是大家所希望看到的。为了解决这个问题就有了临时构造函数模式。1234567891011121314151617181920var Parent = function(name)&#123; this.name = name || 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : 1&#125; ;var Child = function(name)&#123; Parent.apply(this,arguments) ;&#125; ;var F = new Function()&#123;&#125; ;F.prototype = Parent.prototype ;Child.prototype = new F() ;var parent = new Parent('myParent') ;var child = new Child('myChild') ;console.log(parent.getName()) ; //myParentconsole.log(child.getName()) ; //myChild 该方法的原型继承图如下：很容易可以看出，通过在父类原型和子类原型之间加入一个临时的构造函数F，切断了子类原型和父类原型之间的联系，这样当子类原型做修改时就不会影响到父类原型。 我的方法《Javascript模式》中到圣杯模式就结束了，可是不管上面哪一种方法都有一个不容易被发现的问题。大家可以看到我在’Parent’的prototype属性中加入了一个obj对象字面量属性，但是一直都没有用。我们在圣杯模式的基础上来看看下面这种情况：1234567891011121314151617181920212223var Parent = function(name)&#123; this.name = name || 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : 1&#125; ;var Child = function(name)&#123; Parent.apply(this,arguments) ;&#125; ;var F = new Function()&#123;&#125; ;F.prototype = Parent.prototype ;Child.prototype = new F() ;var parent = new Parent('myParent') ;var child = new Child('myChild') ;console.log(child.obj.a) ; //1console.log(parent.obj.a) ; //1child.obj.a = 2 ;console.log(child.obj.a) ; //2console.log(parent.obj.a) ; //2 在上面这种情况中，当我修改child对象obj.a的时候，同时父类的原型中的obj.a也会被修改，这就发生了和共享原型同样的问题。出现这个情况是因为当访问child.obj.a的时候，我们会沿着原型链一直找到父类的prototype中，然后找到了obj属性，然后对obj.a进行修改。再看看下面这种情况：1234567891011121314151617181920212223var Parent = function(name)&#123; this.name = name || 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : 1&#125; ;var Child = function(name)&#123; Parent.apply(this,arguments) ;&#125; ;var F = new Function()&#123;&#125; ;F.prototype = Parent.prototype ;Child.prototype = new F() ;var parent = new Parent('myParent') ;var child = new Child('myChild') ;console.log(child.obj.a) ; //1console.log(parent.obj.a) ; //1child.obj.a = 2 ;console.log(child.obj.a) ; //2console.log(parent.obj.a) ; //2 这里有一个关键的问题，当对象访问原型中的属性时，原型中的属性对于对象来说是只读的，也就是说child对象可以读取obj对象，但是无法修改原型中obj对象引用，所以当child修改obj的时候并不会对原型中的obj产生影响，它只是在自身对象添加了一个obj属性，覆盖了父类原型中的obj属性。而当child对象修改obj.a时，它先读取了原型中obj的引用，这时候child.obj和Parent.prototype.obj是指向同一个对象的，所以child对obj.a的修改会影响到Parent.prototype.obj.a的值，进而影响父类的对象。AngularJS中关于$scope嵌套的继承方式就是模范Javasript中的原型继承来实现的。根据上面的描述，只要子类对象中访问到的原型跟父类原型是同一个对象，那么就会出现上面这种情况，所以我们可以对父类原型进行拷贝然后再赋值给子类原型，这样当子类修改原型中的属性时就只是修改父类原型的一个拷贝，并不会影响到父类原型。具体实现如下：123456789101112131415161718192021222324252627282930313233343536373839var deepClone = function(source,target)&#123; source = source || &#123;&#125; ; target = target || &#123;&#125;; var toStr = Object.prototype.toString , arrStr = '[object array]' ; for(var i in source)&#123; if(source.hasOwnProperty(i))&#123; var item = source[i] ; if(typeof item === 'object')&#123; target[i] = (toStr.apply(item).toLowerCase() === arrStr) ? [] : &#123;&#125; ; deepClone(item,target[i]) ; &#125;else&#123; target[i] = item; &#125; &#125; &#125; return target ;&#125; ;var Parent = function(name)&#123; this.name = name || 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : '1'&#125; ;var Child = function(name)&#123; Parent.apply(this,arguments) ;&#125; ;Child.prototype = deepClone(Parent.prototype) ;var child = new Child('child') ;var parent = new Parent('parent') ;console.log(child.obj.a) ; //1console.log(parent.obj.a) ; //1child.obj.a = '2' ;console.log(child.obj.a) ; //2console.log(parent.obj.a) ; //1 综合上面所有的考虑，Javascript继承的具体实现如下，这里只考虑了Child和Parent都是函数的情况下：1234567891011121314151617181920212223242526272829303132var deepClone = function(source,target)&#123; source = source || &#123;&#125; ; target = target || &#123;&#125;; var toStr = Object.prototype.toString , arrStr = '[object array]' ; for(var i in source)&#123; if(source.hasOwnProperty(i))&#123; var item = source[i] ; if(typeof item === 'object')&#123; target[i] = (toStr.apply(item).toLowerCase() === arrStr) ? [] : &#123;&#125; ; deepClone(item,target[i]) ; &#125;else&#123; target[i] = item; &#125; &#125; &#125; return target ;&#125; ;var extend = function(Parent,Child)&#123; Child = Child || function()&#123;&#125; ; if(Parent === undefined) return Child ; //借用父类构造函数 Child = function()&#123; Parent.apply(this,argument) ; &#125; ; //通过深拷贝继承父类原型 Child.prototype = deepClone(Parent.prototype) ; //重置constructor属性 Child.prototype.constructor = Child ;&#125; ; 总结说了这么多，其实Javascript中实现继承是十分灵活多样的，并没有一种最好的方法，需要根据不同的需求实现不同方式的继承，最重要的是要理解Javascript中实现继承的原理，也就是原型和原型链的问题，只要理解了这些，自己实现继承就可以游刃有余。","raw":null,"content":null,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://bin-playground.top/blog/tags/javascript/"}]},{"title":"有趣的HTML5：离线存储","slug":"html5-offline-cache","date":"2014-10-21T01:50:44.000Z","updated":"2016-04-01T01:52:07.969Z","comments":true,"path":"2014/10/21/html5-offline-cache/","link":"","permalink":"http://bin-playground.top/blog/2014/10/21/html5-offline-cache/","excerpt":"最近由于找工作一直没时间也没有精力更新博客，找工作真是一件苦逼的事情啊。。。不抱怨了，我们来看看HTML5的新特性—离线存储吧。 随着Web App的发展，越来越多的移动端App使用HTML5的方式来开发，除了一些HybridApp以外，其他一部分Web App还是通过浏览器来访问的，通过浏览器访问就需要联网发送请求，这样就使得用户在离线的状态下无法使用App，同时Web App中一部分资源并不是经常改变，并不需要每次都向服务器发出请求，出于这些原因，HTML5提出的一个新的特性：离线存储。通过离线存储，我们可以通过把需要离线存储在本地的文件列在一个manifest配置文件中，这样即使在离线的情况下，用户也可以正常使用App。","keywords":null,"text":"最近由于找工作一直没时间也没有精力更新博客，找工作真是一件苦逼的事情啊。。。不抱怨了，我们来看看HTML5的新特性—离线存储吧。 随着Web App的发展，越来越多的移动端App使用HTML5的方式来开发，除了一些HybridApp以外，其他一部分Web App还是通过浏览器来访问的，通过浏览器访问就需要联网发送请求，这样就使得用户在离线的状态下无法使用App，同时Web App中一部分资源并不是经常改变，并不需要每次都向服务器发出请求，出于这些原因，HTML5提出的一个新的特性：离线存储。通过离线存储，我们可以通过把需要离线存储在本地的文件列在一个manifest配置文件中，这样即使在离线的情况下，用户也可以正常使用App。 怎么用首先来讲解下离线存储的使用方法，说起来也很简单。只要在你的页面头部像下面一样加入一个manifest的属性就可以了。1234&lt;!DOCTYPE HTML&gt;&lt;html manifest = \"cache.manifest\"&gt;...&lt;/html&gt; 然后cache.manifest文件的书写方式，就像下面这样：12345678910111213CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/ /offline.html 离线存储的manifest一般由三个部分组成:1.CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。2.NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。3.FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。 浏览器怎么解析manifest那么浏览器是怎么对离线的资源进行管理和加载的呢？这里需要分两种情况来讨论。 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 这个过程中有几个问题需要注意。 如果服务器对离线的资源进行了更新，那么必须更新manifest文件之后这些资源才能被浏览器重新下载，如果只是更新了资源而没有更新manifest文件的话，浏览器并不会重新下载资源，也就是说还是使用原来离线存储的资源。 对于manifest文件进行缓存的时候需要十分小心，因为可能出现一种情况就是你对manifest文件进行了更新，但是http的缓存规则告诉浏览器本地缓存的manifest文件还没过期，这个情况下浏览器还是使用原来的manifest文件，所以对于manifest文件最好不要设置缓存。 浏览器在下载manifest文件中的资源的时候，它会一次性下载所有资源，如果某个资源由于某种原因下载失败，那么这次的所有更新就算是失败的，浏览器还是会使用原来的资源。 在更新了资源之后，新的资源需要到下次再打开app才会生效，如果需要资源马上就能生效，那么可以使用window.applicationCache.swapCache()方法来使之生效，出现这种现象的原因是浏览器会先使用离线资源加载页面，然后再去检查manifest是否有更新，所以需要到下次打开页面才能生效。 咱们来试试吧说了这么多，不如自己动手来试试。这里需要说明的是，如果需要看到离线存储的效果，那么你需要把你的网页部署到服务器上，不管是本地还是生产环境服务器中，通过本地文件打开网页是无法体验到离线存储的。我在我的电脑上跑了一个本地node服务器，通过localhost访问。我的manifest文件向下面这样：123456789101112131415161718CACHE MANIFEST#v0.11CACHE:lib/ionic/js/ionic.bundle.jslib/angular-ui-router.jsjs/app.jslib/ionic/css/ionic.csscss/style.cssviews/login_header.htmlviews/login.htmllib/ionic/fonts/ionicons.ttf?v=1.5.2lib/ionic/fonts/ionicons.woff?v=1.5.2NETWORK:lib/ionic/fonts/ionicons.ttf?v=1.5.2lib/ionic/fonts/ionicons.woff?v=1.5.2css/style.css 然后我们访问网页看看效果。 可以看出浏览器根据manifest文件下载相应资源并且缓存在本地，现在我们来试试再次访问网页 资源已经离线存储在本地，所以浏览器不需要再次下载资源，可以直接使用本地缓存的资源。接着，我们更新下服务器上的资源，比如我修改下app.js，结果我这里就不显示了，跟上面那张图是一样的，更新的资源并没有生效，现在我们更新下manifest文件，比如把版本改为0.12 很显然，只有更新了manifest文件，对离线资源的更新才能在浏览器上生效。最后，我们来试试离线状态下是什么情况，这才是离线存储的重头戏。通过Chrome设置离线状态，刷新页面 由于在离线状态，所以浏览器无法访问到manifest文件，但是网页还是可以正常访问，这就是离线存储的威力。对于HTML5中离线存储对象window.applicationCache有几个事件需要我们关注下： 1.oncached:当离线资源存储完成之后触发这个事件，这个是文档的说法，我在Chrome上面测试的时候并没有触发这个事件。2.onchecking:当浏览器对离线存储资源进行更新检查的时候会触发这个事件3.ondownloading:当浏览器开始下载离线资源的时候会触发这个事件4.onprogress:当浏览器在下载每一个资源的时候会触发这个事件，每下载一个资源就会触发一次。5.onupdateready:当浏览器对离线资源更新完成之后会触发这个事件6.onnoupdate:当浏览器检查更新之后发现没有资源更新的时候触发这个事件 参考文章：https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cachehttp://diveintohtml5.info/offline.html","raw":null,"content":null,"categories":[],"tags":[{"name":"ApplicationCache","slug":"ApplicationCache","permalink":"http://bin-playground.top/blog/tags/ApplicationCache/"}]},{"title":"CSS那些事","slug":"something-about-css","date":"2014-08-08T01:52:39.000Z","updated":"2016-04-01T02:07:40.037Z","comments":true,"path":"2014/08/08/something-about-css/","link":"","permalink":"http://bin-playground.top/blog/2014/08/08/something-about-css/","excerpt":"今天跟大家分享一下CSS中一些比较重要和比较容易被忽略的东西，开始吧。","keywords":null,"text":"今天跟大家分享一下CSS中一些比较重要和比较容易被忽略的东西，开始吧。 样式优先级当你在不同地方不同的选择器中对同一个元素属性添加了不同的样式的时候，该如何判断最后哪个样式会作用到元素上呢？判断的依据就是样式的优先级。样式优先级的判断分为三个步骤： 首先，根据样式的来源和重要性进行分组，一共可以分成五组(优先级从高到低) 用户自定义样式中带!important的样式 作者样式中带!important的样式 作者样式 用户自定义样式 浏览器样式 然后，如果在第一步中无法分出胜负，那么就根据选择器的权重进行判断。每种CSS选择器都有各自的权重，权重从大到小排列分别是： ID选择器 类选择器，伪类选择器，属性选择器 标签选择器，伪元素选择器 在计算样式优先级的时候除了考虑选择器的权重以外，当然还需要考虑内联样式和外联样式，很明显内联样式的优先级比外联的高，那么它的权重也大。综合这两种情况我们就有下面这样的计算方式：1234行内样式 1,0,0,0ID选择器 0,n,0,0类选择器，伪类选择器，属性选择器 0,0,n,0标签选择器，伪元素选择器 0,0,0,n 在上面n代表对应选择器的个数。根据这个方法，每组选择器都会有一个这样的四位数来表示权重，哪个选择器的数字权重越大它们的样式优先级就越高。比如下面几组选择器的权重123div .one&#123;&#125; 0,0,1,1div #one&#123;&#125; 0,1,0,1div a[href=\"one\"] #one&#123;&#125;0,1,1,2 在这一步计算样式优先级的时候有两个特殊情况，一个是通配符选择器它的权重是0,0,0,0，另一个是继承的样式没有优先级，也就是说它连0都没有。这两个特殊情况就会造成一种现象：1234567891011#out *&#123; color:green;&#125;#out #in&#123; color:black;&#125;&lt;div id=\"out\"&gt; &lt;div id=\"in\"&gt; &lt;div id=\"iin\"&gt;TEST&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 上面代码的结果是字体颜色为绿色而不是很多人想的黑色。在这段代码中，TEST有两个color样式，一个是#out *中的，一个是从#in中继承的，最后前者取得了胜利，就是因为继承的样式没有优先级，它连通配符都不如。所以说在重置样式的时候使用通配符不是一个好的习惯，因为它可能会带来一些奇怪的现象。 最后，如果第二步之后还是没办法区分出优先级的话，那么就很简单了，后出现的优先级更高。 在平时的开发中，我们应该善用样式的优先级规则，不能一味的通过增加选择器权重来覆盖样式，这样长久之后会使得代码变得无法维护。 参考 http://www.smashingmagazine.com/2010/11/02/the-important-css-declaration-how-and-when-to-use-it/ http://www.smashingmagazine.com/2010/04/07/css-specificity-and-inheritance/ http://css-tricks.com/specifics-on-css-specificity/ http://snook.ca/archives/html_and_css/understanding_c 块级元素块级元素通常独占一行并且在正常流中垂直摆放，可以设置高度和宽度。块级元素在格式化的时候可以分为水平格式化和垂直格式化。在水平方向上，元素的所有横向宽度之和要等于包含块的宽度，也就是要满足下面的等式：margin-left+border-left-width+padding-left+width+padding-right+border-right-right+margin-right=包含块的width。当width为auto时，块级元素的宽度会填满整个包含块。当margin-left和margin-right出现auto时，会根据上面公式计算使得margin-left=margin-right，这也就是设置margin为auto时可以实现居中效果的原因。在垂直方向上，情况就比水平方向上要复杂，因为可能会出现外边距叠加的现象。当height为auto时，跟水平方向不同，height会根据内容的高度来计算。而margin-top和margin-bottom为auto时，会被设置为0。 下面来说说垂直方向上外边距叠加的情况。首先，什么是外边距叠加？ 外边距叠加是指在正常流中毗邻的两个以上块级元素在垂直方向上的外边距发生叠加的现象。 根据上面的定义我们可以发生外边距叠加需要下面几个条件： 元素必须在正常流中，也就是说position不为absolute或fixed，并且没有浮动的元素 元素必须是块级元素，很明显在行内元素上设置上下外边距是没有效果的 发生外边距叠加的元素必须是毗邻的，也就是说两个元素是相邻的两个兄弟元素或者是父子关系的元素，而父子关系中必须是父元素和它的第一个子元素或者最后一个子元素。总结起来就是下面四种情况： 父元素的margin-top和它第一个子元素的margin-top 父元素的margin-bottom和它最后一个子元素的margin-bottom 元素的margin-bottom和它相邻的兄弟节点的margin-top 元素自身的margin-top和margin-bottom 下面来看前三种情况：DEMO很明显，父元素#out的上外边距和第一个子元素#first的上外边距发生了重叠；然后#first的下外边距和它的兄弟#last的上外边距发生了叠加；最后，父元素#out的下外边距和最后一个子元素#last的下外边距发生了叠加。对于外边距叠加，我觉得下面参考中smallni的总结很好，我就借用他的总结一下： 父元素和它的第一个子元素 父元素没有创建BFC 父子元素之间没有非空内容 父元素没有padding-top和border-top 父元素和它的最后一个子元素 父元素没有创建BFC 父子元素之间没有非空内容 父元素没有padding-bottom和border-bottom 父元素的height为auto，min-height为0 兄弟元素之间 兄弟元素都不是float元素 兄弟元素都不是absolute元素 兄弟元素都不是inline-block元素 根据上面的总结，我们也可以得出防止外边距叠加的方法：对于父子元素之间的情况，大多数情况下都是采用让父元素创建BFC的方式，对于BFC的概念大家可以google一下，这个也是CSS中一个很重要的概念，当然还有一个办法就是添加padding或border；而对于兄弟元素之间的情况，破坏那三条中间任意一条就可以了。讲了外边距叠加，那在发生外边距叠加的时候，元素之间的外边距该怎么计算了，这也需要分几种情况讨论。 如果发生叠加的外边距都是正值，那么就取两者中间最大的那个作为最后的边距 如果发生叠加的外边距都是负值，那么就取两者绝对值较大的那个然后进行负向位移 如果发生叠加的外边距有正有负，那么就把负值中间绝对值最大的那个和正值中最大的相加，最后得出的就是最后的边距最后在进行计算的时候，所有相邻的外边距应该一起参与计算，不能分别进行计算然后再加起来。比如下面的情况：12345678910&lt;div style=\"margin:50px 0; background-color:green; width:50px;\"&gt; &lt;div style=\"margin:-60px 0;\"&gt; &lt;div style=\"margin:150px 0;\"&gt;A&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div style=\"margin:-100px 0; background-color:green; width:50px;\"&gt; &lt;div style=\"margin:-120px 0;\"&gt; &lt;div style=\"margin:200px 0;\"&gt;B&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 正确的计算A和B之间边距的方法应该是，取出所有负值然后找绝对值最大的也就是-120，然后在找出正值中最大的200，最后把这两个边距相加得出80，也就是最后A和B之间的边距。 参考 http://www.smallni.com/collapsing-margin/ http://www.w3help.org/zh-cn/kb/006/ 行内元素行内元素在摆放的时候不会产生换行，也就是说行内元素在空间足够的情况下会出现在同一行中。行内元素有几个比较重要的概念： 对于行内元素设置高度和宽度是无效的 内容区：由内容高度所决定的区域 行内框：对于非替换元素(&lt;a&gt;,&lt;span&gt;…)高度由line-height决定，对于替换元素(&lt;img&gt;)高度由内容和内外边距决定 内容区的上下加上line-height与font-size差值的一半就形成了行内框 vertical-align是根据行内框进行对其的记住上面几个概念，对于行内元素的布局应该就能明白了。 边距和边框外边距外边距是什么我就不多说了，这里提几个比较容易误会的地方。首先，当外边距是百分比时，它是根据父元素的宽度进行计算的，上下边距也是根据这个值进行计算。也就是说上下外边距的值也是以父元素的宽度为标准的。其次，大家有时候书写margin属性的时候都喜欢使用缩写的方式，写两个宽度或者一个，可是如果写上三个的话会怎么样呢？浏览器对于外边距的计算有下面几个规则： 当缺少下边距时，使用上边距 当缺少左边距时，使用右边距 当缺少右边距时，使用上边距 用上面这三条规则就可以很好的解释边距缩写的原理了。这个原则对于所有边距和边框的缩写都适用。 内边距对于内边距唯一要说的就是IE盒模型和W3C的盒模型的区别，在IE中padding和border是包括在元素width和height中的，而W3C的盒模型是不包括这两个的。还有一个问题就是内边距为百分比时的计算和内边距一样，都是以父元素的宽度为标准。 边框边框有一个特点就是元素的背景会延续到边框，也就是说边框是覆盖在元素背景之上的。 浮动和定位包含块元素的包含块就是包含元素的那个元素，但是对于不同的元素情况会不一样： 浮动元素的包含块是最近的块级元素祖先的内容区域 绝对定位元素的包含块是最近的有定位的祖先。如果这个祖先是块级元素，那么包含块就是块级元素的边框区域；如果是行内元素，那么包含块就是行内元素的内容区域。 相对定位和static定位的元素的包含块就是最近的块级元素或者行内元素的内容区域 浮动 浮动元素会形成块级元素 浮动元素和块级元素重叠时，块级元素的背景在浮动元素下，而内容在上 浮动元素和行内元素重叠时，行内元素在上看DEMO从上面例子很容易看出浮动元素和块级元素重叠的时候不同的现象。 绝对定位 对于绝对定位在横向方向上也有一个计算公式：left+(margin-left)+(border-left-width)+(padding-left)+width-(padding-right)+(border-right-width)+(margin-right)+right=包含块width这个公式在同时指定了绝对定位并且还指定了外边距的情况下非常有用。 如果绝对定位不指定偏移，那么元素会怎么布局呢？很多人认为是相对于包含块进行定位，其实不是这样的。如果不指定偏移的话，元素会根据原来正常流中的位置进行定位。DEMO如果你在上面添加一个left偏移，你会发现它是在正常流的情况下发生偏移的，只有同时指定了两个方向的偏移，才会根据包含块进行定位。 如果绝对定位的元素没有指定width和height那么我们可以通过设置偏移来对元素进行拉伸。DEMO通过修改偏移，你就可以控制元素的大小。 在同时具有margin和偏移的时候该怎么给元素定位呢？ 非替换元素 如果left,right,width都为auto，那么按照正常流方式进行布局，并且把值为auto的margin-left和margin-right设为0 如果left,right,width都不为auto 如果margin-left和margin-right都为auto，那么根据公式把两个设为相同的长度；如果计算出的长度为负数，那么就把margin-left设为0 如果margin-lef或margin-right其中有一个为auto,那么根据公式计算出auto的值 其他情况，首先把值为auto的margin设为0 如果left不为auto，width根据内容计算值，其他值根据公式进行计算 如果width不为auto，首先按照正常流定位，然后根据公式计算margin的值 如果right不为auto，width根据内容计算，其他值根据公式进行计算 如果left,width不为auto，right根据公式计算 如果left,right不为auto，width的值根据公式计算 如果width,right不为auto，left根据公式计算 替换元素 宽度由内容区决定 如果left和right为auto，那么根据正常流定位 如果left或right为auto，则把对于的值为auto的margin改为0 如果此时，margin都是auto，那么根据公式计算平方剩余长度 如果这时候left还是auto，那么根据公式计算left的值上面这些计算原则就可以解释一个现象，就是之前在网上看到一种绝对居中的方法：DEMO这个方法把绝对定位元素的偏移都设为0，然后通过margin:auto来实现居中，这个方法用上面的原则就可以说通了。 相对定位相对定位相对来说就比较容易了。就两个点： 偏移是根据元素本来在正常流中的位置计算的 相对定位会影响其他元素的定位，相对定位元素会占据它原来的空间","raw":null,"content":null,"categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://bin-playground.top/blog/tags/css/"}]}]}