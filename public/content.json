{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":""},"pages":[],"posts":[{"title":"(译)如何写出友好的README","slug":"writing-a-friendly-readme","date":"2016-09-06T14:46:47.000Z","updated":"2016-09-06T15:13:03.000Z","comments":true,"path":"2016/09/06/writing-a-friendly-readme/","link":"","permalink":"/2016/09/06/writing-a-friendly-readme/","excerpt":"","text":"写在最前面：最近陆续把工作中积累的vue组件开源，在写组件的README的时候不知道该怎么能写得很友(bi)好(ge)一些，想起来之前看的这篇文件，很详细的介绍了写README的几个方面，所以翻译出来跟大家分享下，大家可以根据各自的项目情况来写自己的README。 一个项目的README是非常重要的；别人看到你的开源项目的时候第一个看到的就是README，同时README也常常是项目唯一的文档。你的README对于你的项目来说，就相当于一个公司的官方网站一样，就像网站需要注意很多用户体验一样，我们的README也应该从用户的角度出发。这篇文章将告诉我们如何写一个友好的README-不论对于新手还是对你项目很了解的人来说，这个README都会非常有帮助同时可以满足开发者的需求。我们会利用一个叫做”Paddington”的虚拟的库作为例子，分部分来讲解这些东西。让我们从头开始吧。 项目标题毫无疑问，一个网站最上面一部分应该用来展示最重要的信息。我们可以把这个原则放在我们的README上。所以什么才是最重要的东西呢？正如所起到的作用一样，项目名字是很重要的。所以我们先加上下面这些内容： 上面这个基本可以满足新用户的需求，但是README的头部也需要满足已存在的用户的需求，他们有一些很容易回答的问题。当我访问一个我很熟悉的项目的时候，我会想知道： 最新的版本的多少？ 它构建通过了吗？ 作为一个新用户，我也有一些容易回答的问题： 它是用什么语言写的？ 它支持哪个语言版本？ 它是否通过测试？ 它采用哪种开源证书？ 我们可以通过徽章来回答上面所有的问题！我在项目描述下面加了一行徽章，单独一行不会占据很大的空间同时又能涵盖许多信息： 是不是很好看？我使用了一个叫做shields.io的服务，它提供了一致的徽章图标同时也提供了一个添加自定义徽章的方式，比如开源证书信息。对于头部的最后一部分，如果项目足够简单的话，我们可以添加一个简单的例子。这对于新手理解你的项目是用来干什么的有很大帮助，就像项目描述一样。 我们在头部有限的空间里面涵盖了丰富的内容。好极了！现在我们需要看看一些更具体的问题。如果我们的README会变得很长，那么要导航到某个具体的内容就变得很困难，现在添加一个目录就变得很有意义。 目录目录对于相对比较短的README来说也是很有用的。它解决了信息索引的需求，为用户提供了一些有帮助的跳转链接到文档的不同部分。 如果用户只想要看看使用说明，为什么要让他们滚动页面看到他并不需要的安装指南呢，更何况安装指南只有第一次使用项目的时候会用到。 必要条件现在我们来到文档中对于新用户更有用的部分，我们要确保他们获取他们所需要的信息。这部分就是用来添加所有你项目的必要条件的地方：语言，语言版本，包管理工具，操作系统。 这些内容可以直接写上去或者通过列表来展示，明显列表更清晰一些。这对你来说也很有用，这可以帮你有效的减少因为缺少必要条件而提交的ISSUE的数量。在写必要条件的时候，你应该假设从0基础开始使用你的项目。确保你添加了语言和包管理工具的相关链接，这样你也许能帮助到对于项目一无所知的新手。 用法你的使用手册可能是你README中最重要的部分，如果没有这个很少人可以知道怎么用你的项目。这部分可以用很多种方式来写，这取决于你项目的类型。你也许需要一个API手册，一个web接口或者一个命令行工具；有时需要不只一种。下面这个手册涉及到一个Javascript API，不过你可以把这个方式应用到其他的接口文档上。首先我们需要提到如何获取代码，是通过clone代码还是利用包管理工具来安装。别忘了添加一些有用的链接，来提供一些便利。 当给一个API写文档的时候，尽量保持简单清晰。也就是说先写出接口的主要用例。这可以吸引第一次看的用户。在这个例子中，我们突出了方法的参数和返回类型，并附上的例子。越明确，就能给你减少越多的麻烦。 我们已经涵盖了我们的主要用例，同时指明一些边界用例以及用户在使用过程中会遇到的问题也是很有帮助的。这个可以作为使用手册的子章节放在使用手册的最后。试着包括一些有问题的用户会搜索的关键词。 贡献这部分也是很重要的，这决定了是否会有用户来给你贡献代码。就算你有一个CONTRIBUTING文件，如果一个人没有Github或者开源的经验就很难找到它。这部分应该包括基本信息并且如果你有一个CONTRIBUTING文件应该加上一个链接。增加一个关于如何运行测试和提交pull request的简单介绍，对你来说也很有用。这意味着你review pull request的过程会更加有效率。 支持和版本变化一个关于项目支持状态的章节也是很有用的，特别是当你发布了很多个不同的主版本的时候。这部分对于一些要进行版本迁移的老用户来说非常有帮助。一个完整的迁移指南对于README来说可能太长了，所以我在项目中加入了一个MIGRATION文件，同时在README中添加了链接。如果你有一个对于老版本的支持计划，请突出他们。同时你也可以用一个简单的表格来列出主要的版本和他们支持的最后期限。 证书最后你应该加一个版权信息以及一个项目所使用开源证书的链接。如果没有这些信息很多用户无法使用你的项目，特别是一些大企业。就算你的项目里面有一个LICENSE文件，添加一个证书的链接也是很有用的。 其他部分我们上面介绍的内容并没有包括了README可以写的全部内容。我项目中还包括了其他内容包括： 为什么？ 如果你的项目做了一些其他项目已经做了的事情，或者特别复杂，提供一些解释也是很有帮助的。 共有的问题 一个用来列出经常出现的问题的地方，可以减少重复打开的ISSUE。 例子 一个指向例子的链接。 变更日志 一个关于项目变更日志的描述。 一个完整的README现在我们已经拥有一个友好的README，你可以在这里看到所有内容。我希望更多的人在写文档的时候可以考虑用户的需求，如果你觉得漏了什么请告诉我。我对于如何写好README的建议和想法很感兴趣。","categories":[],"tags":[{"name":"others","slug":"others","permalink":"/tags/others/"}]},{"title":"前端不定期刊(1)","slug":"frontend-undated-periodical-1","date":"2016-04-12T06:47:39.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2016/04/12/frontend-undated-periodical-1/","link":"","permalink":"/2016/04/12/frontend-undated-periodical-1/","excerpt":"自己的RSS已经订阅了很多博客了，里面不乏一些Javascript Weekly之类的订阅，想到自己每天也看到很多不错的博客，也可以通过类似的方式分享出来，所以开设了这么一个东西。就像标题一样这个分享是不定期的，不想用一个时间把自己限定死，只要看到的好文章积累到足够的时候就会发出来跟大家分享，尽量保证文章的质量，今天是第一期，总共九篇文章。","text":"自己的RSS已经订阅了很多博客了，里面不乏一些Javascript Weekly之类的订阅，想到自己每天也看到很多不错的博客，也可以通过类似的方式分享出来，所以开设了这么一个东西。就像标题一样这个分享是不定期的，不想用一个时间把自己限定死，只要看到的好文章积累到足够的时候就会发出来跟大家分享，尽量保证文章的质量，今天是第一期，总共九篇文章。1.Functional Programming for Javascript People https://medium.com/@chetcorcos/functional-programming-for-javascript-people-1915d8775504#.ctixu2ipj介绍Javascript函数式编程的一个文章，讲的比较通俗，也不是很深入，可以作为入门 2.深入理解GraphGL http://taobaofed.org/blog/2016/03/10/graphql-in-depth/淘宝前端团队介绍GraphQL的系列文章，这篇是第一篇，大家可以关注下上面的文章，毕竟大厂文章质量还是有保障的，大家也可以了解下GraphQL，平时开发的时候可以借鉴下 3.Canvas vs SVG: Choosing the Right Tool for the Job http://www.sitepoint.com/canvas-vs-svg-choosing-the-right-tool-for-the-job/对SVG和Canvas做了一个对比，分别说了对应的应用场景，在做动画的时候可以考虑一下 4.前端文本截断 http://efe.baidu.com/blog/text-truncating/总结了前端开发过程中解决文本截断的方法，文本截断是平时开发过程中经常会遇到的问题，视觉设计稿经常只是给出了字符定宽的情况下显示的效果，我们在开发过程中还要考虑文本超长的情况，这篇文章给出了很好的解决方法。 5.Why Everyone is Talking About Isomorphic/Universal Javascript and Why it Matters https://medium.com/capital-one-developers/why-everyone-is-talking-about-isomorphic-universal-javascript-and-why-it-matters-38c07c87905同构应用越来越多的被大家提到，前后端同用一套代码，同时可以利用后端渲染在加速首页的加载，这篇文章介绍了同构应用的由来以及解决的问题。 6.Exploring Angular 1.5:Lifecycle Hooks http://blog.thoughtram.io/angularjs/2016/03/29/exploring-angular-1.5-lifecycle-hooks.htmlAngular1.5作为一个向Angular2过渡的版本，里面加入了许多Angular2的特性，比如Component。这篇文章主要介绍Angular1.5中引入的组件生命周期相关的钩子，虽然Angular2相比较Angular1.X变化很大，但我觉得这并不会影响Angular2普及的速度 7.Top 10 ReactJS Articles From Last Month https://medium.mybridge.co/top-10-reactjs-articles-from-last-month-98978b无意中在Medium上看到了这个Top 10的系列，每个月都会发各种Top 10的Web开发博客，大家可以关注下，另外Medium上的文章质量都不错 8.揭秘微信红包：架构、抢红包算法、高并发和降级方案 http://www.infoq.com/cn/articles/2016-hongbao-weixin-archtecture这篇文章中整体架构上介绍了微信红包如何抗住除夕全天80.8亿个红包的，作为前端可以简单的了解一下 9.CSS Modules 详解及 React 中实践 https://github.com/camsong/blog/issues/5CSS Modules是最近比较火的CSS模块化方案，为了解决CSS模块化组件化过程中遇到的问题，有兴趣的可以看看这篇介绍：CSS Modules:Welcome to the Future","categories":[],"tags":[{"name":"frontend","slug":"frontend","permalink":"/tags/frontend/"}]},{"title":"Github装逼指南——Travis CI 和 Codecov","slug":"use-travis-ci-and-codecov-with-github","date":"2016-02-04T06:47:22.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2016/02/04/use-travis-ci-and-codecov-with-github/","link":"","permalink":"/2016/02/04/use-travis-ci-and-codecov-with-github/","excerpt":"好久没写博客了，趁着年前空闲的时间来一篇轻松点的东西。最近工作中积累了一些Angular组件打算整一整把他们开源了，既然要开源那么代码可靠性就很重要了，单测不能少，为了保证每次提交的代码都能很好的运行，持续集成不能少。之前看到很多开源项目介绍中都有一些单测覆盖率和build结果的图标，就像这样：","text":"好久没写博客了，趁着年前空闲的时间来一篇轻松点的东西。最近工作中积累了一些Angular组件打算整一整把他们开源了，既然要开源那么代码可靠性就很重要了，单测不能少，为了保证每次提交的代码都能很好的运行，持续集成不能少。之前看到很多开源项目介绍中都有一些单测覆盖率和build结果的图标，就像这样： 觉得挺酷的。打算在自己的开源组件中也整一套。经过Google决定使用TravisCI来进行持续集成，Codecov来统计单测覆盖率。 Travis CITravis CI是国外新兴的开源持续集成构建项目，支持Github项目。使用十分方便。 使用Github账号登录Travis CI； 登录之后会自动同步Github项目，选择需要使用Travis CI的项目 在项目的根目录新增.travis.yml文件，内容如下： 1234567891011121314#指定运行环境language: node_js#指定nodejs版本，可以指定多个node_js: - 0.12.5#运行的脚本命令script: - npm run ci#指定分支，只有指定的分支提交时才会运行脚本branches: only: - master 更多语法请看这里。使用起来非常方便，这样当你每次向github push代码的时候，Travis CI就会自动运行.travis.yml里面的script。自动进行编译以及运行单测。由于Travis CI每次build之前都会运行npm install安装项目依赖的npm包，所以在提交代码的时候要保证把所有依赖的包都已经在package.json中声明了，否则build就会失败。 CodecovCodecov是一个开源的测试结果展示平台，将测试结果可视化。Github上许多开源项目都使用了Codecov来展示单测结果。Codecov跟Travis CI一样都支持Github账号登录，同样会同步Github中的项目。在nodejs环境下使用Codecov需要安装对于的npm包，运行下面这个命令进行安装：1npm install codecov --save-dev 这个包的作用是将我们运行单测产生的结果文件上传到Codecov上进行可视化展示。同时codecov支持的结果文件类型为cobertura。所以需要保证单测执行的结果文件的类型为cobertura。前端项目进行单元测试推进karma + ‘jasmine’的组合。这两个具体是什么东西大家Google一下就知道。使用karma可以通过简单的配置来运行单测。下面是我一个项目中的配置文件，供大家参考：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// Karma configuration// Generated on Mon Feb 01 2016 21:34:22 GMT+0800 (中国标准时间)module.exports = function(config) &#123; config.set(&#123; // base path that will be used to resolve all patterns (eg. files, exclude) basePath: '', // frameworks to use // available frameworks: https://npmjs.org/browse/keyword/karma-adapter // 使用的测试框架jasmine, requirejs支持模块化加载 frameworks: ['jasmine', 'requirejs'], // list of files / patterns to load in the browser files: [ // karma中用到进行requirejs配置的文件 'test/test-main.js', // 测试中需要用到的文件，includeed设为false表示在页面加载的时候不会加载相应的js文件，也就是可以通过requirejs进行异步加载 &#123;pattern: 'node_modules/jquery/dist/jquery.min.js', included: false&#125;, &#123;pattern: 'node_modules/angular/angular.min.js', included: false&#125;, &#123;pattern: 'node_modules/angular-mocks/angular-mocks.js', included: false&#125;, &#123;pattern: 'src/bg-single-selector.js', included: false&#125;, &#123;pattern: 'test/selector.spec.js', included: false&#125; ], // list of files to exclude exclude: [ ], // preprocess matching files before serving them to the browser // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor // 针对bg-single-selector.js生成单测覆盖率结果 preprocessors: &#123; 'src/bg-single-selector.js': 'coverage' &#125;, // test results reporter to use // possible values: 'dots', 'progress' // available reporters: https://npmjs.org/browse/keyword/karma-reporter // 测试结果的几种输出方式 reporters: ['progress', 'coverage', 'verbose'], // 测试结果报告的类型 coverageReporter:&#123; reporters: [&#123; type:'text-summary' &#125;, &#123; type: 'html', dir: 'test/coverage' &#125;, &#123; // 这就是Codecov支持的文件类型 type: 'cobertura', subdir: '.', dir: 'test/coverage' &#125;] &#125;, // web server port port: 9876, // enable / disable colors in the output (reporters and logs) colors: true, // level of logging // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG logLevel: config.LOG_INFO, // enable / disable watching file and executing tests whenever any file changes autoWatch: true, // start these browsers // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher browsers: ['PhantomJS'], // 运行测试依赖的插件 plugins: [ 'karma-jasmine', 'karma-coverage', 'karma-verbose-reporter', 'karma-phantomjs-launcher', 'karma-requirejs' ], // Continuous Integration mode // if true, Karma captures browsers, runs the tests and exits singleRun: true &#125;)&#125; 通过karma进行单元测试，将命令写到.travis.yml中就可以在每次build的时候运行单测，同时运行codecov [cobertura-coverage.xml路径]就会把单测结果上传到Codecov。在本地运行codecov会失败，需要将这个过程加入到Travis CI的build脚本中，才能成功上传。因为在本地运行就会被作为私有项目，对于私有项目在上传结果时需要加上Codecov提供的token。 在github中加入图标到了最后一步，Travis CI和Codecov都提供图标链接来展示结果。我们只需要将图标链接加入到项目的README中就可以看到结果了。对于Travis CI来说，点击下图中的图标： 就会弹出图标的地址。对于Codecov来说，打开项目的设置列表就会看到，如下： 最后只需要将对应的链接加到README文件中就可以了。下面是最后的效果： 是不是很赞！项目地址：BGSingleSelector，欢迎大家试用提意见，同时不要吝啬Star。 最后的最后，做一个广告。百度告警平台。这是一个智能的告警平台，提供实时精确的告警送达，故障的协作处理能力。再也不需要担心遗漏监控报警，解放运维人力。","categories":[],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"},{"name":"ci","slug":"ci","permalink":"/tags/ci/"}]},{"title":"看看 Grunt 的源码（三）：grunt 任务注册相关源码解析","slug":"grunt-source-code-3","date":"2015-04-20T06:46:58.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2015/04/20/grunt-source-code-3/","link":"","permalink":"/2015/04/20/grunt-source-code-3/","excerpt":"上一篇分享了关于grunt中任务运行相关源码的解析，这一篇来分享grunt中跟任务注册相关的源码解析，废话不多说，开始吧。","text":"上一篇分享了关于grunt中任务运行相关源码的解析，这一篇来分享grunt中跟任务注册相关的源码解析，废话不多说，开始吧。跟任务注册相关的两个方法是 grunt.registerTask 和grunt.registerMultiTask 。这两个方法都位于 lib/grunt/task.js 文件中。首先来看看 grunt.registerTask 方法的实现，这个方法还涉及到了 lib/util/task.js 文件中的 registerTask 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//lib/grunt/task.jstask.registerTask = function(name) &#123; // 将任务加入到registry中 registry.tasks.push(name); // 调用parent的registerTask方法注册任务 parent.registerTask.apply(task, arguments); // 调用parent.registerTask方法之后，任务会被加入到_tasks缓存中 var thisTask = task._tasks[name]; // 复制任务的元数据 thisTask.meta = grunt.util._.clone(registry.meta); // 对注册的任务函数进行封装 // 在真实函数执行之前进行一些预处理 var _fn = thisTask.fn; thisTask.fn = function(arg) &#123; // 缓存任务名称 var name = thisTask.name; // 初始化任务的errorcount errorcount = grunt.fail.errorcount; // 返回任务运行期间的errorcount Object.defineProperty(this, 'errorCount', &#123; enumerable: true, get: function() &#123; return grunt.fail.errorcount - errorcount; &#125; &#125;); // 将task.requires方法添加到this对象中 this.requires = task.requires.bind(task); // 将grunt.config.requires方法添加到this对象中 this.requiresConfig = grunt.config.requires; // options方法返回任务的相关option参数，可以通过参数覆盖默认的配置 this.options = function() &#123; var args = [&#123;&#125;].concat(grunt.util.toArray(arguments)).concat([ grunt.config([name, 'options']) ]); var options = grunt.util._.extend.apply(null, args); grunt.verbose.writeflags(options, 'Options'); return options; &#125;; // 初始化log输出工作 var logger = _fn.alias || (thisTask.multi &amp;&amp; (!arg || arg === '*')) ? 'verbose' : 'log'; grunt[logger].header('Running \"' + this.nameArgs + '\"' + (this.name !== this.nameArgs ? ' (' + this.name + ')' : '') + ' task'); grunt[logger].debug('Task source: ' + thisTask.meta.filepath); // 运行真实注册的任务函数 return _fn.apply(this, arguments); &#125;; return task;&#125;;//lib/util/task.js// 注册任务Task.prototype.registerTask = function(name, info, fn) &#123; // 如果没有传递info，调整参数 // 比如grunt.registerTask('taskName',function()&#123;&#125;)的情况 // 这时候info为function函数，所以把info赋值给fn if (fn == null) &#123; fn = info; info = null; &#125; // 如果fn是字符串或者字符串数组 // 比如grunt.registerTask('task',['task1','task2','task3'])的情况 var tasks; if (typeof fn !== 'function') &#123; // 针对上面的情况，这时候tasks=['task1','task2','task3'] tasks = this.parseArgs([fn]); // 将任务的函数改为将每个子任务添加到任务队列中 // 也就是分别将task1,task2和task3加入任务队列中 fn = this.run.bind(this, fn); fn.alias = true; // 这种情况下task相当于task1,task2和task3任务组合的别名 if (!info) &#123; info = 'Alias for \"' + tasks.join('\", \"') + '\" task' + (tasks.length === 1 ? '' : 's') + '.'; &#125; &#125; else if (!info) &#123; info = 'Custom task.'; &#125; // 将任务加入到缓存中 this._tasks[name] = &#123;name: name, info: info, fn: fn&#125;; // 返回任务对象，支持链式调用 return this;&#125;; 在 registerTask 方法中，首先会调用 lib/util/task.js 中的 registerTask 方法，而在这个方法中会修正方法的参数，然后将任务对象加入到任务缓存中；接着回到 registerTask 方法中对注册的函数进行封装，在封装的函数中会在函数执行前进行一些初始化工作，最后再执行注册函数。 下面来看看 grunt.registerMultiTask 方法的实现。这个方法是针对具有多个target的任务的注册。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 组成含有多target的tasktask.registerMultiTask = function(name, info, fn) &#123; // 针对grunt.registerMultiTask('taskName',function()&#123;&#125;)的情况 if (fn == null) &#123; fn = info; info = 'Custom multi task.'; &#125; var thisTask; task.registerTask(name, info, function(target) &#123; var name = thisTask.name; // 获得除了任务名以外的参数 this.args = grunt.util.toArray(arguments).slice(1); // 如果没有指定target或者指定为*，那么运行所以target if (!target || target === '*') &#123; return task.runAllTargets(name, this.args); &#125; else if (!isValidMultiTaskTarget(target)) &#123; // 如果存在不合法的target则抛出错误 throw new Error('Invalid target \"' + target + '\" specified.'); &#125; // 判断是否存在对应target的配置 this.requiresConfig([name, target]); // options方法返回任务的相关option参数，可以通过参数覆盖默认的配置 this.options = function() &#123; var targetObj = grunt.config([name, target]); var args = [&#123;&#125;].concat(grunt.util.toArray(arguments)).concat([ grunt.config([name, 'options']), grunt.util.kindOf(targetObj) === 'object' ? targetObj.options : &#123;&#125; ]); var options = grunt.util._.extend.apply(null, args); grunt.verbose.writeflags(options, 'Options'); return options; &#125;; // 将target添加到this对象中 this.target = target; // 为this对象添加flags属性，并且初始化flags对象 // flags对象用来记录参数列表中是否存在对象的参数 // 如果存在值为true this.flags = &#123;&#125;; this.args.forEach(function(arg) &#123; this.flags[arg] = true; &#125;, this); // 将target的对于配置添加到this对象中 // 这个配置也就是我们通过initConfig定义的配置 this.data = grunt.config([name, target]); // 将封装之后的files对象添加到this对象中 this.files = task.normalizeMultiTaskFiles(this.data, target); // 将src的相关值添加到this的filesSrc属性中 Object.defineProperty(this, 'filesSrc', &#123; enumerable: true, get: function() &#123; return grunt.util._(this.files).chain().pluck('src').flatten().uniq().value(); &#125;.bind(this) &#125;); // 调用任务注册函数，传入相应参数 return fn.apply(this, this.args); &#125;); // 缓存任务 thisTask = task._tasks[name]; // 将任务标记为多任务 thisTask.multi = true;&#125;; 在 registerMultiTask 方法中会调用 registerTask 方法注册任务，而在注册的函数中首先会根据传入的target执行相应操作，如果没有传入target或者传入 * 那么就调用 runAllTargets 方法将所有target都加入任务队列中，否则执行对应的target，接着获取target的相应配置，调用 normalizeMultiTaskFiles 方法将配置数据转换为内部的file对象（PS：这个过程是grunt比较方便的一个地方，它有多种形式来定义文件路径之间的映射，并且支持多种表达式，file对象也是我一开始看grunt的东西，觉得这很神奇。后面我会说到这个方法），最后调用任务实际注册的函数。 下面我们就来看看 normalizeMultiTaskFiles 方法的具体实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152task.normalizeMultiTaskFiles = function(data, target) &#123; var prop, obj; var files = []; if (grunt.util.kindOf(data) === 'object') &#123; if ('src' in data || 'dest' in data) &#123; /* *Compact Format的情况，比如： *'bar' : &#123; * 'src' : ['a.js','b.js'] , * 'dest' : 'c.js' *&#125; */ obj = &#123;&#125;; // 将除了options以外的配置复制到obj对象中 for (prop in data) &#123; if (prop !== 'options') &#123; obj[prop] = data[prop]; &#125; &#125; files.push(obj); &#125; else if (grunt.util.kindOf(data.files) === 'object') &#123; /* *Files Object Format的情况，比如： *'bar' : &#123; * 'files' : &#123; * 'c.js' : ['a.js','b.js'] * &#125; *&#125; */ for (prop in data.files) &#123; files.push(&#123;src: data.files[prop], dest: grunt.config.process(prop)&#125;); &#125; &#125; else if (Array.isArray(data.files)) &#123; /* *Files Array Format的情况，比如： *'bar' : &#123; * 'files' : [ * &#123;'src':['a.js','b.js'],'dest':'c.js'&#125;, * &#123;'src':['a.js','b.js'],'dest':'d.js'&#125; * ] *&#125; */ grunt.util._.flatten(data.files).forEach(function(obj) &#123; var prop; if ('src' in obj || 'dest' in obj) &#123; files.push(obj); &#125; else &#123; for (prop in obj) &#123; files.push(&#123;src: obj[prop], dest: grunt.config.process(prop)&#125;); &#125; &#125; &#125;); &#125; &#125; else &#123; /* *Older Format的情况，比如： *'bar' : ['a.js','b.js'] */ files.push(&#123;src: data, dest: grunt.config.process(target)&#125;); &#125; // 如果没找到合法的文件配置对象，那么返回空的文件数组 if (files.length === 0) &#123; grunt.verbose.writeln('File: ' + '[no files]'.yellow); return []; &#125; // 对需要扩展的文件对象进行扩展 files = grunt.util._(files).chain().forEach(function(obj) &#123; // 调整obj.src属性，使其成为一维数组 // 如果不存在src属性，则直接返回不需要进行任何操作 if (!('src' in obj) || !obj.src) &#123; return; &#125; // 如果obj.src是数组则压缩成一维数组，否则直接转换为数组 if (Array.isArray(obj.src)) &#123; obj.src = grunt.util._.flatten(obj.src); &#125; else &#123; obj.src = [obj.src]; &#125; &#125;).map(function(obj) &#123; // 在obj的基础上创建对象，移除不需要的属性，处理动态生成src到dest的映射 var expandOptions = grunt.util._.extend(&#123;&#125;, obj); delete expandOptions.src; delete expandOptions.dest; // 利用expand中的配置，扩展文件映射关系，并返回扩展后的file对象 if (obj.expand) &#123; return grunt.file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) &#123; // 将obj对象复制为result对象 var result = grunt.util._.extend(&#123;&#125;, obj); // 将obj对象复制为result的orig属性 result.orig = grunt.util._.extend(&#123;&#125;, obj); // 如果src或dest为模板，则解析为真正的路径 result.src = grunt.config.process(mapObj.src); result.dest = grunt.config.process(mapObj.dest); // 移除不需要的属性 ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function(prop) &#123; delete result[prop]; &#125;); return result; &#125;); &#125; // 复制obj对象，并且向副本添加一个orig属性，属性的值也是obj对象的一个副本 // 保存一个obj的副本orig是因为在后面可能会对result中的属性进行修改 // orig使得result中可以访问到原始的file对象 var result = grunt.util._.extend(&#123;&#125;, obj); result.orig = grunt.util._.extend(&#123;&#125;, obj); if ('src' in result) &#123; // 如果result对象中具有src属性，那么给src属性添加一个get方法， // 方法中对src根据expand进行扩展 Object.defineProperty(result, 'src', &#123; enumerable: true, get: function fn() &#123; var src; if (!('result' in fn)) &#123; src = obj.src; // 将src转换为数组 src = Array.isArray(src) ? grunt.util._.flatten(src) : [src]; // 根据expand参数扩展src属性，并把结果缓存在fn中 fn.result = grunt.file.expand(expandOptions, src); &#125; return fn.result; &#125; &#125;); &#125; if ('dest' in result) &#123; result.dest = obj.dest; &#125; return result; &#125;).flatten().value(); // 如果命令行带有--verbose参数，则在log中输出文件路径 if (grunt.option('verbose')) &#123; files.forEach(function(obj) &#123; var output = []; if ('src' in obj) &#123; output.push(obj.src.length &gt; 0 ? grunt.log.wordlist(obj.src) : '[no src]'.yellow); &#125; if ('dest' in obj) &#123; output.push('-&gt; ' + (obj.dest ? String(obj.dest).cyan : '[no dest]'.yellow)); &#125; if (output.length &gt; 0) &#123; grunt.verbose.writeln('Files: ' + output.join(' ')); &#125; &#125;); &#125; return files;&#125;; grunt提供了多种格式来进行文件参数的配置，normalizeMultiTaskFiles方法会将相应target的配置转换为一个files数组，这个数组中存放的是每对文件的源地址和目的地址，该方法还负责对expand属性相关参数进行解析，最后生成多个源地址和目的地址对存在在files数组中。这个方法大大方便了grunt中关于文件的操作和配置。 到这里 grunt 源码的解析就差不多了，更多的东西需要不断在实践中去理解，关于源码的详细注释请看 这里。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"看看 Grunt 的源码（二）：grunt 任务运行相关源码解析","slug":"grunt-source-code-2","date":"2015-04-19T06:46:55.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2015/04/19/grunt-source-code-2/","link":"","permalink":"/2015/04/19/grunt-source-code-2/","excerpt":"上一篇分享了关于grunt-cli的源码解析，这篇开始grunt核心部分代码的解析，还是从上一篇结束部分开始。","text":"上一篇分享了关于grunt-cli的源码解析，这篇开始grunt核心部分代码的解析，还是从上一篇结束部分开始。12//调用grunt执行任务require(gruntpath).cli(); gruntpath是通过解析得到的grunt.js的文件路径，通过require方法加载grunt模块然后调用模块的cli方法来运行命令行最后运行命令行中的任务。 我们先从大体上看看grunt从输入命令行到任务运行完毕整个过程中都经过了哪些步骤。下图是我根据源码得出的一个流程图。 首先，我们输入命令行之后调用require(gruntpath).cli()方法，在cli方法中会初始化命令行的默认参数列表，解析输入命令行的参数以及任务名称 然后调用grunt.tasks方法，将任务参数和名称传入。在grunt.tasks方法中，会进一步对参数进行解析，初始化log功能，如果参数带有version或者help选项那么直接执行相应的函数，否则就解析任务名称。 接着调用task.init方法。加载Gruntfile.js文件，注册任务信息以及配置信息。 接着调用task.run方法。task.run方法并不会运行任务，而是把任务相关信息添加到任务队列中。 最后才是调用task.start方法来依次运行任务队列中的任务。下面来一步步解析grunt核心源码。首先，来看看lib/grunt/cli.js文件中的代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 执行命令行时执行的函数var cli = module.exports = function(options, done) &#123; // 利用传递的参数设置cli.options对象，但是不覆盖命令行的参数 if (options) &#123; Object.keys(options).forEach(function(key) &#123; if (!(key in cli.options)) &#123; // 如果输入的命令行中不存在这个参数，那么把它加入到cli的options属性中 cli.options[key] = options[key]; &#125; else if (cli.optlist[key].type === Array) &#123; // 如果输入的命令行中存在这个参数，并且参数的类型是数组，那么把它加入到数组尾部 [].push.apply(cli.options[key], options[key]); &#125; &#125;); &#125; // 运行任务 grunt.tasks(cli.tasks, cli.options, done);&#125;;// 默认的参数选项列表var optlist = cli.optlist = &#123; help: &#123; short: 'h', info: 'Display this help text.', type: Boolean &#125;, base: &#123; info: 'Specify an alternate base path. By default, all file paths are relative to the Gruntfile. ' + '(grunt.file.setBase) *', type: path &#125;, color: &#123; info: 'Disable colored output.', type: Boolean, negate: true &#125;, gruntfile: &#123; info: 'Specify an alternate Gruntfile. By default, grunt looks in the current or parent directories ' + 'for the nearest Gruntfile.js or Gruntfile.coffee file.', type: path &#125;, debug: &#123; short: 'd', info: 'Enable debugging mode for tasks that support it.', type: [Number, Boolean] &#125;, stack: &#123; info: 'Print a stack trace when exiting with a warning or fatal error.', type: Boolean &#125;, force: &#123; short: 'f', info: 'A way to force your way past warnings. Want a suggestion? Don\\'t use this option, fix your code.', type: Boolean &#125;, tasks: &#123; info: 'Additional directory paths to scan for task and \"extra\" files. (grunt.loadTasks) *', type: Array &#125;, npm: &#123; info: 'Npm-installed grunt plugins to scan for task and \"extra\" files. (grunt.loadNpmTasks) *', type: Array &#125;, write: &#123; info: 'Disable writing files (dry run).', type: Boolean, negate: true &#125;, verbose: &#123; short: 'v', info: 'Verbose mode. A lot more information output.', type: Boolean &#125;, version: &#123; short: 'V', info: 'Print the grunt version. Combine with --verbose for more info.', type: Boolean &#125;, completion: &#123; info: 'Output shell auto-completion rules. See the grunt-cli documentation for more information.', type: String &#125;,&#125;;// 利用optlist列表初始化aliases和known对象// 传递给nopt模块进行命令行参数解析// nopt是一个用来解析命令行参数的第三方模块var aliases = &#123;&#125;;var known = &#123;&#125;;Object.keys(optlist).forEach(function(key) &#123; var short = optlist[key].short; if (short) &#123; aliases[short] = '--' + key; &#125; known[key] = optlist[key].type;&#125;);var parsed = nopt(known, aliases, process.argv, 2);// 获取命令行中的任务名称cli.tasks = parsed.argv.remain;// 获得命令行中的参数cli.options = parsed;delete parsed.argv;// 初始化类型为数组但是还没被初始化的参数，比如npm和taskObject.keys(optlist).forEach(function(key) &#123; if (optlist[key].type === Array &amp;&amp; !(key in cli.options)) &#123; cli.options[key] = []; &#125;&#125;); 这段代码相对比较简单，主要功能就是解析任务名和参数然后传递给grunt.tasks方法进行调用。下面来看看grunt.js中关于grunt.tasks方法的代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// 这个tasks方法一般只在grunt内部调用// tasks方法用来将任务添加到任务队列中，并且运行任务grunt.tasks = function(tasks, options, done) &#123; // option模块对命令行参数进行包装 // init方法对参数进行了初始化，在方法内部判断传入参数是否为空 // 如果为空则初始化为空对象否则使用传入的对象进行初始化 option.init(options); var _tasks, _options; // option方法接受可变属性的参数， // 如果传入一个参数则在参数对象中找出对于的参数， // 如果传入两个参数则根据这两个参数设置key-value键值对，并value // 同时方法内部会用正则匹配no-color、no-write的情况， // 如果出现则设置option['color']或option['write']为false，并返回false if (option('version')) &#123; // 如果带有version参数 // 输出版本信息 log.writeln('grunt v' + grunt.version); if (option('verbose')) &#123; // //输出详细信息，包括grunt的路径 verbose.writeln('Install path: ' + path.resolve(__dirname, '..')); grunt.log.muted = true; // 初始化任务系统，解析gruntfile以便输出所有可用的任务 grunt.task.init([], &#123;help: true&#125;); grunt.log.muted = false; // 输出可用的任务信息 _tasks = Object.keys(grunt.task._tasks).sort(); verbose.writeln('Available tasks: ' + _tasks.join(' ')); // 输出所有可用参数的详细信息 _options = []; Object.keys(grunt.cli.optlist).forEach(function(long) &#123; var o = grunt.cli.optlist[long]; _options.push('--' + (o.negate ? 'no-' : '') + long); if (o.short) &#123; _options.push('-' + o.short); &#125; &#125;); verbose.writeln('Available options: ' + _options.join(' ')); &#125; return; &#125; // 初始化log的着色功能 log.initColors(); // 如果参数带有help则输出帮助信息 if (option('help')) &#123; help.display(); return; &#125; // 根据option输出命令行参数，flags方法会过滤掉值为空的参数 verbose.header('Initializing').writeflags(option.flags(), 'Command-line options'); // 判断是否有传入tasks参数并且任务长度大于0 var tasksSpecified = tasks &amp;&amp; tasks.length &gt; 0; //将传入参数进行转换，转换为任务数组，如果没有传入有效的任务那么使用默认default任务 tasks = task.parseArgs([tasksSpecified ? tasks : 'default']); // 根据传入的tasks参数初始化任务 // 在方法中加载gruntfile.js文件，进行任务注册和配置的解析 // 也就是加载我们编写的任务代码 task.init(tasks, options); verbose.writeln(); if (!tasksSpecified) &#123; verbose.writeln('No tasks specified, running default tasks.'); &#125; verbose.writeflags(tasks, 'Running tasks'); // 注册异常处理函数，输出异常信息 var uncaughtHandler = function(e) &#123; fail.fatal(e, fail.code.TASK_FAILURE); &#125;; process.on('uncaughtException', uncaughtHandler); task.options(&#123; error: function(e) &#123; fail.warn(e, fail.code.TASK_FAILURE); &#125;, done: function() &#123; // 当任务完成之后移除异常监听函数，减少多余的开销 process.removeListener('uncaughtException', uncaughtHandler); // 输出最后的运行结果，失败或者成功 fail.report(); if (done) &#123; // 如果存在done函数的话，当完成任务时执行done函数 done(); &#125; else &#123; // 如果没有done函数直接结束进程 util.exit(0); &#125; &#125; &#125;); // 将任务依次加入内部的任务队列中，run方法并不会运行任务，只是加入到队列中 tasks.forEach(function(name) &#123; task.run(name); &#125;); // 开始运行任务队列中的任务 task.start(&#123;asyncDone:true&#125;);&#125;; 在grunt.tasks代码中，首先会进行参数的初始化，接着判断参数是否带有version或者help选项，如果带有这两个选项就进行相应的工作而不运行任务任务，否则解析任务名进行任务初始化并添加到任务队列中，最后运行任务。在grunt.tasks方法中比较重要的三个方法就是task.init，task.run和task.start方法。下面看看task.init方法的具体实现。这个方法位于lib/grunt/task.js文件中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 初始化任务task.init = function(tasks, options) &#123; if (!options) &#123; options = &#123;&#125;; &#125; // 拥有init方法说明task是初始化任务，比如第三方插件 var allInit = tasks.length &gt; 0 &amp;&amp; tasks.every(function(name) &#123; var obj = task._taskPlusArgs(name).task; return obj &amp;&amp; obj.init; &#125;); // 获取gruntfile.js路径，如果有指定路径那么直接使用否则在当前目录及父目录中查找 var gruntfile, msg; if (allInit || options.gruntfile === false) &#123; gruntfile = null; &#125; else &#123; gruntfile = grunt.option('gruntfile') || grunt.file.findup('Gruntfile.&#123;js,coffee&#125;', &#123;nocase: true&#125;); msg = 'Reading \"' + (gruntfile ? path.basename(gruntfile) : '???') + '\" Gruntfile...'; &#125; // 如果参数中将gruntfile设为false，那么说明任务是一个插件或者库 // 不做任何操作 if (options.gruntfile === false) &#123; // Grunt was run as a lib with &#123;gruntfile: false&#125;. &#125; else if (gruntfile &amp;&amp; grunt.file.exists(gruntfile)) &#123; // 如果存在gruntfile grunt.verbose.writeln().write(msg).ok(); // 修改进程的操作目录，如果有指定base那么使用base目录否则就使用gruntfile所在的目录 process.chdir(grunt.option('base') || path.dirname(gruntfile)); // 在verbose情况下输出Registering Gruntfile tasks信息 loadTasksMessage('Gruntfile'); // 加载gruntfile中的任务 loadTask(gruntfile); &#125; else if (options.help || allInit) &#123; // 如果没找到grunt但是有help参数的话，那么不做任何操作 &#125; else if (grunt.option('gruntfile')) &#123; // 如果指定了gruntfile参数但是找不到文件那么输出错误信息 grunt.log.writeln().write(msg).error(); grunt.fatal('Unable to find \"' + gruntfile + '\" Gruntfile.', grunt.fail.code.MISSING_GRUNTFILE); &#125; else if (!grunt.option('help')) &#123; grunt.verbose.writeln().write(msg).error(); grunt.log.writelns( 'A valid Gruntfile could not be found. Please see the getting ' + 'started guide for more information on how to configure grunt: ' + 'http://gruntjs.com/getting-started' ); grunt.fatal('Unable to find Gruntfile.', grunt.fail.code.MISSING_GRUNTFILE); &#125; // 加载用户指定的npm包 (grunt.option('npm') || []).forEach(task.loadNpmTasks); // 加载用户指定的任务 (grunt.option('tasks') || []).forEach(task.loadTasks);&#125;; 在初始化任务之后grunt.tasks方法会调用task.run方法，将任务添加到任务队列中等待执行。下面是task.run方法的代码，它也是位于lib/util/task.js文件中。123456789101112131415161718192021222324252627282930313233343536373839404142// 将任务加入到队列中Task.prototype.run = function() &#123; // 将参数转换为数组并且根据参数构建任务对象 var things = this.parseArgs(arguments).map(this._taskPlusArgs, this); // 找出无法构建的任务 var fails = things.filter(function(thing) &#123; return !thing.task; &#125;); if (fails.length &gt; 0) &#123; // 如果存在无法构建的任务，抛出错误并返回 this._throwIfRunning(new Error('Task \"' + fails[0].nameArgs + '\" not found.')); return this; &#125; // 将任务加入到任务队列相应的位置 this._push(things); // 支持链式调用 return this;&#125;;// 将任务名分离为真实运行的任务名和参数的对象，比如：// 'foo' ==&gt; 任务名为foo，没有参数// 'foo:bar:baz' ==&gt; 如果'foo:bar:baz'任务存在，那么任务名为'foo:bar:baz'，没有参数// ==&gt; 如果'foo:bar'任务存在，那么任务名为'foo:bar'，参数为'baz'// ==&gt; 如果'foo'任务存在，那么任务名为'foo'，参数为'bar'和'baz'Task.prototype._taskPlusArgs = function(name) &#123; // 将传入的任务名根据冒号转换为数组 var parts = this.splitArgs(name); // 从数组最后开始遍历数组 var i = parts.length; var task; do &#123; // 将0到i的数组转换为任务名，用冒号隔开 // 然后根据得到的任务名从任务缓存中得到相应的任务 task = this._tasks[parts.slice(0, i).join(':')]; // 如果相应任务不存在，那么i减1，知道i等于0 &#125; while (!task &amp;&amp; --i &gt; 0); // 除了任务名以外的部分属于参数 var args = parts.slice(i); // 根据参数列表，得到相应的boolean型标记 var flags = &#123;&#125;; args.forEach(function(arg) &#123; flags[arg] = true; &#125;); // 返回构建的任务对象，包括任务名和任务参数 return &#123;task: task, nameArgs: name, args: args, flags: flags&#125;;&#125;; 在task.run方法中，首先将参数进行分离，分隔出任务名和参数，然后利用任务名和参数构建一个任务对象，最后将这个对象放入任务队列中，参数分离的实现方法为_taskPlusArgs。调用task.run之后，grunt.tasks方法马上就会调用task.start方法运行任务队列中的任务。task.start方法的实现也在lib/util/task.js文件中，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 开始运行任务队列中的任务Task.prototype.start = function(opts) &#123; //初始化opts对象 if (!opts) &#123; opts = &#123;&#125;; &#125; // 如果任务正在运行则退出 if (this._running) &#123; return false; &#125; // 通过nextTask依次运行队列中的任务 var nextTask = function() &#123; // 用来保存从队列中取出的任务对象 var thing; // 取出队列中的元素，直到取出的元素不是placeholder和marker // placeholder用来处理嵌套任务的情况 do &#123; //取出队列中的任务对象 thing = this._queue.shift(); &#125; while (thing === this._placeholder || thing === this._marker); // 如果队列为空，那么完成任务，执行可选的done函数并返回 if (!thing) &#123; this._running = false; if (this._options.done) &#123; this._options.done(); &#125; return; &#125; // 向队列中插入一个placeholder this._queue.unshift(this._placeholder); // 使用取出的任务对象构造任务函数的上下文对象 var context = &#123; // 任务名称:target名称:参数 nameArgs: thing.nameArgs, // 任务名称 name: thing.task.name, // 任务参数，这个参数包括了除了任务名以外的东西，包括target名称和参数 args: thing.args, // 以args为键的键值对，值为true flags: thing.flags &#125;; // 运行任务的注册函数，上下文设置为上面构造的context函数 this.runTaskFn(context, function() &#123; return thing.task.fn.apply(this, this.args); &#125;, nextTask, !!opts.asyncDone); &#125;.bind(this); // 把任务标记为正在运行 this._running = true; // 运行任务队列中的下一个任务 nextTask();&#125;;// 运行任务的注册函数Task.prototype.runTaskFn = function(context, fn, done, asyncDone) &#123; // 标记是否异步 var async = false; // 执行函数完成之后的工作，更新任务状态，执行done函数也就是运行下一个任务 var complete = function(success) &#123; var err = null; if (success === false) &#123; // 任务运行失败，创建错误对象 err = new Error('Task \"' + context.nameArgs + '\" failed.'); &#125; else if (success instanceof Error || &#123;&#125;.toString.call(success) === '[object Error]') &#123; // 如果传入的是错误对象，表示任务执行失败 err = success; success = false; &#125; else &#123; // 任务运行成功 success = true; &#125; // 任务结束后重置当前运行任务 this.current = &#123;&#125;; // 记录任务执行结构 this._success[context.nameArgs] = success; // 如果任务失败则调用错误处理函数 if (!success &amp;&amp; this._options.error) &#123; this._options.error.call(&#123;name: context.name, nameArgs: context.nameArgs&#125;, err); &#125; // 如果指定了异步执行，那么使用node自带的nextTick来运行done // 否则直接运行done if (asyncDone) &#123; process.nextTick(function() &#123; done(err, success); &#125;); &#125; else &#123; done(err, success); &#125; &#125;.bind(this); // 用来支持异步任务，也就是this.async()方法的实现， // 返回函数在异步任务完成时被调用执行complete方法 context.async = function() &#123; async = true; // 返回的函数在任务中的异步工作完成后被调用 return function(success) &#123; setTimeout(function() &#123; complete(success); &#125;, 1); &#125;; &#125;; // 记录当前正在运行的任务上下文 this.current = context; try &#123; // 执行任务的注册函数 var success = fn.call(context); // 如果没有使用this.async // 也就是说async标记为false时在任务完成之后直接调用complete方法 if (!async) &#123; complete(success); &#125; &#125; catch (err) &#123; complete(err); &#125;&#125;; 在task.start方法中定义了一个nextTask方法，方法的作用是依次执行任务队列中的任务，从任务队列中取出任务对象，利用任务对象构建一个上下文对象，然后在这个上下文中执行任务的注册函数，执行完注册函数之后执行队列中的下一个任务。执行注册函数的功能有task.runTaskFn方法实现。在这个方法中定义了一个complele方法，会在任务注册函数执行完成后备调用，进行错误处理工作。同时在task.runTaskFn方法中还向上下文对象context中添加了一个async方法，这个方法就是当我们需要在任务中进行一些异步操作是首先需要调用的方法，调用这个方法之后会返回一个函数，这个函数会异步执行complete方法，如果没有async方法，那么在我们任务中的异步操作还未返回时，grunt内部就会调用complete方法，这样就会造成错误。有了async方法，我们就可以确保complete方法是在我们任务完成之后才被调用。 上面所涉及到的几个方法就是grunt中运行任务过程中主要的几个方法。大家肯定还觉得少了点什么，想要运行任务首先需要在gruntfile.js中注册任务，所以下一次我将和大家分享任务注册相关的源码解析，敬请期待。","categories":[],"tags":[{"name":"grunt","slug":"grunt","permalink":"/tags/grunt/"}]},{"title":"看看 Grunt 的源码（一）：grunt-cli 源码解析","slug":"grunt-source-code-1","date":"2015-04-07T06:46:53.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2015/04/07/grunt-source-code-1/","link":"","permalink":"/2015/04/07/grunt-source-code-1/","excerpt":"由于将来工作需要最近学习了Grunt，至于Grunt是什么大家百度下就好了，我就不多说了。对于它内部的实现比较感兴趣，所以看了看源码。今天先来说说grunt命令行工具grunt-cli的实现。","text":"由于将来工作需要最近学习了Grunt，至于Grunt是什么大家百度下就好了，我就不多说了。对于它内部的实现比较感兴趣，所以看了看源码。今天先来说说grunt命令行工具grunt-cli的实现。grunt-cli是建立在grunt基础上的命令行工具，通过它可以很方便的使用grunt进行一些自动化任务。grunt-cli的处理过程主要分为下面几步： 加载必须的模块，这其中包括第三方模块和grunt-cli内部的模块 获取命令行参数执行相应的操作 查找grunt.js文件并执行任务 下面的grunt-cli的主要代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/env node'use strict';process.title = 'grunt';//加载文件查找模块,findup用于向上查找var findup = require('findup-sync');//加载路径解析模块var resolve = require('resolve').sync;//加载grunt-cli内部的cli模块//cli模块利用nopt第三方库来获取grunt命令中的参数值var options = require('../lib/cli').options;//加载grunt-cli内部的completion模块//completion模块用来打印自动补全的脚本//这样就可以通过eval \"$(grunt --completion=bash)\"来执行脚本支持自动补全//completion.js内部就是通过参数查找文件最后输出var completion = require('../lib/completion');//加载grunt-cli内部的info模块//用来输出版本信息以及帮助信息的模块//info.js内部主要就是几个输出grunt信息的方法var info = require('../lib/info');//加载node自带的路径解析模块var path = require('path');//获取当前路径var basedir = process.cwd();//grunt.js文件的路径var gruntpath;//判断命令行参数进行相应操作if ('completion' in options) &#123;//如果grunt命令带有--completion参数，则打印相应的自动补全脚本//grunt --completion=bash这个命令基本上只会在设置自动补全的使用//在自动化工作中并不会用到completion.print(options.completion);&#125; else if (options.version) &#123;//如果grunt命令带有--version参数，则打印版本信息info.version();&#125; else if (options.base &amp;&amp; !options.gruntfile) &#123;//如果在grunt命令中指定了base文件夹//那么所有操作都会基于这个文件路径进行basedir = path.resolve(options.base);&#125; else if (options.gruntfile) &#123;//如果grunt命令中指定了gruntfile，那么就会执行这个文件中的任务，同时文件夹切换到对于目录下//默认情况下grunt会在当前目录以及父目录中查找Gruntfile.js或者Gruntfile.coffee文件basedir = path.resolve(path.dirname(options.gruntfile));&#125;try &#123;//得到grunt.js的地址gruntpath = resolve('grunt', &#123;basedir: basedir&#125;);&#125; catch (ex) &#123;//如果在当前路径没找到，向父目录继续查找gruntpath = findup('lib/grunt.js');// No grunt install found!if (!gruntpath) &#123; //无法找到目录 if (options.version) &#123; //如果查询版本信息，由于找不到grunt所以直接退出 process.exit(); &#125; if (options.help) &#123; //显示帮助信息 info.help(); &#125; info.fatal('Unable to find local grunt.', 99);&#125;&#125;//调用grunt执行任务，精彩从这里开始require(gruntpath).cli(); 整个过程比较简单，真正有意思的工作在grunt.js中，后续我会跟大家分享这方面的内容。","categories":[],"tags":[{"name":"grunt","slug":"grunt","permalink":"/tags/grunt/"}]},{"title":"(译)为什么原型继承很重要","slug":"why-prototype-important","date":"2015-03-14T06:46:35.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2015/03/14/why-prototype-important/","link":"","permalink":"/2015/03/14/why-prototype-important/","excerpt":"五天之前我写了一个关于ES6标准中Class的文章。在里面我介绍了如何用现有的Javascript来模拟类并且介绍了ES6中类的用法，其实它只是一个语法糖。感谢Om Shakar以及Javascript Room中的各位，我的编程风格从那时候开始发生了改变；就像Dougla Crockford2006年做的一样，我也学习了很多来完全理解基于原型的编程方式。 Javascript是一个多样化的编程语言。它拥有面向对象和函数式的编程特点，你可以使用任何一种风格来编写代码。然而这两个编程风格并不能很好的融合。例如，你不无法同时使用new(典型的面向对象的特点)和apply(函数式编程的特点).原型继承一直都作为连接这两种风格的桥梁。","text":"五天之前我写了一个关于ES6标准中Class的文章。在里面我介绍了如何用现有的Javascript来模拟类并且介绍了ES6中类的用法，其实它只是一个语法糖。感谢Om Shakar以及Javascript Room中的各位，我的编程风格从那时候开始发生了改变；就像Dougla Crockford2006年做的一样，我也学习了很多来完全理解基于原型的编程方式。 Javascript是一个多样化的编程语言。它拥有面向对象和函数式的编程特点，你可以使用任何一种风格来编写代码。然而这两个编程风格并不能很好的融合。例如，你不无法同时使用new(典型的面向对象的特点)和apply(函数式编程的特点).原型继承一直都作为连接这两种风格的桥梁。 基于类继承的问题大部分Javascript程序员会告诉你基于类的继承不好。然而它们中只有很少一部分知道其中的原因。事实实际上是基于类的基础并没有什么不好。Python是基于类继承的，并且它是一门很好的编程语言。但是，基于类的继承并不适合用于Javascript。Python正确的使用了类，它们只有简单的工厂方法不能当成构造函数使用。而在Javascript中任何函数都可以被当成构造函数使用。 Javascript中的问题是由于每个函数都可以被当成构造函数使用，所以我们需要区分普通的函数调用和构造函数调用；我们一般使用new关键字来进行区别。然而，这样就破坏了Javascript中的函数式特点，因为new是一个关键字而不是函数。因而函数式的特点无法和对象实例化一起使用。 1234function Person(firstname,lastname)&#123; this.firstname = firstname ; this.lastname = lastname ;&#125; 考虑上面这段程序。你可以通过new关键字来调用Person方法来创建一个函数Person的实例： 1var author = new Person('Aadit','Shah') ; 然而，没有任何办法来使用apply方法来为构造函数指定参数列表： 1var author = new Person.apply(null,['Aadit','Shah']);//error 但是，如果new是一个方法那么上面的需求就可以通过下面这种方式实现了： 1var author = Person.new.apply(Person,['Aadit','Shah']) ; 幸运的是，因为Javascript有原型继承，所以我们可以实现一个new的函数： 1234567Function.prototype.new = function () &#123; function functor() &#123; return constructor.apply(this, args); &#125; var args = Array.prototype.slice.call(arguments); functor.prototype = this.prototype; var constructor = this; return new functor;&#125;; 在像Java这样对象只能通过new关键字来实例化的语言中，上面这种方式是不可能实现的。 下面这张表列出了原型继承相比于基于类的基础的优点： 基于类的继承 原型继承 类是不可变的。在运行时，你无法修改或者添加新的方法 原型是灵活的。它们可以是不可变的也可以是可变的 类可能会不支持多重继承 对象可以继承多个原型对象 基于类的继承比较复杂。你需要使用抽象类，接口和final类等等 原型继承比较简洁。你只有对象，你只需要对对象进行扩展就可以了 不要再使用关键词new了到现在你应该知道为什么我觉得new关键字是不会的了吧—你不能把它和函数式特点混合使用。然后，这并不代表你应该停止使用它。new关键字有合理的用处。但是我仍然建议你不要再使用它了。new关键字掩盖了Javascript中真正的原型继承，使得它更像是基于类的继承。就像Raynos说的: new是Javascript在为了获得流行度而加入与Java类似的语法时期留下来的一个残留物 Javascript是一个源于Self的基于原型的语言。然而，为了市场需求，Brendan Eich把它当成Java的小兄弟推出： 并且我们当时把Javascript当成Java的一个小兄弟，就像在微软语言家庭中Visual Basic相对于C++一样。 这个设计决策导致了new的问题。当人们看到Javascript中的new关键字，他们就想到类，然后当他们使用继承时就遇到了傻了。就像Douglas Crockford说的： 这个间接的行为是为了使传统的程序员对这门语言更熟悉，但是却失败了，就像我们看到的很少Java程序员选择了Javascript。Javascript的构造模式并没有吸引传统的人群。它也掩盖了Javascript基于原型的本质。结果就是，很少的程序员知道如何高效的使用这门语言 因此我建议停止使用new关键字。Javascript在传统面向对象假象下面有着更加强大的原型系统。然大部分程序员并没有看见这些还处于黑暗中。 理解原型继承原型继承很简单。在基于原型的语言中你只有对象。没有类。有两种方式来创建一个新对象—“无中生有”对象创建法或者通过现有对象创建。在Javascript中Object.create方法用来创建新的对象。新的对象之后会通过新的属性进行扩展。 “无中生有”对象创建法Javascript中的Object.create方法用来从0开始创建一个对象，像下面这样: 1var object = Object.create(null) ; 上面例子中新创建的object没有任何属性。 克隆一个现有的对象Object.create方法也可以克隆一个现有的对象，像下面这样: 123456var rectangle = &#123; area : function()&#123; return this.width * this.height ; &#125;&#125; ;var rect = Object.create(rectangle) ; 上面例子中rect从rectangle中继承了area方法。同时注意到rectangle是一个对象字面量。对象字面量是一个简洁的方法用来创建一个Object.prototype的克隆然后用新的属性来扩展它。它等价于: 1234var rectangle = Object.create(Object.prototype) ;rectangle.area = function()&#123; return this.width * this.height ;&#125; ; 扩展一个新创建的对象上面的例子中我们克隆了rectangle对象命名为rect，但是在我们使用rect的area方法之前我们需要扩展它的width和height属性，像下面这样: 123rect.width = 5 ;rect.height = 10 ;alert(rect.area()) ; 然而这种方式来创建一个对象的克隆然后扩展它是一个非常傻缺的方法。我们需要在每个rectangle对象的克隆上手动定义width和height属性。如果有一个方法能够为我们来完成这些工作就很好了。是不是听起来有点熟悉？确实是。我要来说说构造函数。我们把这个函数叫做create然后在rectangle对象上定义它: 12345678910111213var rectangle = &#123; create : function(width,height)&#123; var self = Object.create(this) ; self.height = height ; self.width = width ; return self ; &#125; , area : function()&#123; return this.width * this.height ; &#125;&#125; ;var rect = rectangle.create(5,10) ;alert(rect.area()) ; 构造函数 VS 原型等等。这看起来很像Javascript中的正常构造模式: 123456789101112function Rectangle(width, height) &#123; this.height = height; this.width = width;&#125; ;Rectangle.prototype.area = function () &#123; return this.width * this.height;&#125;;var rect = new Rectangle(5, 10);alert(rect.area()); 是的，确实很像。为了使得Javascript看起来更像Java原型模式被迫屈服于构造模式。因此每个Javascript中的函数都有一个prototype对象然后可以用来作为构造器(这里构造器的意思应该是说新的对象是在prototype对象的基础上进行构造的)。new关键字允许我们把函数当做构造函数使用。它会克隆构造函数的prototype属性然后把它绑定到this对象中，如果没有显式返回对象则会返回this。 原型模式和构造模式都是平等的。因此你也许会怀疑为什么有人会困扰于是否应该使用原型模式而不是构造模式。毕竟构造模式比原型模式更加简洁。但是原型模式相比构造模式有许多优势。具体如下： 构造模式 原型模式 函数式特点无法与new关键字一起使用 函数式特点可以与create结合使用 忘记使用new会导致无法预期的bug并且会污染全局变量 由于create是一个函数，所以程序总是会按照预期工作 使用构造函数的原型继承比较复杂并且混乱 使用原型的原型继承简洁易懂 最后一点可能需要解释一下。使用构造函数的原型继承相比使用原型的原型继承更加复杂，我们先看看使用原型的原型继承: 123456var square = Object.create(rectangle);square.create = function (side) &#123; return rectangle.create.call(this, side, side);&#125; ;var sq = square.create(5) ;alert(sq.area()) ; 上面的代码很容易理解。首先我们创建一个rectangle的克隆然后命名为square。接着我们用新的create方法重写square对象的create方法。最终我们从新的create方法中调用rectangle的create函数并且返回对象。相反的，使用构造函数的原型继承像下面这样: 1234567891011function Square()&#123; Rectangle.call(this,side,side) ;&#125; ;Square.prototype = Object.create(Rectangle.prototype) ;Square.prototype.constructor = Square ;var sq = new Square(5) ;alert(sq.area()) ; 当然，构造函数的方式更简单。然后这样的话，向一个不了解情况的人解释原型继承就变得非常困难。如果想一个了解类继承的人解释则会更加困难。 当使用原型模式时一个对象继承自另一个对象就变得很明显。当使用方法构造模式时就没有这么明显，因为你需要根据其他构造函数来考虑构造继承。 对象创建和扩展相结合在上面的例子中我们创建一个rectangle的克隆然后命名为square。然后我们利用新的create属性扩展它，重写继承自rectangle对象的create方法。如果把这两个操作合并成一个就很好了，就像对象字面量是用来创建Object.prototype的克隆然后用新的属性扩展它。这个操作叫做extend，可以像下面这样实现: 123456789101112Object.prototype.extend = function(extension)&#123; var hasOwnProperty = Object.hasOwnProperty ; var object = Object.create(this) ; for(var property in extension)&#123; if(hasOwnProperty.call(extension,property) || typeof obejct[property] === 'undefined') //这段代码有问题，按照文章意思，这里应该使用深复制，而不是简单的浅复制,deepClone(extension[property],object[property]),deepClone的实现可以看我之前关于继承的博客 object[properyty] = extension[property] ; &#125; return object ;&#125; ; 译者注：我觉得博主这里的实现有点不符合逻辑，正常extend的实现应该是可以配置当被扩展对象和用来扩展的对象属性重复时是否覆盖原有属性，而博主的实现就只是简单的覆盖。同时博主的实现在if判断中的做法个人觉得是值得学习的，首先判断extension属性是否是对象自身的，如果是就直接复制到object上，否则再判断object上是否有这个属性，如果没有那么也会把属性复制到object上，这种实现的结果就使得被扩展的对象不仅仅只扩展了extension中的属性，还包括了extension原型中的属性。不难理解，extension原型中的属性会在extension中表现出来，所以它们也应该作为extension所具有的特性而被用来扩展object。所以我对这个方法进行了改写: 12345678910111213141516 Object.prototype.extend = function(extension,override)&#123; var hasOwnProperty = Object.hasOwnProperty ; var object = Object.create(this) ; for(var property in extension)&#123; if(hasOwnProperty.call(extension,property) || typeof object[property] === 'undefined')&#123; if(object[property] !== 'undefined')&#123; if(override)&#123; deepClone(extension[property],object[property]) ; &#125; &#125;else&#123; deepClone(extension[property],object[property]) ; &#125; &#125; &#125;&#125;; 利用上面的extend方法，我们可以重写square的代码: 12345678var square = rectangle.extend(&#123; create : function(side)&#123; return rectangle.create.call(this,side,side) ; &#125;&#125;) ;var sq = square.create(5) ;alert(sq.area()) ; extend方法是原型继承中唯一需要的操作。它是Object.create函数的超集，因此它可以用在对象的创建和扩展上。因此我们可以用extend来重写rectangle，使得create函数更加结构化看起来就像模块模式。 1234567891011var rectangle = &#123; create : function(width,height)&#123; return this.extend(&#123; height : height , width : width &#125;) ; &#125;&#125; ;var rect = rectangle.create(5,10) ;alert(rect.area()) ; 原型继承的两种方法一些人可能已经注意到extend函数返回的对象实际上是继承了两个对象的属性，一个是被扩展的对象，另一个是用来扩展的对象。另外从两个对象继承属性的方式也不一样。第一种情况下是通过委派来继承属性(也就是使用Object.create()来继承属性)，第二种情况下使用合并属性的方式来继承属性。 委派(差异化继承)很多Javascript程序员对于差别继承比较熟悉。维基百科是这么解释的: 大部分对象是从其他更一般的对象中得到的，只是在一些很小的地方进行了修改。每个对象通常在内部维护一个指向其他对象的引用列表，这些对象就是该对象本身进行差异化继承的对象。 Javascript中的原型继承是基于差异化继承的。每个对象都有个内部指针叫做[[proto]] (在大部分浏览器中可以通过__proto__属性访问)，这个指针指向对象的原型。多个对象之间通过内部[[proto]]属性链接起来形成了原型链，链的最后指向null。 当你试图获取一个对象的属性时Javascript引擎会首先查找对象自身的属性。如果在对象上没找到该属性，那么它就会去对象的原型中去查找。以此类推，它会沿着原型链一直查找知道找到或者到原型链的末尾。 12345678function get(object,property)&#123; if(!Object.hasOwnProperty.call(object,property))&#123; var prototype = Object.getPrototypeOf(object) ; if(prototype) return get(prototype,property) ; &#125;else&#123; return object[property] ; &#125;&#125; ; Javascript中属性查找的过程就像上面的程序那样。 克隆(合并式继承)大多数Javascript程序员会觉得复制一个对象的属性到另一个对象上并不是一个正确的继承的方式，因为任何对原始对象的修改都不会反映在克隆的对象上。五天前我会同意这个观点。然而现在我相信合并式继承是原型继承的一种正确方式。对于原始对象的修改可以发送到它的副本来实现真正的原型继承。 合并式继承和代理有他们的优点和缺点。下表列出了它们的优缺点: 代理 合并 任何对于原型的修改都会反映在所有副本上 任何对于原型的修改都需要手动更新到副本中 属性查找效率较低因为需要进行原型链查找 属性查找更搞笑因为继承的属性是通过复制的方式附加在对象本身的 使用Object.create()方法只能继承单一对象 对象可以从任意数量的对象中通过复制继承属性 从多个原型继承上表中最后一点告诉我们对象可以通过合并的方式从多个原型中继承属性。这是一个重要的特点因为这证明原型继承比Java中的类继承更强大并且与C++中的类继承一样强大。为了实现多重继承，你只需要修改extend方法来从多个原型中复制属性。 123456789101112131415161718Object.prototype.extend = function()&#123; var hasOwnProperty = Object.hasOwnProperty ; var object = Object.create(this) ; var length = arguments.length ; var index = length ; while(index)&#123; var extension = arguments[length - (index--)] ; for(var property in extension)&#123; if(hasOwnProperty.call(extension,property)|| typeof object[property] === 'undefined')&#123; //这里同样应该使用深复制 object[property] = extension[property] ; &#125; &#125; &#125; return object;&#125; ; 多重继承是非常有用的因为它提高了代码的可重用性和模块化。对象通过委派继承一个原型对象然后通过合并继承其他属性。比如说你有一个事件发射器的原型，像下面这样： 1234567891011121314151617181920var eventEmitter = &#123; on : function(event,listener)&#123; if(typeof this[event] !== 'undefined') this[event].push(listener) ; else this[event] = [listener] ; &#125; , emit : function(event)&#123; if(typeof this[event] !== 'undefined')&#123; var listeners = this[event] ; var length = listeners.length,index = length ; var args = Array.prototype.slice.call(arguments,1) ; while(index)&#123; var listener = listeners[length - (index--)] ; listener.apply(this,args) ; &#125; &#125; &#125;&#125; ; 现在你希望square表现得像一个事件发射器。因为square已经通过委派的方式继承了rectangle，所以它必须通过合并的方式继承eventEmitter。这个修改可以很容易地通过使用extend方法实现： 1234567891011121314151617var square = rectangle.extend(eventEmitter,&#123; create : function(side)&#123; return rectangle.create.call(this,side,side) ; &#125; , resize : function(newSize)&#123; var oldSize = this.width ; this.width = this.height = newSize ; this.emit('resize',oldSize,newSize) ; &#125;&#125;) ;var sq = square.create(5) ;sq.on('resize',function(oldSize,newSize)&#123; alert('sq resized from ' + oldSize + 'to' + newSize + '.') ;&#125;) ;sq.resize(10) ;alert(sq.area()) ; 在Java中是不可能实现上面的程序的，因为它不支持多重继承。相应的你必须另外再创建一个EventEmitter类或者使用一个EventEmitter接口并且在每个实现该接口的类中分别实现on和emit方法。当然你在C++中不需要面对这个问题。我们都知道Java sucks(呵呵呵)。 Mixin的蓝图(Buleprint)在上面的例子中你肯定注意到eventEmitter原型并没有一个create方法。这是因为你不应该直接创建一个eventEmitter对象。相反eventEmitter是用来作为其他原型的原型。这类原型称为mixin。它们等价于抽象类。mixin用来通过提供一系列可重用的方法来扩展对象的功能。 然而有时候mixin需要私有的状态。例如eventEmitter如果能够把它的事件监听者列表放在私有变量中而不是放在this对象上会安全得多。但是mixin没有create方法来封装私有状态。因此我们需要为mixin创建一个蓝图(blueprint)来创建闭包。蓝图(blueprint)看起来会像是构造函数但是它们并不用像构造函数那样使用。例如： 1234567891011121314151617function eventEmitter()&#123; var evnets = Object.create(null) ; this.on = function(event,listener)&#123; if(typeof events[event] !== 'undefined') events[event].push(listener) ; else events[event] = [listener] ; &#125; ; this.emit = function(event)&#123; if(typeof events[event] !== 'undefined')&#123; var listeners = events[event] ; var length = listeners.length ,index = length ; var args = Array.prototype.slice.call(arguments,1) ; &#125; &#125; ;&#125; ; 一个蓝图用来在一个对象创建之后通过合并来扩展它(我觉得有点像装饰者模式)。Eric Elliot把它们叫做闭包原型。我们可以使用蓝图版本的eventEmitter来重写square的代码，如下： 123456789101112131415161718192021var square = rectangle.extend(&#123; create : function(side)&#123; var self = rectangle.create.call(this,side,side) ; eventEmitter.call(self) ; return self ; &#125; , resize : function(newSize)&#123; var oldSize = this.width ; this.width = this.height = newSize ; this.emit('resize',oldSize,newSize) ; &#125;&#125;) ;var sq = square.create(5) ;sq.on('resize',function(oldSize,newSize)&#123; alert('sq resized from ' + oldSize + 'to' + newSize + '.') ;&#125;) ;sq.resize(10) ;alert(sq.area()) ; 蓝图在Javascript中是独一无二的。它是一个很强大的特性。然而它们也有自己的缺点。下表列出了mixin和蓝图的优缺点： Mixin 蓝图 它们用来扩展对象的原型。因此对象共享同一个原型 它们用来扩展新创建的对象。因此每个对象都是在自己对象本身进行修改 因为缺少封装方法所以不存在私有状态 它们是函数，所以可以封装私有状态 它们是静态原型并且不能被自定义 它们可以传递参数来自定义对象，可以向蓝图函数传递一些用来自定义的参数 修复instanceof操作许多Javascript程序员会觉得使用原型模式来继承违背了语言的精髓。他们更偏向于构造模式因为他们觉得通过构造函数创建的对象才是真正的实例，因为instanceof操作会返回true。然而，这个争论是没有意义的，因为instanceof操作可以像下面这样实现： 12345678Object.prototype.instanceof = function(prototype)&#123; var object = this ; do&#123; if(object === prototype) return true ; var object = Object.getPrototypeOf(object) ; &#125;while(object) ; return false ;&#125; 这个instanceof方法现在可以被用来测试一个对象是否是通过委派从一个原型继承的。例如： 1sq.instanceof(square) ; 然而还是没有办法判断一个对象是否是通过合并的方式从一个原型继承的，因为实例的关联信息丢失了。为了解决这个问题我们将一个原型的所有克隆的引用保存在原型自身中，然后使用这个信息来判断一个对象是否是一个原型的实例。这个可以通过修改extend方法来实现： 1234567891011121314151617181920212223Object.prototype.extend = function()&#123; var hasOwnProperty = Object.hasOwnProperty ; var object = Object.create(this) ; var length = arguments.lenght ; var index = length ; while(index)&#123; var extension = arguments[length - (index--)] ; for(var property in extension)&#123; if(property !== 'clones' &amp;&amp; hasOwnProperty.call(extension,property) || typeof object[property] === 'undefined') object[property] = extension[property] ; if(hasOwnProperty.call(extension,'clones')&#125;) extension.clones.unshift(object) ; else extension.clones = [object] ; &#125; &#125; return object;&#125; ; 通过合并继承自原型的对象形成了一个克隆树，这些树从根对象开始然后向下一直到叶子对象。一个克隆链是一个从根对象到叶子对象的单一路径，这跟遍历原型链很相似。我们可以使用这个信息来判断一个对象是否是通过合并继承自一个原型。 1234567891011121314Object.prototype.instanceof = function(prototype)&#123; if (Object.hasOwnProperty.call(prototype, \"clones\")) var clones = prototype.clones; var object = this; do &#123; if (object === prototype || clones &amp;&amp; clones.indexOf(object) &gt;= 0) return true; var object = Object.getPrototypeOf(o bject); &#125; while (object); return false;&#125; ; 这个instanceof方法现在可以用来判断一个对象是否是通过合并继承自一个原型。例如: 1sq.instanceof(eventEmitter); 在上面的程序中instanceof会返回true如果我妈使用mixin版本的eventEmitter。然而如果我们使用蓝图版本的eventEmitter它会返回false。为了解决这个问题我创建了一个蓝图函数，这个函数接收一个蓝图作为参数，向它添加一个clones属性然后返回一个记录了它的克隆的新蓝图： 1234567891011121314151617181920212223242526272829function blueprint(f)&#123; var g = function()&#123; f.apply(this,arguments) ; g.clones.unshift(this) ; &#125; ; g.clones = [] ; return g ;&#125; ;var eventEmitter = blueprint(function()&#123; var events = Object.create(null); this.on = function (event, listener) &#123; if (typeof events[event] !== \"undefined\") events[event].push(listener); else events[event] = [listener]; &#125;; this.emit = function (event) &#123; if (typeof events[event] !== \"undefined\") &#123; var listeners = events[event]; var length = listeners.length, index = length; var args = Array.prototype.slice.call(arguments, 1); while (index) &#123; var listener = listeners[length - (index--)]; listener.apply(this, args); &#125; &#125; &#125;;&#125;) ; 向原型发送变化上面例子中的clones属性有双重作用。它可以用来判断一个对象是否是通过合并继承自一个原型的，然后他可以用来发送原型改变给所有它的克隆。原型继承相比类继承最大的优势就是你可以修改一个原型在它创建之后。为了使克隆可以继承对于原型的修改，我们创建了一个叫做define的函数： 1234567891011121314Object.prototype.define = function (property, value) &#123; this[property] = value; if (Object.hasOwnProperty.call(this, \"clones\")) &#123; var clones = this.clones; var length = clones.length; while (length) &#123; var clone = clones[--length]; if (typeof clone[property] === \"undefined\") clone.define(property, value); &#125; &#125;&#125;; 现在我们可以修改原型然后这个修改会反映在所有的克隆上。例如我们可以创建创建一个别名addEventListener针对eventEmitter上的on方法： 12345678910111213141516171819202122var square = rectangle.extend(eventEmitter, &#123; create: function (side) &#123; return rectangle.create.call(this, side, side); &#125;, resize: function (newSize) &#123; var oldSize = this.width; this.width = this.height = newSize; this.emit(\"resize\", oldSize, newSize); &#125;&#125;);var sq = square.create(5);eventEmitter.define(\"addEventListener\", eventEmitter.on);sq.addEventListener(\"resize\", function (oldSize, newSize) &#123; alert(\"sq resized from \" + oldSize + \" to \" + newSize + \".\");&#125;);sq.resize(10);alert(sq.area()); 蓝图需要特别注意。尽管对于蓝图的修改会被发送到它的克隆，但是蓝图的新的克隆并不会反映这些修改。幸运的是这个问题的解决方法很简单。我们只需要对blueprint方法进行小小的修改，然后任何对于蓝图的修改就会反映在克隆上了。 1234567891011121314151617function blueprint(f) &#123; var g = function () &#123; f.apply(this, arguments); g.clones.unshift(this); var hasOwnProperty = Object.hasOwnProperty; for (var property in g) if (property !== \"clones\" &amp;&amp; hasOwnProperty.call(g, property)) this[property] = g[property]; &#125;; g.clones = []; return g;&#125;; 结论恭喜你。如果你读完了整篇文章并且理解了我所说的东西，你现在就了解了 原型继承并且为什么它很重要。很感谢你们看完了这篇文章。我希望这个博客能帮到你们。原型继承是强大的并且值得更多的信任。然后大部分人从来不明白这个因为Javascript中的原型继承被构造模式所掩盖了。 译者注这篇文章针对几种继承方式进行了对比。文章中说到的几种扩展的方法我觉得是比较有用的。蓝图(blueprint，这个实在不知道该怎么翻译)的扩展方式比较像设计模式中的装饰者模式，通过函数对对象进行扩展，这个是一种比较好玩的扩展方式，可以跟原型继承配合使用。另外文中提到了new关键字的弊端，个人觉得主要的原因还是new关键字的出现掩盖了Javascript本身原型继承的特点，人们自然而然就会想到传统的类继承，这样就无法发挥原型继承的最大威力。最后说到的属性修改传播的问题也挺有意思的，应该会有相应的应用场景。总之，我觉得原型继承相比于传统的类继承提供了更大的灵活性，可以给我们开发者提供很大的发挥空间，不过不管怎样，到最后还是要涉及到基本的原型继承的原理上，所以掌握了原型继承的原理就可以根据不同的应用场景使用各种各样的扩展方式。 原文地址：http://aaditmshah.github.io/why-prototypal-inheritance-matters/","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"angularjs实践过程中的心得总结","slug":"some-angular-practice","date":"2015-03-10T06:46:12.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2015/03/10/some-angular-practice/","link":"","permalink":"/2015/03/10/some-angular-practice/","excerpt":"利用寒假的时间给我家女神做了一个WebApp作为情人节礼物，一为表表忠心，二为练练手，在过程中也发现一些问题，在此总结总结。这里面除了angular方面的问题，还有一些单页面应用开发过程中的问题。","text":"利用寒假的时间给我家女神做了一个WebApp作为情人节礼物，一为表表忠心，二为练练手，在过程中也发现一些问题，在此总结总结。这里面除了angular方面的问题，还有一些单页面应用开发过程中的问题。 ##加载优化WebApp第一个版本完成之后兴高采烈的打开浏览器测试，结果Chrome的加载时间让我大跌眼镜，整整用了八秒钟的时间首页在显示出来，这明显是不可接受的。所以必须进行拆分加载。整个WebApp分为一个首页和三个功能模块，所以很自然把三个模块拆分出来，优先加载首页，在点击导航的时候再依次加载对应模块代码。功能模块的延迟加载实际上就是与功能有关的控制器，服务和路由的延迟加载，所以在拆分加载中遇到的问题就是来自这些方面。首先常用的module.controller的controller定义方式无法满足App启动之后的controller动态定义，也就是说如果在angular启动了App之后再使用module.controller的方式定义controller是无效的，仍然会报controller undefined的错误。这时候就需要使用$controllerProvider的register方法来动态定义controller。功能模块的异步加载自然而然想到了requirejs,具体实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var meng = angular.module('meng',['ionic','ngRoute']) ;//异步加载功能模块var resolveController = function(names)&#123; return &#123; loadController : ['$q','$rootScope',function($q,$rootScope)&#123; var defer = $q.defer() ; require(names,function()&#123; defer.resolve() ; $rootScope.$apply() ; &#125;) ; return defer.promise ; &#125;] &#125;&#125; ;//route configmeng.config( ['$routeProvider','$controllerProvider','$provide','$compileProvider', function($routeProvider,$controllerProvider,$provide,$compileProvider)&#123; meng.register = &#123; controller: $controllerProvider.register, factory: $provide.factory, directive: $compileProvider.directive &#125;; $provide.decorator('$route',function($delegate)&#123; var $route = $delegate ; $route.when = function( path, route ) &#123; $routeProvider.when( path, route ); return this ; &#125;; return $route ; &#125;) ; $routeProvider .when('/',&#123; templateUrl : 'views/main.html' &#125;) .when('/info',&#123; templateUrl : 'views/info.html' &#125;) .when('/task',&#123; templateUrl : 'views/task/task.html', controller : 'taskController', resolve : resolveController(['TaskModule']) &#125;) .when('/wallet',&#123; templateUrl : 'views/wallet/wallet.html', controller : 'walletController', resolve : resolveController(['WalletModule']) &#125;) .when('/note',&#123; templateUrl : 'views/note/note_list.html', controller : 'noteController', resolve : resolveController(['NoteModule']) &#125;) .otherwise('/');&#125;]) ; 上面的实现的关键就是resolveController方法，它在路由过程中利用require方法去加载功能对应的模块代码，在代码加载完成后进行路由跳转。上面省略了require的配置部分，TaskModule，WalletModule，NoteModule分别对于task.js，wallet.js和note.js三个文件。上面代码中还解决了延迟加载中的另一个问题，angular中路由配置是通过$routeProvider完成的，但是这个服务在config的时候才能获取，在App启动之后是无法获取进行路由配置的，而$route对象是随时都可以获取的，所以这里在config过程中对利用angular提供的装饰方法对$route进行了扩展，增加了一个when方法指向$routeProvider的when方法，这样就可以在其他地方对路由进行配置。通过上面的方法进行加载拆分有一个问题，它并没有很好的利用angular中模块化的特性，为了延迟加载功能不得不把原来分为三个module的代码都合并到一个module中，这样破坏了模块的独立性，如何在angular的module上进行延迟加载我还在寻找方法。 ##数据缓存高响应是单页面应用的一大优势，这是因为单页面应用会尽可能少的刷新页面。除了通过减少刷新来提高响应以外，减少不必要的数据交互也是一个关键。而为了减少不必要的数据交互，对数据进行缓存是很有必要的。在首次请求数据返回之后，将数据缓存下来，在下一次请求数据是先在缓存中查找，如果没有再去请求服务器数据，在这个过程中我们必须要保证缓存的数据与服务器数据保持同步，所以在进行增删改的时候需要同时对本地和服务器的数据进行增删改。而我在开发过程中把这部分功能实现放在Model中，这样向上隐藏内部的数据层实现。在数据缓存这方面大家如果有更好的办法，欢迎交流。 ##离线存储HTML5中的ApplicationCache离线存储是一个很好的提高App加载速度的途径，但是它也会给开发过程中带来一些不便，经常出现更新资源但是没有更新manifest文件带来的失误，而且希望更新生效需要进行两次页面刷新，这是比较不方便的。所以这个东西好用确实好用，只是加入离线存储应该放在开发过程的最后，在完成功能实现的前提下再把ApplicationCache加上去，这样可以避免它给开发过程中带来的不便。 ##小结上面所说的三个问题只是目前遇到的主要的三个问题，App还在改进中。对于angular的使用还不够熟练，对于单页面中的组织结构划分和模块化的理解还不够透彻，除了上面所说的问题以外还有几个问题有待继续钻研，比如如何更高效的处理数据缓存，移动设备上点击的击穿现象，还有CSS动画的问题，总之就是多动手多思考少吃零食多睡觉。PS:做了这个App之后发现自己真是不适合做设计，改了又改界面才勉强达到我家女神的要求，再接再厉吧。","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"/tags/angular/"}]},{"title":"再谈Javascript原型继承","slug":"talk-about-javascript-prototype-inheritance","date":"2014-11-09T06:45:50.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/11/09/talk-about-javascript-prototype-inheritance/","link":"","permalink":"/2014/11/09/talk-about-javascript-prototype-inheritance/","excerpt":"真正意义上来说Javascript并不是一门面向对象的语言，没有提供传统的继承方式，但是它提供了一种原型继承的方式，利用自身提供的原型属性来实现继承。Javascript原型继承是一个被说烂掉了的话题，但是自己对于这个问题一直没有彻底理解，今天花了点时间又看了一遍《Javascript模式》中关于原型实现继承的几种方法，下面来一一说明下，在最后我根据自己的理解提出了一个关于继承比较完整的实现，如果大家有不同意见，欢迎建议。","text":"真正意义上来说Javascript并不是一门面向对象的语言，没有提供传统的继承方式，但是它提供了一种原型继承的方式，利用自身提供的原型属性来实现继承。Javascript原型继承是一个被说烂掉了的话题，但是自己对于这个问题一直没有彻底理解，今天花了点时间又看了一遍《Javascript模式》中关于原型实现继承的几种方法，下面来一一说明下，在最后我根据自己的理解提出了一个关于继承比较完整的实现，如果大家有不同意见，欢迎建议。 原型与原型链说原型继承之前还是要先说说原型和原型链，毕竟这是实现原型继承的基础。在Javascript中，每个函数都有一个原型属性prototype指向自身的原型，而由这个函数创建的对象也有一个__proto__属性指向这个原型，而函数的原型是一个对象，所以这个对象也会有一个__proto__指向自己的原型，这样逐层深入直到Object对象的原型，这样就形成了原型链。下面这张图很好的解释了Javascript中的原型和原型链的关系。 每个函数都是Function函数创建的对象，所以每个函数也有一个__proto__属性指向Function函数的原型。这里需要指出的是，真正形成原型链的是每个对象的__proto__属性，而不是函数的prototype属性，这是很重要的。 原型继承基本模式123456789101112131415161718var Parent = function()&#123; this.name = 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : 1&#125; ;var Child = function()&#123; this.name = 'child' ;&#125; ;Child.prototype = new Parent() ;var parent = new Parent() ;var child = new Child() ;console.log(parent.getName()) ; //parentconsole.log(child.getName()) ; //child 这种是最简单实现原型继承的方法，直接把父类的对象赋值给子类构造函数的原型，这样子类的对象就可以访问到父类以及父类构造函数的prototype中的属性。 这种方法的原型继承图如下： 这种方法的优点很明显，实现十分简单，不需要任何特殊的操作；同时缺点也很明显，如果子类需要做跟父类构造函数中相同的初始化动作，那么就得在子类构造函数中再重复一遍父类中的操作：123456789101112131415161718var Parent = function(name)&#123; this.name = name || 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : 1&#125; ;var Child = function(name)&#123; this.name = name || 'child' ;&#125; ;Child.prototype = new Parent() ;var parent = new Parent('myParent') ;var child = new Child('myChild') ;console.log(parent.getName()) ; //myParentconsole.log(child.getName()) ; //myChild 上面这种情况还只是需要初始化name属性，如果初始化工作不断增加，这种方式是很不方便的。因此就有了下面一种改进的方式。 借用构造函数123456789101112131415161718var Parent = function(name)&#123; this.name = name || 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : 1&#125; ;var Child = function(name)&#123; Parent.apply(this,arguments) ;&#125; ;Child.prototype = new Parent() ;var parent = new Parent('myParent') ;var child = new Child('myChild') ;console.log(parent.getName()) ; //myParentconsole.log(child.getName()) ; //myChild 上面这种方法在子类构造函数中通过apply调用父类的构造函数来进行相同的初始化工作，这样不管父类中做了多少初始化工作，子类也可以执行同样的初始化工作。但是上面这种实现还存在一个问题，父类构造函数被执行了两次，一次是在子类构造函数中，一次在赋值子类原型时，这是很多余的，所以我们还需要做一个改进：123456789101112131415161718var Parent = function(name)&#123; this.name = name || 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : 1&#125; ;var Child = function(name)&#123; Parent.apply(this,arguments) ;&#125; ;Child.prototype = Parent.prototype ;var parent = new Parent('myParent') ;var child = new Child('myChild') ;console.log(parent.getName()) ; //myParentconsole.log(child.getName()) ; //myChild 这样我们就只需要在子类构造函数中执行一次父类的构造函数，同时又可以继承父类原型中的属性，这也比较符合原型的初衷，就是把需要复用的内容放在原型中，我们也只是继承了原型中可复用的内容。上面这种方式的原型图如下： 临时构造函数模式(圣杯模式)上面借用构造函数模式最后改进的版本还是存在问题，它把父类的原型直接赋值给子类的原型，这就会造成一个问题，就是如果对子类的原型做了修改，那么这个修改同时也会影响到父类的原型，进而影响父类对象，这个肯定不是大家所希望看到的。为了解决这个问题就有了临时构造函数模式。1234567891011121314151617181920var Parent = function(name)&#123; this.name = name || 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : 1&#125; ;var Child = function(name)&#123; Parent.apply(this,arguments) ;&#125; ;var F = new Function()&#123;&#125; ;F.prototype = Parent.prototype ;Child.prototype = new F() ;var parent = new Parent('myParent') ;var child = new Child('myChild') ;console.log(parent.getName()) ; //myParentconsole.log(child.getName()) ; //myChild 该方法的原型继承图如下：很容易可以看出，通过在父类原型和子类原型之间加入一个临时的构造函数F，切断了子类原型和父类原型之间的联系，这样当子类原型做修改时就不会影响到父类原型。 我的方法《Javascript模式》中到圣杯模式就结束了，可是不管上面哪一种方法都有一个不容易被发现的问题。大家可以看到我在’Parent’的prototype属性中加入了一个obj对象字面量属性，但是一直都没有用。我们在圣杯模式的基础上来看看下面这种情况：1234567891011121314151617181920212223var Parent = function(name)&#123; this.name = name || 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : 1&#125; ;var Child = function(name)&#123; Parent.apply(this,arguments) ;&#125; ;var F = new Function()&#123;&#125; ;F.prototype = Parent.prototype ;Child.prototype = new F() ;var parent = new Parent('myParent') ;var child = new Child('myChild') ;console.log(child.obj.a) ; //1console.log(parent.obj.a) ; //1child.obj.a = 2 ;console.log(child.obj.a) ; //2console.log(parent.obj.a) ; //2 在上面这种情况中，当我修改child对象obj.a的时候，同时父类的原型中的obj.a也会被修改，这就发生了和共享原型同样的问题。出现这个情况是因为当访问child.obj.a的时候，我们会沿着原型链一直找到父类的prototype中，然后找到了obj属性，然后对obj.a进行修改。再看看下面这种情况：1234567891011121314151617181920212223var Parent = function(name)&#123; this.name = name || 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : 1&#125; ;var Child = function(name)&#123; Parent.apply(this,arguments) ;&#125; ;var F = new Function()&#123;&#125; ;F.prototype = Parent.prototype ;Child.prototype = new F() ;var parent = new Parent('myParent') ;var child = new Child('myChild') ;console.log(child.obj.a) ; //1console.log(parent.obj.a) ; //1child.obj.a = 2 ;console.log(child.obj.a) ; //2console.log(parent.obj.a) ; //2 这里有一个关键的问题，当对象访问原型中的属性时，原型中的属性对于对象来说是只读的，也就是说child对象可以读取obj对象，但是无法修改原型中obj对象引用，所以当child修改obj的时候并不会对原型中的obj产生影响，它只是在自身对象添加了一个obj属性，覆盖了父类原型中的obj属性。而当child对象修改obj.a时，它先读取了原型中obj的引用，这时候child.obj和Parent.prototype.obj是指向同一个对象的，所以child对obj.a的修改会影响到Parent.prototype.obj.a的值，进而影响父类的对象。AngularJS中关于$scope嵌套的继承方式就是模范Javasript中的原型继承来实现的。根据上面的描述，只要子类对象中访问到的原型跟父类原型是同一个对象，那么就会出现上面这种情况，所以我们可以对父类原型进行拷贝然后再赋值给子类原型，这样当子类修改原型中的属性时就只是修改父类原型的一个拷贝，并不会影响到父类原型。具体实现如下：123456789101112131415161718192021222324252627282930313233343536373839var deepClone = function(source,target)&#123; source = source || &#123;&#125; ; target = target || &#123;&#125;; var toStr = Object.prototype.toString , arrStr = '[object array]' ; for(var i in source)&#123; if(source.hasOwnProperty(i))&#123; var item = source[i] ; if(typeof item === 'object')&#123; target[i] = (toStr.apply(item).toLowerCase() === arrStr) ? [] : &#123;&#125; ; deepClone(item,target[i]) ; &#125;else&#123; target[i] = item; &#125; &#125; &#125; return target ;&#125; ;var Parent = function(name)&#123; this.name = name || 'parent' ;&#125; ;Parent.prototype.getName = function()&#123; return this.name ;&#125; ;Parent.prototype.obj = &#123;a : '1'&#125; ;var Child = function(name)&#123; Parent.apply(this,arguments) ;&#125; ;Child.prototype = deepClone(Parent.prototype) ;var child = new Child('child') ;var parent = new Parent('parent') ;console.log(child.obj.a) ; //1console.log(parent.obj.a) ; //1child.obj.a = '2' ;console.log(child.obj.a) ; //2console.log(parent.obj.a) ; //1 综合上面所有的考虑，Javascript继承的具体实现如下，这里只考虑了Child和Parent都是函数的情况下：1234567891011121314151617181920212223242526272829303132var deepClone = function(source,target)&#123; source = source || &#123;&#125; ; target = target || &#123;&#125;; var toStr = Object.prototype.toString , arrStr = '[object array]' ; for(var i in source)&#123; if(source.hasOwnProperty(i))&#123; var item = source[i] ; if(typeof item === 'object')&#123; target[i] = (toStr.apply(item).toLowerCase() === arrStr) ? [] : &#123;&#125; ; deepClone(item,target[i]) ; &#125;else&#123; target[i] = item; &#125; &#125; &#125; return target ;&#125; ;var extend = function(Parent,Child)&#123; Child = Child || function()&#123;&#125; ; if(Parent === undefined) return Child ; //借用父类构造函数 Child = function()&#123; Parent.apply(this,argument) ; &#125; ; //通过深拷贝继承父类原型 Child.prototype = deepClone(Parent.prototype) ; //重置constructor属性 Child.prototype.constructor = Child ;&#125; ; 总结说了这么多，其实Javascript中实现继承是十分灵活多样的，并没有一种最好的方法，需要根据不同的需求实现不同方式的继承，最重要的是要理解Javascript中实现继承的原理，也就是原型和原型链的问题，只要理解了这些，自己实现继承就可以游刃有余。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"有趣的HTML5：离线存储","slug":"html5-offline-cache","date":"2014-10-21T06:45:31.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/10/21/html5-offline-cache/","link":"","permalink":"/2014/10/21/html5-offline-cache/","excerpt":"最近由于找工作一直没时间也没有精力更新博客，找工作真是一件苦逼的事情啊。。。不抱怨了，我们来看看HTML5的新特性—离线存储吧。 随着Web App的发展，越来越多的移动端App使用HTML5的方式来开发，除了一些HybridApp以外，其他一部分Web App还是通过浏览器来访问的，通过浏览器访问就需要联网发送请求，这样就使得用户在离线的状态下无法使用App，同时Web App中一部分资源并不是经常改变，并不需要每次都向服务器发出请求，出于这些原因，HTML5提出的一个新的特性：离线存储。通过离线存储，我们可以通过把需要离线存储在本地的文件列在一个manifest配置文件中，这样即使在离线的情况下，用户也可以正常使用App。","text":"最近由于找工作一直没时间也没有精力更新博客，找工作真是一件苦逼的事情啊。。。不抱怨了，我们来看看HTML5的新特性—离线存储吧。 随着Web App的发展，越来越多的移动端App使用HTML5的方式来开发，除了一些HybridApp以外，其他一部分Web App还是通过浏览器来访问的，通过浏览器访问就需要联网发送请求，这样就使得用户在离线的状态下无法使用App，同时Web App中一部分资源并不是经常改变，并不需要每次都向服务器发出请求，出于这些原因，HTML5提出的一个新的特性：离线存储。通过离线存储，我们可以通过把需要离线存储在本地的文件列在一个manifest配置文件中，这样即使在离线的情况下，用户也可以正常使用App。 怎么用首先来讲解下离线存储的使用方法，说起来也很简单。只要在你的页面头部像下面一样加入一个manifest的属性就可以了。1234&lt;!DOCTYPE HTML&gt;&lt;html manifest = \"cache.manifest\"&gt;...&lt;/html&gt; 然后cache.manifest文件的书写方式，就像下面这样：12345678910111213CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/ /offline.html 离线存储的manifest一般由三个部分组成:1.CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。2.NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。3.FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。 浏览器怎么解析manifest那么浏览器是怎么对离线的资源进行管理和加载的呢？这里需要分两种情况来讨论。 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 这个过程中有几个问题需要注意。 如果服务器对离线的资源进行了更新，那么必须更新manifest文件之后这些资源才能被浏览器重新下载，如果只是更新了资源而没有更新manifest文件的话，浏览器并不会重新下载资源，也就是说还是使用原来离线存储的资源。 对于manifest文件进行缓存的时候需要十分小心，因为可能出现一种情况就是你对manifest文件进行了更新，但是http的缓存规则告诉浏览器本地缓存的manifest文件还没过期，这个情况下浏览器还是使用原来的manifest文件，所以对于manifest文件最好不要设置缓存。 浏览器在下载manifest文件中的资源的时候，它会一次性下载所有资源，如果某个资源由于某种原因下载失败，那么这次的所有更新就算是失败的，浏览器还是会使用原来的资源。 在更新了资源之后，新的资源需要到下次再打开app才会生效，如果需要资源马上就能生效，那么可以使用window.applicationCache.swapCache()方法来使之生效，出现这种现象的原因是浏览器会先使用离线资源加载页面，然后再去检查manifest是否有更新，所以需要到下次打开页面才能生效。 咱们来试试吧说了这么多，不如自己动手来试试。这里需要说明的是，如果需要看到离线存储的效果，那么你需要把你的网页部署到服务器上，不管是本地还是生产环境服务器中，通过本地文件打开网页是无法体验到离线存储的。我在我的电脑上跑了一个本地node服务器，通过localhost访问。我的manifest文件向下面这样：123456789101112131415161718CACHE MANIFEST#v0.11CACHE:lib/ionic/js/ionic.bundle.jslib/angular-ui-router.jsjs/app.jslib/ionic/css/ionic.csscss/style.cssviews/login_header.htmlviews/login.htmllib/ionic/fonts/ionicons.ttf?v=1.5.2lib/ionic/fonts/ionicons.woff?v=1.5.2NETWORK:lib/ionic/fonts/ionicons.ttf?v=1.5.2lib/ionic/fonts/ionicons.woff?v=1.5.2css/style.css 然后我们访问网页看看效果。 可以看出浏览器根据manifest文件下载相应资源并且缓存在本地，现在我们来试试再次访问网页 资源已经离线存储在本地，所以浏览器不需要再次下载资源，可以直接使用本地缓存的资源。接着，我们更新下服务器上的资源，比如我修改下app.js，结果我这里就不显示了，跟上面那张图是一样的，更新的资源并没有生效，现在我们更新下manifest文件，比如把版本改为0.12 很显然，只有更新了manifest文件，对离线资源的更新才能在浏览器上生效。最后，我们来试试离线状态下是什么情况，这才是离线存储的重头戏。通过Chrome设置离线状态，刷新页面 由于在离线状态，所以浏览器无法访问到manifest文件，但是网页还是可以正常访问，这就是离线存储的威力。对于HTML5中离线存储对象window.applicationCache有几个事件需要我们关注下： 1.oncached:当离线资源存储完成之后触发这个事件，这个是文档的说法，我在Chrome上面测试的时候并没有触发这个事件。2.onchecking:当浏览器对离线存储资源进行更新检查的时候会触发这个事件3.ondownloading:当浏览器开始下载离线资源的时候会触发这个事件4.onprogress:当浏览器在下载每一个资源的时候会触发这个事件，每下载一个资源就会触发一次。5.onupdateready:当浏览器对离线资源更新完成之后会触发这个事件6.onnoupdate:当浏览器检查更新之后发现没有资源更新的时候触发这个事件 参考文章：https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cachehttp://diveintohtml5.info/offline.html","categories":[],"tags":[{"name":"html5","slug":"html5","permalink":"/tags/html5/"},{"name":"application-cache","slug":"application-cache","permalink":"/tags/application-cache/"}]},{"title":"CSS那些事","slug":"something-about-css","date":"2014-08-02T06:45:09.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/08/02/something-about-css/","link":"","permalink":"/2014/08/02/something-about-css/","excerpt":"今天跟大家分享一下CSS中一些比较重要和比较容易被忽略的东西，开始吧。","text":"今天跟大家分享一下CSS中一些比较重要和比较容易被忽略的东西，开始吧。 样式优先级当你在不同地方不同的选择器中对同一个元素属性添加了不同的样式的时候，该如何判断最后哪个样式会作用到元素上呢？判断的依据就是样式的优先级。样式优先级的判断分为三个步骤： 首先，根据样式的来源和重要性进行分组，一共可以分成五组(优先级从高到低) 用户自定义样式中带!important的样式 作者样式中带!important的样式 作者样式 用户自定义样式 浏览器样式 然后，如果在第一步中无法分出胜负，那么就根据选择器的权重进行判断。每种CSS选择器都有各自的权重，权重从大到小排列分别是： ID选择器 类选择器，伪类选择器，属性选择器 标签选择器，伪元素选择器 在计算样式优先级的时候除了考虑选择器的权重以外，当然还需要考虑内联样式和外联样式，很明显内联样式的优先级比外联的高，那么它的权重也大。综合这两种情况我们就有下面这样的计算方式：1234行内样式 1,0,0,0ID选择器 0,n,0,0类选择器，伪类选择器，属性选择器 0,0,n,0标签选择器，伪元素选择器 0,0,0,n 在上面n代表对应选择器的个数。根据这个方法，每组选择器都会有一个这样的四位数来表示权重，哪个选择器的数字权重越大它们的样式优先级就越高。比如下面几组选择器的权重123div .one&#123;&#125; 0,0,1,1div #one&#123;&#125; 0,1,0,1div a[href=\"one\"] #one&#123;&#125;0,1,1,2 在这一步计算样式优先级的时候有两个特殊情况，一个是通配符选择器它的权重是0,0,0,0，另一个是继承的样式没有优先级，也就是说它连0都没有。这两个特殊情况就会造成一种现象：1234567891011#out *&#123; color:green;&#125;#out #in&#123; color:black;&#125;&lt;div id=\"out\"&gt; &lt;div id=\"in\"&gt; &lt;div id=\"iin\"&gt;TEST&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 上面代码的结果是字体颜色为绿色而不是很多人想的黑色。在这段代码中，TEST有两个color样式，一个是#out *中的，一个是从#in中继承的，最后前者取得了胜利，就是因为继承的样式没有优先级，它连通配符都不如。所以说在重置样式的时候使用通配符不是一个好的习惯，因为它可能会带来一些奇怪的现象。 最后，如果第二步之后还是没办法区分出优先级的话，那么就很简单了，后出现的优先级更高。 在平时的开发中，我们应该善用样式的优先级规则，不能一味的通过增加选择器权重来覆盖样式，这样长久之后会使得代码变得无法维护。 参考 http://www.smashingmagazine.com/2010/11/02/the-important-css-declaration-how-and-when-to-use-it/ http://www.smashingmagazine.com/2010/04/07/css-specificity-and-inheritance/ http://css-tricks.com/specifics-on-css-specificity/ http://snook.ca/archives/html_and_css/understanding_c 块级元素块级元素通常独占一行并且在正常流中垂直摆放，可以设置高度和宽度。块级元素在格式化的时候可以分为水平格式化和垂直格式化。在水平方向上，元素的所有横向宽度之和要等于包含块的宽度，也就是要满足下面的等式：margin-left+border-left-width+padding-left+width+padding-right+border-right-right+margin-right=包含块的width。当width为auto时，块级元素的宽度会填满整个包含块。当margin-left和margin-right出现auto时，会根据上面公式计算使得margin-left=margin-right，这也就是设置margin为auto时可以实现居中效果的原因。在垂直方向上，情况就比水平方向上要复杂，因为可能会出现外边距叠加的现象。当height为auto时，跟水平方向不同，height会根据内容的高度来计算。而margin-top和margin-bottom为auto时，会被设置为0。 下面来说说垂直方向上外边距叠加的情况。首先，什么是外边距叠加？ 外边距叠加是指在正常流中毗邻的两个以上块级元素在垂直方向上的外边距发生叠加的现象。 根据上面的定义我们可以发生外边距叠加需要下面几个条件： 元素必须在正常流中，也就是说position不为absolute或fixed，并且没有浮动的元素 元素必须是块级元素，很明显在行内元素上设置上下外边距是没有效果的 发生外边距叠加的元素必须是毗邻的，也就是说两个元素是相邻的两个兄弟元素或者是父子关系的元素，而父子关系中必须是父元素和它的第一个子元素或者最后一个子元素。总结起来就是下面四种情况： 父元素的margin-top和它第一个子元素的margin-top 父元素的margin-bottom和它最后一个子元素的margin-bottom 元素的margin-bottom和它相邻的兄弟节点的margin-top 元素自身的margin-top和margin-bottom 下面来看前三种情况：DEMO很明显，父元素#out的上外边距和第一个子元素#first的上外边距发生了重叠；然后#first的下外边距和它的兄弟#last的上外边距发生了叠加；最后，父元素#out的下外边距和最后一个子元素#last的下外边距发生了叠加。对于外边距叠加，我觉得下面参考中smallni的总结很好，我就借用他的总结一下： 父元素和它的第一个子元素 父元素没有创建BFC 父子元素之间没有非空内容 父元素没有padding-top和border-top 父元素和它的最后一个子元素 父元素没有创建BFC 父子元素之间没有非空内容 父元素没有padding-bottom和border-bottom 父元素的height为auto，min-height为0 兄弟元素之间 兄弟元素都不是float元素 兄弟元素都不是absolute元素 兄弟元素都不是inline-block元素 根据上面的总结，我们也可以得出防止外边距叠加的方法：对于父子元素之间的情况，大多数情况下都是采用让父元素创建BFC的方式，对于BFC的概念大家可以google一下，这个也是CSS中一个很重要的概念，当然还有一个办法就是添加padding或border；而对于兄弟元素之间的情况，破坏那三条中间任意一条就可以了。讲了外边距叠加，那在发生外边距叠加的时候，元素之间的外边距该怎么计算了，这也需要分几种情况讨论。 如果发生叠加的外边距都是正值，那么就取两者中间最大的那个作为最后的边距 如果发生叠加的外边距都是负值，那么就取两者绝对值较大的那个然后进行负向位移 如果发生叠加的外边距有正有负，那么就把负值中间绝对值最大的那个和正值中最大的相加，最后得出的就是最后的边距最后在进行计算的时候，所有相邻的外边距应该一起参与计算，不能分别进行计算然后再加起来。比如下面的情况：12345678910&lt;div style=\"margin:50px 0; background-color:green; width:50px;\"&gt; &lt;div style=\"margin:-60px 0;\"&gt; &lt;div style=\"margin:150px 0;\"&gt;A&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div style=\"margin:-100px 0; background-color:green; width:50px;\"&gt; &lt;div style=\"margin:-120px 0;\"&gt; &lt;div style=\"margin:200px 0;\"&gt;B&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 正确的计算A和B之间边距的方法应该是，取出所有负值然后找绝对值最大的也就是-120，然后在找出正值中最大的200，最后把这两个边距相加得出80，也就是最后A和B之间的边距。 参考 http://www.smallni.com/collapsing-margin/ http://www.w3help.org/zh-cn/kb/006/ 行内元素行内元素在摆放的时候不会产生换行，也就是说行内元素在空间足够的情况下会出现在同一行中。行内元素有几个比较重要的概念： 对于行内元素设置高度和宽度是无效的 内容区：由内容高度所决定的区域 行内框：对于非替换元素(&lt;a&gt;,&lt;span&gt;…)高度由line-height决定，对于替换元素(&lt;img&gt;)高度由内容和内外边距决定 内容区的上下加上line-height与font-size差值的一半就形成了行内框 vertical-align是根据行内框进行对其的记住上面几个概念，对于行内元素的布局应该就能明白了。 边距和边框外边距外边距是什么我就不多说了，这里提几个比较容易误会的地方。首先，当外边距是百分比时，它是根据父元素的宽度进行计算的，上下边距也是根据这个值进行计算。也就是说上下外边距的值也是以父元素的宽度为标准的。其次，大家有时候书写margin属性的时候都喜欢使用缩写的方式，写两个宽度或者一个，可是如果写上三个的话会怎么样呢？浏览器对于外边距的计算有下面几个规则： 当缺少下边距时，使用上边距 当缺少左边距时，使用右边距 当缺少右边距时，使用上边距 用上面这三条规则就可以很好的解释边距缩写的原理了。这个原则对于所有边距和边框的缩写都适用。 内边距对于内边距唯一要说的就是IE盒模型和W3C的盒模型的区别，在IE中padding和border是包括在元素width和height中的，而W3C的盒模型是不包括这两个的。还有一个问题就是内边距为百分比时的计算和内边距一样，都是以父元素的宽度为标准。 边框边框有一个特点就是元素的背景会延续到边框，也就是说边框是覆盖在元素背景之上的。 浮动和定位包含块元素的包含块就是包含元素的那个元素，但是对于不同的元素情况会不一样： 浮动元素的包含块是最近的块级元素祖先的内容区域 绝对定位元素的包含块是最近的有定位的祖先。如果这个祖先是块级元素，那么包含块就是块级元素的边框区域；如果是行内元素，那么包含块就是行内元素的内容区域。 相对定位和static定位的元素的包含块就是最近的块级元素或者行内元素的内容区域 浮动 浮动元素会形成块级元素 浮动元素和块级元素重叠时，块级元素的背景在浮动元素下，而内容在上 浮动元素和行内元素重叠时，行内元素在上看DEMO从上面例子很容易看出浮动元素和块级元素重叠的时候不同的现象。 绝对定位 对于绝对定位在横向方向上也有一个计算公式：left+(margin-left)+(border-left-width)+(padding-left)+width-(padding-right)+(border-right-width)+(margin-right)+right=包含块width这个公式在同时指定了绝对定位并且还指定了外边距的情况下非常有用。 如果绝对定位不指定偏移，那么元素会怎么布局呢？很多人认为是相对于包含块进行定位，其实不是这样的。如果不指定偏移的话，元素会根据原来正常流中的位置进行定位。DEMO如果你在上面添加一个left偏移，你会发现它是在正常流的情况下发生偏移的，只有同时指定了两个方向的偏移，才会根据包含块进行定位。 如果绝对定位的元素没有指定width和height那么我们可以通过设置偏移来对元素进行拉伸。DEMO通过修改偏移，你就可以控制元素的大小。 在同时具有margin和偏移的时候该怎么给元素定位呢？ 非替换元素 如果left,right,width都为auto，那么按照正常流方式进行布局，并且把值为auto的margin-left和margin-right设为0 如果left,right,width都不为auto 如果margin-left和margin-right都为auto，那么根据公式把两个设为相同的长度；如果计算出的长度为负数，那么就把margin-left设为0 如果margin-lef或margin-right其中有一个为auto,那么根据公式计算出auto的值 其他情况，首先把值为auto的margin设为0 如果left不为auto，width根据内容计算值，其他值根据公式进行计算 如果width不为auto，首先按照正常流定位，然后根据公式计算margin的值 如果right不为auto，width根据内容计算，其他值根据公式进行计算 如果left,width不为auto，right根据公式计算 如果left,right不为auto，width的值根据公式计算 如果width,right不为auto，left根据公式计算 替换元素 宽度由内容区决定 如果left和right为auto，那么根据正常流定位 如果left或right为auto，则把对于的值为auto的margin改为0 如果此时，margin都是auto，那么根据公式计算平方剩余长度 如果这时候left还是auto，那么根据公式计算left的值上面这些计算原则就可以解释一个现象，就是之前在网上看到一种绝对居中的方法：DEMO这个方法把绝对定位元素的偏移都设为0，然后通过margin:auto来实现居中，这个方法用上面的原则就可以说通了。 相对定位相对定位相对来说就比较容易了。就两个点： 偏移是根据元素本来在正常流中的位置计算的 相对定位会影响其他元素的定位，相对定位元素会占据它原来的空间 PS:这篇博客大家看得可能有点痛苦，貌似现在SegmentFault不支持CodePen，不知道大家有没有什么办法可以做到。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"/tags/css/"}]},{"title":"(译)深入理解Promise五部曲：5.LEGO","slug":"understand-promise-5","date":"2014-07-19T06:44:48.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/07/19/understand-promise-5/","link":"","permalink":"/2014/07/19/understand-promise-5/","excerpt":"在Part4:扩展问题中，我讨论了如何扩展和抽象Promise是多么的常见，以及这中间的一些问题。但是为什么promise对于开发者来说不是足够友好的呢？这就是它的设计用意吗？","text":"在Part4:扩展问题中，我讨论了如何扩展和抽象Promise是多么的常见，以及这中间的一些问题。但是为什么promise对于开发者来说不是足够友好的呢？这就是它的设计用意吗？ #I’ve Got Friends In Low PlacesPromise被设计为低级别的构建块。一个promise就像一个乐高玩具。单个乐高只是一个有趣的玩具。但是如果把它们拼在一起，你会感受到更多的乐趣。问题是promise不是你小时候玩儿的那个有趣LEGO，它们不是充满想象力的打气筒，也不是Gandalf mini-figure(一种乐高玩具)。都不是，promise只是你的简单老旧的4X2的砖块。这并不是使它们非常有用。但是它们是你箱子中最重要的组成部分之一。当它们彼此分开时它们只是这么个东西，但是当把它们整合在一起它们就会散发出光芒。换句话说，promise本质上是一个构建在真实用户之上的低级别的API。这是对的：promise并不是给开发者使用的，它们是给库作者使用的。你会从它们那收益许多，但是你很可能不是直接使用它们。你将会使用的是经过许多库组合包装之后的结果。 #控制 VS 值请允许我矫正第一个最大的关于promise的误解：它们不是真正关于流程控制的。promise当然可以链接在一起来变成近似异步流程控制的东西。但是最后证明它们并不像你想象的那样擅长这个任务。promises确实只是一个值的容器。这个值可能现在就存在也可能是未来的一个值。但是不管怎样，它只是一个值。这是promise最有意义的好处之一。它们在值的上面创建了一个强大的抽象使得值不再是暂存的东西。换句话说，不管那个值现在是否存在，你都可以用同样的方式使用promise。在这个系列的第三部分中，我讨论过promise必须是不可变的，它们作为值的意义也是基于这个特点的。promises就像状态的小型的自包含的表现方式。它们是可组合的，也就意味着你全部的程序可以用它们来表示。 限制就像你不能奢望一个单独的4X2的乐高可以变成一个跑车，让promise成为你的异步流程控制机制也是一种奢望。那么promises作为一个非暂存的不可变的值对于解决异步任务意味着什么呢？在它们设计哲学的约束中，有它们擅长并且可以有帮助的东西。在剩下的内容中，我会讨论这个限制。但是我并不打算作为一个promise的批判者。我试图去强调扩展和抽象的重要性。 错误处理当我说promise只是一个值的容器的时候我撒了个小慌。实际上，它是一个成功值或者失败信息的容器。在任何时候，一个promise是一个未来的成功值或者在获取这个值时的失败信息。不会超过这两种情况。在某种意义上说，一个promise是一个决策结构，一个if..then..else。其他人喜欢把它想成一个try..catch结构。不管是哪种理解，你就像在说”请求一个值，不管成功还是失败”。就像尤达说，”Do or do not, there is no try.”。考虑下面这个情况：12345678910111213function ajax(url) &#123; return new Promise( function(resolve,reject)&#123; // make some ajax request // if you get a response, `resolve( answer )` // if it fails, `reject( excuses )` &#125; );&#125;ajax( \"http://TheMeaningOfLife.com\" ).then( winAtLife, keepSearching); 看到winAtLife()和keepSearching()函数了吗？我们在说，”去问问生命的意义，不管你有没有找到答案，我们都继续”。如果我们不传入keepSearching会怎样？除了作为一个乐观主义者假设你会找到答案然后在生命长河中取胜，这里会有什么危险呢？如果promise没有找到生命的意义（或者如果在处理答案的过程中发生了javascript异常），它会默默地保留着错误的事实，也许会永远保留着。就算你等上一百万年，你都不会知道对于答案的请求失败了。你只能通过观察才能知道它失败了。这可能需要深入到形而上学或者量子学的东西。让我们停止在这吧。所以不带失败处理函数的promise是一个会默默地失败的promise。这并不好。这意味着如果你忘记了，你会陷入失败的陷阱而不是成功。所以你会怀疑：为什么promises会忽略失败处理函数呢？因为你可能现在不在意失败的情况，只有以后某个时刻会关心。我们程序的暂时性意味着系统现在不会知道你以后会想做什么。现在忽略失败处理函数也许对你来说是正合适的，因为你知道你会把这个promise链接到另一个promise，并且那个promise有一个失败处理函数。所以promise机制让你可以创建不需要监听失败的promise。这里有一个很微妙的问题，很可能也是大多数刚接触promise的开发者会碰到的问题。 束缚我们的链子为了理解这个问题，我们首先需要理解promises是如何链接在一起的。我认为你会很快明白promise链是强大并且有一点复杂的。1234567ajax( \"http://TheMeaningOfLife.com\" ).then( winAtLife, keepSearching)// a second promise returned here that we ignored!; ajax(..)调用产生了第一个promise，然后then(..)调用产生了第二个promise。我们没有捕捉并且观察在这段代码中的第二个promise，但是我们可以。第二个promise是根据第一个promise处理函数如何运行来自动变成fulfilled状态(成功或者失败)。第二个promise不会在意第一个promise是成功还是失败。它在意第一个promise的处理函数(不管成功还是失败)。这是promise链的关键。但是这有一点不好理解，所以重复读上面那段话直到你理解为止。考虑下promise代码通常是怎么写的(通过链):123456ajax( \"..\" ).then( transformResult ).then( displayAnswer, reportError); 这段代码也可以像下面这么写，效果是一样的：12345678910var promiseA = ajax( \"..\" );var promiseB = promiseA.then( transformResult );var promiseC = promiseB.then( displayAnswer, reportError);// we don't use `promiseC` here, but we could... Promise A是唯一在意ajax(..)结果的promise。Promise B只关心Promise A在transformResult(..)函数内部是如何处理的(不是Promise A的结果本身),同样的，Promise C只关心Promise B在displayAnswer(..)或者reportError(..)函数内部是如何处理的(不是Promise B结果本身)。再一次，重复读这段话直到理解。在transformResult(..)内部，如果它立刻完成了它的任务，然后Promise B就会立刻完成，不管成功还是失败。然而，如果transformResult(..)不能立刻完成，而是创建它自己的promise，我们称它为Promise H1(‘H’是’hidden’,因为它是隐藏在内部的)。原本Promise B返回的等待我们如何处理Promise A的promise，现在概念上被Promise H1替换了(并不是真的替换了，只是被说成一样的)。所以，现在当你说promiseB.then(..)时，它实际上就像说promiseH1.then(..)。如果Promise H1成功了，displayAnswer(..)会被调用，但是如果它失败了，reportError(..)会被调用。这就是promise链是如何工作的。但是，如果Promise A(由ajax调用返回)失败了会怎样？promiseA.then(..)调用没有注册一个失败处理函数。它会默默地隐藏错误吗？它会的，除了我们链接上Promise B然后在上面注册一个错误处理函数:reportError(..)。如果Promise A失败了，transformResult(..)不会被调用，并且没有错误处理函数，所以Promise B马上被标记为失败，所以reportError(..)会被调用。如果Promise A成功了，transformResult(..)会被执行，然后当运行transformResult(..)时有一个错误会怎样？Promise B被标记为失败，然后reportError(..)也会被调用。但是这里是危险的地方，这个地方甚至有经验的开发者都会遗漏的！如果Promise A成功了(成功的ajax(..))，然后Promise B成功了(成功的transformResult(..))，但是当运行displayAnswer(..)时有一个错误会怎样？你也许会认为reportError(..)会被调用？大多数人会这么想，但是不是的。为什么？因为来自displayAnswer(..)的一个错误或者失败promise导致一个失败的Promise C。我们监听Promise C失败的情况了吗？仔细看看。没有。为了确保你不会漏掉这种错误并且让它默默地隐藏在Promise C状态内部，你也会希望监听Promise C的失败：123456789101112var promiseC = promiseB.then( displayAnswer, reportError);// need to do this:promiseC.then( null, reportError );// or this:, which is the same thing:promiseC.catch( reportError );// Note: a silently ignored *Promise D* was created here! OK,所以现在我们捕获displayAnswer(..)内部的错误。不得不去记住这个有一点坑爹。 乌龟但是有一个更加微妙的问题！如果当处理displayAnswer(..)返回的错误时，reportError(..)函数也有一个JS异常会怎样？会有人捕获这个错误吗？没有。看！上面有一个隐含的Promise D，并且它会被告知reportError(..)内部的异常。OMG，你肯定会想。什么时候才能停止？它会这样一直下去吗？一些promise库作者认为有必要解决这个问题通过让”安静的错误”被作为全局异常抛出。但是这种机制该如何得知你不想再链接promise并且提供一个错误处理函数呢？它如何知道什么时候应该通报一个全局异常或者不通报呢？你肯定不希望当你已经捕获并且处理错误的情况下仍然有很多控制台错误信息。在某种意义上，你需要可以标记一个promise为“final”，就像说“这是我链子中的最后一个promise”或者“我不打算再链接了，所以这是乌龟停止的地方”。如果在链的最后发生了错误并且没有被捕获，然后它需要被报告为一个全局异常。从表面上我猜测这似乎是很明智的。这种情况下的实现像下面这样：12345678var promiseC = promiseB.then( displayAnswer, reportError);promiseC.catch( reportError ).done(); // marking the end of the chain 你仍然需要记住调用done()，要不然错误还是会隐藏在最后一个promsie中。你必须使用稳固的错误处理函数。“恶心”，你肯定会这么想。欢迎来到promises的欢乐世界。 Value vs Values对于错误处理已经说了很多了。另一个核心promsie的限制是一个promise代表一个单独的值。什么是一个单独的值呢？它是一个对象或者一个数组或者一个字符串或者一个数字。等等，我还可以在一个容器里放入多个值，就像一个数组或对象中的多个元素。Cool！一个操作的最终结果不总是一个值，但是promise并不会这样，这很微妙并且又是另一个失败陷阱：1234567891011121314151617function ajax(url) &#123; return new Promise( function(resolve,reject)&#123; // make some ajax request // if you get a response, `resolve( answer, url )` // if it fails, `reject( excuses, url )` &#125; );&#125;ajax( \"..\" ).then( function(answer,url)&#123; console.log( answer, url ); // .. undefined &#125;, function(excuses,url)&#123; console.log( excuses, url ); // .. undefined &#125;); 你看出这里面的问题了吗？如果你意外的尝试传递超过一个的值过去，不管传给失败处理函数还是成功处理函数，只有第一个值能被传递过去，其他几个会被默默地丢掉。为什么？我相信这和组合的可预测性有关，或者一些其他花哨的词汇有关。最后，你不得不记住包裹自己的多个值要不然你就会不知不觉的丢失数据。 并行真实世界中的app经常在“同一时间”发生超过一件事情。本质上说，我们需要构建一个处理器，并行处理多个事件，等待它们全部完成再执行回调函数。相比于promise问题，这是一个异步流程控制的问题。一个单独的promise不能表达两个或更多并行发生的异步事件。你需要一个抽象层来处理它。在计算机科学术语中，这个概念叫做一个“门”。一个等待所有任务完成，并且不关心它们完成顺序的门。在promise世界中，我们添加一个API叫做Promise.all(..)，它可以构建一个promise来等待所有传递进来的promise完成。1234567Promise.all([ // these will all proceed \"in parallel\" makePromise1(), makePromise2(), makePromise3()]).then( .. ); 一个相近的方法是race()。它的作用和all()一样，除了它只要有一个promise返回消息就执行回调函数，而不等待其他promise的结果。当你思考这些方法的时候，你可能会想到许多方式来实现这些方法。Promise.all(..)和Promise.race(..)是原生提供的，因为这两个方法是很常用到的，但是如果你还需要其他的功能那么你就需要一个库来帮助你了。限制的另一个表现就是你很快就会发现你需要自己使用Array的相关方法来管理promise列表，比如.map(..)和.reduce(..)。如果你对map/reduce不熟悉，那么赶紧去熟悉一下，因为你会发现当处理现实世界中promise的时候你经常会需要它们。幸运的是，已经有很多库来帮助你了，并且每天还有很多新的库被创造出来。 Single Shot Of Espresso，Please！另一个关于promise的事情是它们只会运行一次，然后就不用了。如果你只需要处理单个事件，比如初始化一个也没或者资源加载，那么这样没什么问题。但是如果你有一个重复的事件(比如用户点击按钮)，你每次都需要执行一系列异步操作会怎么样呢？Promise并不提供这样的功能，因为它们是不可变的，也就是不能被重置。要重复同样的promise，唯一的方法就是重新定义一个promise。123456$(\"#my_button\").click(function(evt)&#123; doTask1( evt.target ) .then( doTask2 ) .then( doTask3 ) .catch( handleError );&#125;); 太恶心了，不仅仅是因为重复创建promise对于效率有影响，而且它对于职责分散不利。你不得不把多个事件监听函数放在同一个函数中。如果有一个方式来改变这种情况就好了，这样事件监听和事件处理函数就能够分开了。Microsoft的RxJS库把这种方式叫做”观察者模式”。我的asynquence库有一个react(..)方法通过简单的方式提供了一个类似的功能。 盲区…在一个已经被使用回调函数的API占据的世界中，把promise插入到代码中比我们想象的要困难。考虑下面这段代码：123456789101112function myAjax(url) &#123; return new Promise( function(resolve,reject)&#123; ajax( url, function(err,response)&#123; if (err) &#123; reject( err ); &#125; else &#123; resolve( response ); &#125; &#125; ) &#125; );&#125; 我认为promise解决了回调地狱的问题，但是它们代码看起来仍然像垃圾。我们需要抽象层来使得用promise表示回调变得更简单。原生的promise并没有提供这个抽象层，所以结果就是通过原生promise写出来的代码还是很丑陋。但是如果有抽象层那么事情就变得很简单了。例如，我的asynquence库提供了一个errfcb()插件(error-first callback)，用它可以构建一个回调来处理下面这种场景:12345function myAjax(url) &#123; var sq = ASQ(); ajax( url, sq.errfcb() ); return sq;&#125; Stop The Presses!有时，你想要取消一个promise而去做别的事情，但是如果现在你的promise正处在挂起状态会怎样呢？123456789var pr = ajax( \"..\" ).then( transformResult ).then( displayAnswer, reportError);// Laterpr.cancel(); // &lt;-- doesn't work! 所以，为了取消promise，你需要引入一下东西：123456789101112131415function transformResult(data) &#123; if (!pr.ignored) &#123; // do something! &#125;&#125;var pr = ajax( \"..\" ).then( transformResult ).then( displayAnswer, reportError);// Laterpr.ignored = true; // just hacking around 换句话说，你为了能够取消你的promise，在promise上面加了一层来处理这种情况。你不能从promise取消注册处理函数。并且因为一个promise必须不可变，你能够直接取消一个promise这种情况是不允许出现的。从外部取消一个promise跟改变它的状态没有什么区别。它使得promise变得不可靠。许多promise库都提供了这种功能，但是这明显是一个错误。取消这种行为是不需要promise，但是它可以出现在promise上面的一个抽象层里。 冗长另一个关于原生promise的担心是有些事情并没有被实现，所以你必须自动手动实现它们，而这些事情对于可扩展性是很重要的，但是这些东西经常会导致令人讨厌的重复代码。看一个例子，在每一个promise的完成步骤中，有一个设定就是你希望保持链式结构，所以then(..)方法会返回一个新的promise。但是如果你想要加入一个自己创建的promise并且从一个成功处理函数中返回，这样你的promise就可以加入到链的流程控制中。12345678910111213function transformResult(data) &#123; // we have to manually create and return a promise here return new Promise( function(resolve,reject)&#123; // whatever &#125; );&#125;var pr = ajax( \"..\" ).then( transformResult ).then( displayAnswer, reportError); 不同的是，就像上面解释的一样，从第一个then(..)返回的隐藏的promise立刻就完成(或者失败)，然后你就没办法让剩下的链异步延迟。如果有一个抽象层能够通过某种方式把自动创建/链接的promise暴露给你，然后你就不需要创建自己的promise来替换了，这样该多好。换句话说，如果有一个设定假设你需要为了异步的目的使用链，而不是你只是需要漂亮得执行异步。（也就是说你确实是希望你的代码可以异步执行，而不是说希望整个异步流程看过去好看点）。另一个例子：你不能直接传递一个已经存在的promise给then(..)方法，你必须传递一个返回这个promise的函数。123456789var pr = doTask2();doTask1().then( pr ); // would be nice, but doesn't work!// instead:doTask1().then( function()&#123; return pr; &#125; ); 这个限制性是有很多原因的。但是它只是减弱了有利于保持可扩展性和可预测性的用法的简洁。抽象可以容易的解决这个问题。 全剧终所有这些原因就是为什么原生的promise API是强大同时也是有局限性的。关于扩展和抽象是一个成熟的领域。许多库正在做这些工作。就像我之前说的，asynquence是我自己的promise抽象库。它很小但是很强大。它解决了所有博客中提到的promise的问题。我后面会写一篇详细的博客来介绍asynquence是如果解决这些问题的，所以敬请期待。 原文地址：http://blog.getify.com/promises-part-5/ 深入理解Promise五部曲–1.异步问题深入理解Promise五部曲–2.转换问题深入理解Promise五部曲–3.可靠性问题深入理解Promise五部曲–4.扩展性问题深入理解Promise五部曲–5.乐高问题","categories":[],"tags":[{"name":"promise","slug":"promise","permalink":"/tags/promise/"}]},{"title":"(译)深入理解Promise五部曲：4.扩展问题","slug":"understand-promise-4","date":"2014-07-09T06:44:46.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/07/09/understand-promise-4/","link":"","permalink":"/2014/07/09/understand-promise-4/","excerpt":"现在，我希望你已经看过深入理解Promise的前三篇文章了。并且假设你已经完全理解Promises是什么以及深入讨论Promises的重要性。","text":"现在，我希望你已经看过深入理解Promise的前三篇文章了。并且假设你已经完全理解Promises是什么以及深入讨论Promises的重要性。 不要扩展原生对象！回到2005年，Prototype.js框架是最先提出扩展Javascript原生对象的内置prototype属性的框架之一。它们的想法是我们可以通过向prototype属性添加额外的方法来扩展现有的功能。如果你对近十年Javascript编程做一个简单的调查，比如使用google简单搜索下，你会发现对于这个想法有很多反对意见。它们都是有原因的。大多数开发者会告诉你：“不要扩展原生对象”或者“只在polyfill的时候扩展原生对象”。后者意味着只有当扩展的功能已经被列入规范然后你只是为了能在旧的环境中使用这些功能的时候才能对元素对象进行扩展。 数组Push方法想象一个真实的场景(确实发生在我身上)：回到Netscape3/4和IE4的时代，当时的JS并没有现在这么友好。作为许多显著差异中的一个，数组并没有push(..)方法来向它的尾部添加元素。所以，一些人会通过下面这段代码来扩展：1234//Netscape 4 doesn't hava Array.pushArray.prototype.push = function(elem)&#123; this[this.length - 1] = elem ;&#125; 乍一看可能觉得没问题，但是你很快就会发现一些问题。 这里需要一个if来判断原生是否有对于push(..)的支持，如果有我们就可以使用原生的push(..)方法。 我们需要注意我们已经破坏了数组对象for..in循环行为，因为我们的push(..)方法会出现在for..in循环的结果中。当然，你不应该在数组上使用for..in循环，这又是另外一个话题了。 有一个和1相关的更大的问题。不仅仅是需要一个if判断：123if(!Array.prototype.push)&#123; //make our own&#125; 我们应该问问我们自己，如果内置的push(..)实现和我们的实现不兼容怎么办？如果内置的实现接受不一样数量的参数或者不一样的参数类型怎么办？如果我们的代码依赖于我们自己实现的push(..)，然后我们只是简单的用新的方法替换我们自己的方法，那么代码会出现问题。如果我们的实现覆盖了内置的push(..)实现，然后如果一些JS库期望使用内置的标准push(..)方法怎么办？这些问题是真实发生在我身上的。我有一个工作是在一个用户的古老的网站上加入一个组件，然后这个组件依赖于jQuery。我们组件在其他网站都可以正常使用，但是在这个特殊的站点却无法使用。我花了很多时间来找出问题。最终，我定位到了上面那个if代码片段。这里有什么问题呢？它的push(..)实现只接受一个参数，然而jQuery中期望是通过push(el1,el2,...)来调用push方法，所以它就无法正常运行了。Oops。但是猜猜当我移除原来的push代码时发生了什么？在其他网站这个组件也不能使用的。为什么？我还是不知道具体是为什么。我认为他们意外地依赖于外部变量，而这些外部变量没有传递进来。但是，真正的问题是，有人通过一种对于未来存在潜在危险的方式扩展内置原生对象，导致这个方法在未来可能无法正常运行。我不是唯一遇到这个问题的人。成千上万的开发者都遇到了这种情况。我们中的大多数认为你必须十分小心当你扩展原生JS对象时。如果你这么做了，你最好不要使用跟语言新版本中的方法名相同的名字。 Promise扩展为什么所有的老爷爷抱怨如今Promises的火热呢？因为那些开发Promise“polyfills”的人似乎忘记或者抛弃了老人们的智慧。他们开始直接往Promise和Promsie.prototype上加额外的东西。我真的需要再去解释为什么这是一个“未来的”坏点子吗？ Blue In The Face我们可以一直争论这个问题到死，但是仍然不能改变这个事实。如果你扩展原生对象，你就是和未来敌对的，就算你觉得你自己已经做得很好了。而且，你用越大众化的名字来扩展原生对象，你越有可能影响未来的人。让我们看看Bluebird库，因为它是最流行的Promisepolyfill/库之一。它足够快但是它跟其他库比起来也更加大。但是速度和大小并不是我现在担心的。我关心的是它选择了把自己添加到Promise的命名空间上。就算它使用一个polyfill安全的方式，实际上并没有，事实就算它添加许多额外的东西到原生对象上。例如，Bluebird添加了Promise.method(..):123456789function someAsyncNonPromiseFunc() &#123; // ...&#125;var wrappedFn = Promise.method( someAsyncNonPromiseFunc );var p = wrappedFn(..);p.then(..)..; 看起来没什么问题，是吗？当然。但是如果某天规范需要添加Promise.method(..)方法。然后如果它的行为和Bluebird有很大的区别会怎么样呢？你又会看到Array.prototype.push(..)一样的情况。Bluebird添加了许多东西到原生的Promise。所以有很多可能性会在未来会发生冲突。我希望我从来不需要去修复某个人的Promise扩展代码。但是，我很可能需要这么做。 未来约束但是这还不是最糟的。如果Bluebir非常流行，然后许多现实中的网站依赖于这么一个扩展，突然一天TC39协会通过某种方式强制避免扩展官方规范，那么这些依赖于扩展的网站都将崩溃。你看，这就是扩展原生对象的危险所在：你为了实现你的功能然后扩展原生对象，然后就拍拍屁股把这些烂摊子留给了TC39成员们。因为你愚蠢的决定Javascript的维护者只能选择其他机制。不相信我？这种情况已经发生很多次了。你知道为什么在19年的JS历史中typeof null === &quot;object&quot;这个bug一直无法修复吗？因为太多的代码都依赖于这段代码了。如果他们修复了这个bug，那么结果可想而知。我真的不想这种事情发生在Promsie身上。请停止通过扩展原生对象来定义Promise polyfill/库。 包装抽象我认为我们需要更多不破坏规范的polyfill，像我的”Native Promise Only“。我们需要良好，稳固，性能优秀但是和标准兼容的polyfill。特别的，我们需要它们以便于那些需要扩展promise的人可以在这个包装上进行操作。我们不应该很容易获得一个Promisepolyfill然后创建我们自己的SuperAwesomePromise包装在它上面吗？已经有很多的好例子了，比如Q和when我自己也写了一个，叫做asnquence(async + sequence)我的是设计来隐藏promises的，因为promise是低级别的API，所以与其给你一个简单的抽象的东西不如隐藏丑陋的细节。例如，比较下下面两段代码原生Promises：1234567891011121314151617181920212223function delay(n) &#123; return new Promise( function(resolve,reject)&#123; setTimeout( resolve, n ); &#125; );&#125;function request(url) &#123; return new Promise( function(resolve,reject)&#123; ajax( url, function(err,res)&#123; if (err) reject( err ); else resolve( res ); &#125; ); &#125; );&#125;delay( 100 ).then( function()&#123; return request( \"some/url\" );&#125; ).then( success, error); asynquence：1234567891011121314151617function delay(n) &#123; return ASQ( function(done)&#123; setTimeout( done, n ); &#125; );&#125;function request(url) &#123; return ASQ( function(done)&#123; ajax( url, done.errfcb ); &#125; );&#125;delay( 100 ).val( \"some/url\" ).seq( request ).then( success ).or( error ); 希望你能够通过这个简单的例子看出asynquence是如何降低使用promises来表达异步流程的难度的。它在底层实现为你创建promise，它自动把它们连接在一起，然后为同样的组合模式提供了简单的语法。显然，我认为asynquence是非常令人惊奇的。我认为你应该看看一些例子，然后看看大家扩展的插件，这些插件使得它能提供更多的便利。如果asynquence不是你的菜，那么你可以再寻找一个适合你的好用知名的抽象库。但是请不要使用那些扩展原生Promise的库。这对于未来不是一件好事。 总结Promise是令人惊奇的并且它们正在改变许多JS开发者编写和维护一部流程的方式。ES6带来的原生Promise是这个语言一个重大的胜利。为了加速这个胜利的过程，我们中的许多人开发Promise polyfill和Promise库。但是不要因为Promise带来的兴奋和喜悦让你忘了一个不可否认的事实：扩展原生对象是一件危险并且充满冒险的事情，并仅仅对于库的作者也包括使用这些库的所有人。最后，请负有责任感并且使用安全的promise扩展。我们在将来会感谢你的。 原文地址：http://blog.getify.com/promises-part-4/ 深入理解Promise五部曲–1.异步问题深入理解Promise五部曲–2.转换问题深入理解Promise五部曲–3.可靠性问题深入理解Promise五部曲–4.扩展性问题深入理解Promise五部曲–5.乐高问题","categories":[],"tags":[{"name":"promise","slug":"promise","permalink":"/tags/promise/"}]},{"title":"(译)深入理解Promise五部曲：3.可靠性问题","slug":"understand-promise-3","date":"2014-07-02T06:44:43.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/07/02/understand-promise-3/","link":"","permalink":"/2014/07/02/understand-promise-3/","excerpt":"如果你需要赶上我们关于Promise的进度，可以看看这个系列前两篇文章深入理解Promise五部曲–1.异步问题和深入理解Promise五部曲–2.控制权转移问题。","text":"如果你需要赶上我们关于Promise的进度，可以看看这个系列前两篇文章深入理解Promise五部曲–1.异步问题和深入理解Promise五部曲–2.控制权转移问题。 Promise状态 == 信任在前面，我们说明了几个关于Promises如何工作的要点，这些要点是我们之所以可以信任promise机制作为控制转移的一种解决方案的基础。这些要点直接来自Promises/A+规范。任何本地实现或者polyfill或者库都必须通过一个全面严格的测试来确定是否符合规范。对于promises可靠性是最基本的，因为如果没有可靠性，那么你就跟使用普通的回调一样了。你必须谨慎地编写那些涉及到异步调用第三方库的代码。你必须自己来解决状态跟踪的问题然后确保第三方库不会出问题。如果没有可靠的promises你自己可以完成异步任务吗？当然可以。但是问题是，你自己无法处理得很完美，你得把很多额外的变量加到你的代码中并且你会产生一个未来的维护风险，代码会变得很难维护。Promises是被设计用来规范和集中这种逻辑的。你可以使用一个规范的promise系统而不用担心可靠性问题，因为它会按照Promises机制来执行。 可依赖吗？在理论上这个可靠性保证合同听起来很棒。但是在JavaScript中真的有可能有这么一个机制吗？ 可靠性在我开始说这个问题之前，我们首先排除一些JS代码中的可靠性问题： 我们这里的讨论跟密码/加密中的“私有性”和“安全”无关。 和JS代码可以被用户通过查看源码看到无关。 和一个黑客可以侵入你的服务器来发送一些恶意代码或者通过中间人攻击来劫持浏览器和服务器之间的连接来实现同样的目的或者甚至在运行时使用XSS漏洞来注入恶意代码无关。 同时，也和恶意代码一旦存在你的页面就可以理论上修改JavaScript运行时功能(比如通过修改Object.prototype或者Function.prototype)来破坏你的程序这个事实无关。 相似的，和一些粗心的代码可能会意外地通过非标准的方式来修改标准JS函数无关。 最后，和如果你页面中依赖于第三方库那么他们的服务器，连接和代码也会出现上面所说的漏洞无关。 现在我可以继续了，但是我认为你已经找到关键点了。我们在通过一个假设来缩小我们的讨论范围：当所有的代码以及主机环境都在一种预期的安全的状态中时，你的程序会如何执行？这并不是说我们使用Promise所做的事情对上面这些问题没有帮助。这仅仅是由于这些问题在一个更高的层面上—这些问题远离了编写API和模式，这些问题留给专家来讨论。 在Promise状态下的可靠性我们看看下面这个例子：123456789var myPromise = &#123; state: &#123; status: 1, value: \"Hello World\" &#125;, then: function(success,failure) &#123; // implement something like a thenable's behavior &#125;&#125;; 我可以新建一个像这样的对象，然后在平时使用它并且说我在用promises。实际是，我可以再完善一下使它可以通过整个Promises/A+ 测试网站的测试。 但是我真的是使用了Promises吗？你如何回答这个问题比你意识到的更重要。在很多开发者社区中很多人的回答是，是的。我很确定的说，不是！为什么？如果你通过了promises测试网站，那么它就是一个promise 了，不是吗？而且，它在所有情况下都按照规范来执行，不是吗？ 不是promises的精髓远不是规范说的那么简单，是可靠性。可靠性是一个promise就是一个状态(状态会从”pending”转变成”resolved”或者”rejected”其中一个)的容器，这些状态会附带一个结果值(成功信息或者错误信息)。可靠性是一旦一个promise的状态变为”resolved”或者”rejected”，那么就不能改变也不会改变。可靠性就是完成的promise是不可变的。但是promises的精髓还有一些更深层次的东西，这些是无法通过阅读规范看出来的：改变一个promise状态和设置它的完成值的能力只存在于原始的promise的实现。也就是说这个能力的实现掌握在开发者手里。规范的早期版本中，把resolve/reject的功能分离出来放在一个对象中，叫做Deferred.把这想成一个对象对：在创建的时候，我们创建一个promise和一个deferred，deferred可以resolve这个promise。重要的是，这两个可以被分开，一部分代码可以resolve/reject一个promise而另外一部分只能监听这个变化然后做出回应。规范的后续版本中简化了promises，通过删除deferred对象，取而代之的是简单的暴露出原来属于deferred的resolve()和reject()方法。12345678var p = new Promise( function(resolve,reject)&#123; // I have `resolve()` and `reject()` from the // hidden `deferred`, and I **alone** control // the state of the promise.&#125; );// now, I can pass around `p` freely, and it can't// be changed by anyone else but the creator. 看看之前的那个myPromise对象。你注意到了什么吗？123456789var myPromise = &#123; state: &#123; status: 1, value: \"Hello World\" &#125;, then: function(success,failure) &#123; // implement something like a thenable's behavior &#125;&#125;; 如果你到处传递myPromise，然后不管恶意代码还是意外的代码都可以改变myPromise.state.status或者myPromise.state.value属性，我们是不是开了一个很大的后门，失去了Promises的可靠性。当然，答案是肯定的。把状态暴露给方法使得这不是一个真正的promise。因为现在promise的保证已经完全不可靠了。如果你从一个第三方库中得到了一个这样的对象，你不会信任它的，不是吗？更重要的，如果你把这个对象传递给其他第三方库，你肯定不会相信只有原始的创建者才能修改它，不是吗？当然不会相信。那就太天真了。你看，使用promises是基于可靠性的。然后可靠性是基于promise的状态是与外部影响隔离的，只有创建者能改变。注意到我并没有说状态必须是私有的，只要它不会被外界改变就可以。如果没有promise的对象不会被除了创建者改变的可靠性，那么promise就几乎失去了它的意义。 错误的可靠性？注意，这正是事情变得模糊的地方，是不可忽视的事实。大多数为了在旧的JS环境下能够支持promise的polyfill会把状态通过可变的方式暴露出来。Ouch!!!在这方面，我的ES6 Promise polyfill”Native Promise Only“没有把state暴露出来。据我所知，这是唯一一个没有把promise状态暴露出来的polyfill。为什么？因为我不仅仅关心Promise规范，我更在意Promises的精髓。 Tradeoffs但是究竟为什么所有这些高度可信的Promise polyfill和库会忘了promise中这么重要的东西呢？因为在原生Javascript有一些限制，这是一些内置机制不需要遵循的。简单的说，即将到来的ES6标准指出Promise是一个“class”，所以作为一个“class”，promise必须可以被子类化。换句话说，你必须可以创建一个class CustomPromise extends Promise{..}子类，在这个基础上你可以扩展内置promises的功能。例如，你需要一个自定义的promise，这个promise可以处理超过一条消息。至少理论上，实现这个只需要你继承内置Promise类然后扩展它。鉴于我对JS中类概念的偏见，我认为Promise子类化是一种没有意义的闹剧或者转移注意力的幌子。我努力让自己想出一些Promise子类化的好处，可是我实在想不出来。而且，如果要继续保持一些特性来遵循Promises/A+ Test Suite,这些子类的实现很可能变得相当笨拙。最后，我对于promise的子类化没有任何好感。 怎么办呢！？不涉及太多JS的细节，把Promise表达成一个可以被继承的”class”需要你把实例方法加入到Promise.prototype对象中。但是当你这么做的时候，你就把then..()和catch(..)变成共享方法，所有Promise实例都可以访问到，然后这些方法只能通过this访问每个实例上的公共属性。换句话说，如果要使得promise可以子类化，只使用简单的JS是不可能的，必须使用闭包或其他方法来为每个实例创建私有的promise状态。我知道现在你已经开始想各种你见过的可以实现闭包私有和this公共继承混合的方法。我可以写一整本书来说明为什么这样行不通，但是我这里就简单的说下：不要管你所听到的，只使用ES5中可以使用的方法，你是不可能创建私有状态同时又可以有效子类化的promise。这两个概念在ES5以下是互相排斥的。 Promise 削弱另一个ES6中的新特性是WeakMap。简单的说，一个WeakMap实例能够使用对象引用作为键，然后和一个数据相联系，而不需要真正把数据存储在对象上。这正是我们需要的，不是吗？我们需要一个我们公共的then(..)和catch(..)可以访问的WeakMap，无论this绑定的是什么，它们都可以根据this访问到并且查找对应的被保护的状态值。这个特权Promise方法可以取得这个内部状态，但是外部不能。不过，事情并没有这么美好： WeakMap根本不可能通过原生JS用性能可接受的方法实现。 就算我们在ES5及以下可以使用WeakMap，它还是没有完全解决子类化的问题，因为你必须隐藏WeakMap实例使得只有你的Promise方法可以访问，但是这样的话另一个Promise的子类也能访问到。假设我们可以解决第二个问题—其实我们不能，就做一个假设。那么WeakMap的实现应该是什么样的呢？123456789101112131415161718192021222324252627282930313233343536373839var WeakMap = function()&#123; var objs = [], data = []; function findObj(obj) &#123; for (var i=0; i&lt;objs.length; i++) &#123; if (objs[i] === obj) return i; &#125; // not found, add it onto the end objs.push( obj ); data.push( undefined ); return i; &#125; function __set(key,value) &#123; var idx = findObj( key ); data[idx] = value; &#125; function __get(key) &#123; var idx = findObj( key ); return data[idx]; &#125; return &#123; \"set\": __set, \"get\": __get &#125;;&#125;;var myMap = new WeakMap();var myObj = &#123;&#125;;myMap.set( myObj, \"foo\" );myObj.foo; // undefinedmyMap.get( myObj ); // \"foo\" OK，基本的思想就是我们维护两个数组(objs，data)，通过下标相对应。在第一个数组中保存对象引用，在另一个保存数据。漂亮，不是吗？看看性能怎么样吧。看看findObj(..)，它要循环整个数组来找到相应的数据。引用越多性能就越低。但是这还不是最坏的地方。WeakMap之所以叫做“Weak”是由于垃圾回收行为。在我们WeakMap的实现中，会保存每个对象的引用，这就意味着就算程序已经没有对于对象的引用了，这些对象还是不能被回收。但是真正的WeakMap就是这么“weak”，所以你不需要做任何事情来优化垃圾回收。好的，WeakMap是一个错误的希望。它并没有解决ES6中的问题并且使得事情在ES5及以下变得更糟。 保护state还是子类化？这是个问题！我真的希望我能创建一个忠实的Peomisepolyfill给ES5及以下。但是必须做一个选择，在这里出现了一个分歧。要不就放弃子类化的功能，要不就放弃作为promise的可靠性。那么我们该怎么做呢？ 总结我会做另一个promise polyfill，这个polyfill选择保留子类化的能力，以可变的state为代价。我已经选择了抛弃子类化使得我的promise polyfill可以很可靠。就像我之前说的，我认为promise的子类化最终会被证明是一个华而不实的东西。我不会牺牲promise的可靠性来顺从子类化。很显然，其他人对于这个问题会有不同的看法。但是我只想让你问问你自己：一个不可靠的promise可以用来干嘛？什么代码能真正拯救你？什么代码可以做得更好？现有的Promise polyfill和库的问题比不可变的state vs 子类化更深层面。在第四部分：扩展问题中，我会指出许多现有polyfill和库中的问题。 译者注这篇文章不大好翻译也不大好理解，所以在这里总结下我的理解，希望对大家的理解有所帮助，如果大家有什么不同的看法，欢迎讨论。这篇文章围绕Promise的可靠性展开，Promise的可靠性是它的精髓所在。要实现Promise的可靠性最关键的就是要保证Promise的状态值state不能被外部改变，这样才能保证状态值的不可逆。而现在几乎所有的Promise库都忽略了这个关键，而它们会忽略这个关键点一个很重要的原因就是在ES6的规范中，Promise被规定为一个类，也就是说Promise是可以被子类化的。然而在ES5及以下的规范中，在没有private关键字的情况下，是不可能实现可子类化同时又能保证Promise的状态值不会被外部改变（真的吗？我保持怀疑态度）。而在ES6中出现的新对象WeakMap确实给实现Promise带来了新的思路，可以在ES5及以下环境中实现WeakMap，利用它的特点可以实现符合要求的Promise。具体实现思路就是：定义一个全局私有的WeakMap，这个WeakMap只有公共的方法then()和catch()可以访问到，在这个WeakMap中以每个Promise实例的this作为键，状态值state作为值进行存储。这样在每个Promise实例中都可以通过自己的this对象查找自己的状态值，而不能查找到其他Promise实例的状态值，这样就实现了状态值的外部不可修改。但是WeakMap有一个很大的问题就是性能比较低并且不利于垃圾回收，所以这并不是一个理想的解决方案。综上两个原因就导致了现在大部分库暴露state状态值，它们为了实现子类化选择了暴露状态值，丢弃了Promise的精髓所在。而在作者看来子类化对于Promise的重要性远远比不上Promise的可靠性，所以它选择了放弃子类化而保证Promise的可靠性。事实确实是这样，如果不能保证Promise的可靠性，那么就会出现第一篇中出现的那个不可靠的情况，这样Promise除了改善了回调金字塔的问题，跟普通的回调也就没有什么区别了，也就失去了它更重要的意义。 原文地址：http://blog.getify.com/promises-part-3/ 深入理解Promise五部曲–1.异步问题深入理解Promise五部曲–2.转换问题深入理解Promise五部曲–3.可靠性问题深入理解Promise五部曲–4.扩展性问题深入理解Promise五部曲–5.乐高问题","categories":[],"tags":[{"name":"promise","slug":"promise","permalink":"/tags/promise/"}]},{"title":"(译)深入理解Promise五部曲：2.控制权转换问题","slug":"understand-promise-2","date":"2014-06-29T06:46:55.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/06/29/understand-promise-2/","link":"","permalink":"/2014/06/29/understand-promise-2/","excerpt":"厦门旅行归来，继续理解Promise 在上一篇深入理解Promise五部曲:1.异步问题中，我们揭示了JS的异步事件轮询并发模型并且解释了多任务是如何相互穿插使得它们看起来像是同时运行的。然后我们讨论了为什么我们努力地在我们的代码里表达这些东西以及为什么我们的大脑不善于理解它们。","text":"厦门旅行归来，继续理解Promise 在上一篇深入理解Promise五部曲:1.异步问题中，我们揭示了JS的异步事件轮询并发模型并且解释了多任务是如何相互穿插使得它们看起来像是同时运行的。然后我们讨论了为什么我们努力地在我们的代码里表达这些东西以及为什么我们的大脑不善于理解它们。我们现在要找出一个更好的方式来表达异步流程，然后看看Promises是怎么解决这个问题的。 回调嵌套JS从一开始就使用事件轮询的并发模型。我们一直以来都在写异步的程序。直到最近，我们仍然在用简单的回调函数来处理异步的问题。 123makeAjaxRequest(url,function(respnose)&#123; alert(\"Response:\" + response) ;&#125;) ; 当我们只有一个异步任务的时候使用回调函数看起来还不会有什么问题。但是，实际是我们完成一个任务通常需要多个异步操作。例如：1234567btn.addEventListener(\"click\",function(evt)&#123; makeAjaxRequest(url,function(response)&#123; makeAjaxRequest(anotherURL + \"?resp=\" + response,function(response2)&#123; alert(\"Response2:\" + response) ; &#125;) &#125;) ;&#125;,false) ; 把一系列异步操作链接在一起最自然的方式就是使用回调嵌套，步骤2嵌套在步骤1中然后步骤3嵌套在步骤2中，等等。 回调地狱你使用越多的回调，就会有越多的嵌套，不断缩进意大利面条似的代码。很显然，这种代码难以编写，难以理解而且难以维护。如果我们花点时间来理清这些代码往往会让我们事半功倍。这类嵌套/缩进经常被叫做”回调地狱”。有时也被叫做”回调金字塔”，专指由于代码不断缩进所形成的金字塔形状，缩进越多金字塔形状越明显。但是我还是觉得”回调地狱”真的跟嵌套和缩进扯不上太大的关系。如果之前有人跟你说回调地狱就是指嵌套和缩进的话，不要相信他，因为他们并不理解回调真正的问题在哪儿。 可靠性缺失回调(无论是否有嵌套)的真正问题是远比编辑器中的空白符严重。让我们来分析下下面这个简单的回调发生了什么12345//1.everything in my program before nowsomeAsyncThing(function()&#123; //2.everything in my program for later&#125;) ; 你看清这段代码说了什么吗？你从根本上把你的程序分成了两个部分： 直到现在为止发生的事情 以后会发生的事情 换句话说，你把第二部分代码包装在一个回调函数中然后延迟到后面执行。但是这并不是问题，真正问题是在1和2之间发生了什么。请问在这段时间内是谁在控制这些。someAsyncThing(..)控制着这些。是你自己拥有并管理someAsyncThing()吗？许多时候不是。更重要的是，你有多信任someAsyncThing(..)？你会问，信任什么？不管你意识到没有，你潜在的相信someAsyncThing(..)会做到下面这些： 不会太早调用我的回调函数 不会太迟调用我的回调函数(1,2就是说会在适当的时候调用回调函数) 不会调用我的回调太少次(不会少于实际应该调用的次数，比如不会漏掉函数调用) 不会调用我的回调太多次(不会多于实际应该调用的次数，比如重复调用) 会给我的回调提供必要的参数 在我的回调失败的时候会提醒我 咳！你也太信任它了！实际上，这里真正的问题是由于回调引起的控制转移。在你的程序的前半部分，你控制着程序的进程。现在你转移了控制权，someAsyncThing(..)控制了你剩余程序什么时候返回以及是否返回。控制转移表明了你的代码和其他人的代码之间的过度信任关系。 恐吓战术当someAsyncThing(..)是第三方库的一个方法并且你无法控制不能检查的时候会发生什么？只能祝你好运了！比如你有一个电子商务网站，用户就要完成付款的步骤了，但是在扣费之前有最后一个步骤，它需要通知一个第三方跟踪库。你调用他们API，并且提供一个回调函数。大部分情况下，这不会有什么问题。但是，在这次业务中，有一些你和他们都没有意识到的奇怪的Bug，结果就是第三方库在超时之前五秒的时间内每隔一秒就会调用一次回调函数。猜猜发生了什么？在这个回调里调用了chargeTheCreditCard()。Oops，消费者被扣了五次钱。为什么？因为你相信第三方库只会调用你的回调一次。所以你不得不被丢鸡蛋并且给消费者道歉归还多扣的四次钱。然后你立刻采取措施确保这种情况不会再发生。你会怎么做呢？你可能会创建一些状态值来跟踪你的回调，当它被调用一次之后会被标记，然后就可以忽略任何意外的重复调用。无论第三方如何道歉并且承诺他们的bug已经修复了，你再也不会相信他们了，不是吗？这看起来像一个愚蠢的场景，但是这可能比你想得还普遍。我们的程序变得越复杂，我们就会集成越多的第三方/外部代码，这种愚蠢的场景就越容易发生。 布基胶带你给你的回调加入了状态跟踪机制，然后睡了一个好觉。但是实际上你只是处理了信任列表许多项目中的一项。当另一个bug造成另一个可靠性丢失的情况时会发生什么？更多的改造，更多丑陋的代码。更多布基胶带。你必须不断修复回调中的漏洞。无论你是多优秀的开发者，无论你的布基胶带多漂亮，事实就是：在你信任墙上的回调充满了漏洞。 Promise解决方案一些人喜欢使用布基绷带并且给信任墙上的洞打补丁。但是在某些时候，你也许会问自己，是否有其他模式来表达异步流程控制，不需要忍受所有这些可靠性丢失？是的！Promises就是一个方法。在我解释它们是怎么工作之前，让我来解释一些它们背后的概念问题。 快餐业务你走进你最喜爱的快餐店，走到前台要了一些美味的食物。收银员告诉你一共7.53美元然后你把钱给她。她会给回你什么东西呢？如果你足够幸运，你要的食物已经准备好了。但是大多数情况下，你会拿到一个写着序列号的小票，是吧？所以你站到一边等待你的食物。很快，你听到广播响起：“请317号取餐”。正好是你的号码。你走到前台用小票换来你的食物！谢天谢地，你不用忍受太长的等待。刚才发生的是一个对于Promises很好的比喻。你走到前台开始一个业务，但是这个业务不能马上完成。所以，你得到一个在迟些时候完成业务(你的食物)的promise(小票)。一旦你的食物准备就绪，你会得到通知然后你第一时间用你的promise(小票)换来了你想要的东西：食物。换句话说，带有序列号的小票就是对于一个未来结果的承诺。 完成事件想想上面调用someAsyncThing(..)的例子。如果你可以调用它然后订阅一个事件，当这个调用完成的时候你会得到通知而不是传递一个回调给它，这样难道不会更好吗？例如，想象这样的代码：1234var listener = someAsyncThing(..) ;listener.on(\"completion\",function(data)&#123; //keep going now !&#125;) ; 实际上，如果我们还可以监听调用失败的事件那就更好了。123listener.on(\"failure\",function()&#123; //Oops,What's plan B?&#125;) ; 现在，对于我们调用的每个函数，我们能够在函数成功执行或者失败的时候得到通知。换句话说，每个函数调用会是流程控制图上的决策点。 Promise”事件”Promises就像是一个函数在说“我这有一个事件监听器，当我完成或者失败的时候会被通知到。”我们看看它是怎么工作的：123456789101112131415function someAsyncThing()&#123; var p = new Promise(function(resolve,reject)&#123; //at some later time,call 'resolve()' or 'reject()' &#125;) ; return p ;&#125;var p = someAsyncThing() ;p.then( function()&#123; //success happened &#125;, function()&#123; //failure happened &#125;) ; 你只需要监听then事件，然后通过知道哪个回调函数被调用就可以知道是成功还是失败。 逆转通过promises，我们重新获得了程序的控制权而不是通过给第三方库传递回调来转移控制权。这是javascript中异步控制流程表达上一个很大的进步。“等等”，你说。“我仍然要传递回调啊。有什么不一样？！”嗯。。。好眼力！有些人声称Promises通过移除回调来解决“回调地狱”的问题。并不是这样！在一些情况下，你甚至需要比以前更多的回调。同时，根据你如何编写你的代码，你可能仍然需要把promises嵌套在别的promises中！批判性地看，promises所做的只是改变了你传递回调的地方。本质上，如果你把你的回调传递给拥有良好保证和可预测性的中立Promises机制，你实质上重新获得了对于后续程序能很稳定并且运行良好的可靠性。标准的promises机制有以下这些保证： 如果promise被resolve，它要不是success就是failure，不可能同时存在。 一旦promise被resolve，它就再也不会被resolve(不会出现重复调用)。 如果promise返回了成功的信息，那么你绑定在成功事件上的回调会得到这个消息。 如果发生了错误，promise会收到一个带有错误信息的错误通知。 无论promise最后的结果是什么(success或者failure)，他就不会改变了，你总是可以获得这个消息只要你不销毁promise。 如果我们从someAsyncThing(..)得到的promise不是可用的标准的promise会发生什么？如果我们无法判断我们是否可相信它是真的promise会怎么样？简单！只要你得到的是“类promise”的，也就是拥有then(..)方法可以注册success和failure事件，那么你就可用使用这个“类promise”然后把它包装在一个你信任的promise中。12345678910111213var notSureWhatItIs = someAsyncThing();var p = Promise.resolve( notSureWhatItIs );// now we can trust `p`!!p.then( function()&#123; // success happened &#125;, function()&#123; // failure happened &#125;); promises的最重要的特点就是它把我们处理任何函数调用的成功或者失败的方式规范成了可预测的形式，特别是如果这个调用实际上的异步的。在这个规范过程中，它使我们的程序在可控制的位置而不是把控制权交给一个不可相信的第三方。 总结不要管你所听到的，“回调地狱”不是真的关于函数嵌套和它们在代码编辑器中产生的缩进。它是关于控制转移的，是指我们由于把控制权交给一个我们不能信任的第三方而产生的对我们的程序失去控制的现象。Promises逆转了这个情况，它使得我们重新获得控制权。相比传递回调给第三方函数，函数返回一个promise对象，我们可以使用它来监听函数的成功或失败。在promise我们仍然使用回调，但是重要的是标准的promise机制使我们可以信任它们行为的正确性。我们不需要想办法来处理这些可靠性问题。在第三部分：可靠性问题中，我会说道一个promises可靠性机制中很特别的部分：一个promise的状态必须是可靠并且不可变的。 深入理解Promise五部曲–1.异步问题深入理解Promise五部曲–2.转换问题深入理解Promise五部曲–3.可靠性问题深入理解Promise五部曲–4.扩展性问题深入理解Promise五部曲–5.乐高问题 原文地址：http://blog.getify.com/promises-part-2/","categories":[],"tags":[{"name":"promise","slug":"promise","permalink":"/tags/promise/"}]},{"title":"(译)深入理解Promise五部曲：1.异步问题","slug":"understand-promise-1","date":"2014-06-23T06:46:53.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/06/23/understand-promise-1/","link":"","permalink":"/2014/06/23/understand-promise-1/","excerpt":"在微博上看到有人分享LabJS作者写的关于Promise的博客，看了下觉得写得很好，分五个部分讲解了Promise的来龙去脉。从这篇文章开始，我会陆续把五篇博客翻译出来跟大家分享，在大牛的带领下真正理解Promise。卖个关子，作者看待Promise的角度跟我一直以来看到的讲解Promise的角度完全不一样，不只是定留在解决回调金字塔上，至少我没想到Promise竟然有这么重要的意义。先上第一篇。","text":"在微博上看到有人分享LabJS作者写的关于Promise的博客，看了下觉得写得很好，分五个部分讲解了Promise的来龙去脉。从这篇文章开始，我会陆续把五篇博客翻译出来跟大家分享，在大牛的带领下真正理解Promise。卖个关子，作者看待Promise的角度跟我一直以来看到的讲解Promise的角度完全不一样，不只是定留在解决回调金字塔上，至少我没想到Promise竟然有这么重要的意义。先上第一篇。在这篇文章中，我会解释我们为什么需要使用一个更好的方式(比如Promise)来进行异步流程的编写。 异步你肯定听说过Javascript中的异步编程，但是它到底是什么呢?比如当你发生一个Ajax请求，你通常会提供一个回调函数，这个回调函数会在请求返回的时候被调用。但是你是否思考过你的回调函数在其他代码也需要运行的时候是如何被调用的呢？如果两个回调函数同时都要运行会怎样呢？JS引擎会如何处理这个问题呢？为了理解异步到底是什么，你首先需要理解一个问题：JS引擎是单线程的。这意味着在任何环境中，只有一段JS代码会被执行。但是什么叫一段JS代码呢？总的来说，每个函数是一个不可分割的片段或者代码块。当JS引擎开始执行一个函数(比如回调函数)时，它就会把这个函数执行完，也就是说只有执行完这段代码才会继续执行后面的代码。换句话说，JS引擎就像一个主题公园中的游乐项目，这个项目每次只能一个人玩儿，人们会排成一个长长的队。大家一个个上去玩儿，下来一个然后再上去一个。如果你要玩儿这个项目你只能在队尾排队等待。幸运的是，每个人都很快就下来了，所以这个队伍移动得很快。上面说的队伍在技术上被叫做事件轮询。它尽可能快的进行轮询，如果事件队列中有代码需要执行，它会让JS引擎执行这段代码，然后移到下一个需要执行的代码，或者等待新的代码进来。 并发如果程序在一个时间只有一个任务在执行，这样明显是低效而且有限制性的。如果你点击一个按钮提交一个表单，然后你的鼠标就会被冻结并且你不能滚动页面，这个情况会持续几秒直到请求返回，这样肯定会带来很差的用户体验。这就是为什么真实的程序会有很多任务在运行而不是就只有一个任务，但是JS引擎是怎么在单线程的环境下实现的呢？你应该想到每个代码块运行只要很短的时间，通常不到1毫秒。你一眨眼的时间，JS引擎会执行上千百个这样的代码块。但是并不是所有的代码块都是为了执行同一个任务。比如，当你点击提交按钮之后，你也可以点击导航或者滚动页面等等。每个任务都会被分为很多个原子操作，执行这些原子操作会非常快。比如：Task A step1 step2 step3 step4 Task B step1 step2 JS引擎肯定不能在执行A:1步骤的同时执行B:1。但是Task B不需要等到Task A执行完后再执行，因为引擎可以在每个独立的原子操作之间快速的切换，可能是按下面的顺序执行的： A:1 B:1 A:2 B:2(Task B完成) A:3 A:4(Task A完成) 所以，事实上Task A和Task B是可以”同时”运行的，通过穿插地执行它们的每个原子操作，这叫做并发，换句话说，Task A和Task B是并发的。我们很容易就会把并发和并行弄混。在真正并行的系统中，你会有多个线程，可能一个线程执行Task A同时另一个线程执行Task B。这也意味着，A:1的运行不会阻塞B:1的运行。这就好像有主题公园中有两个分开的游乐项目，会有两队人在排队，它们互相不影响。JS事件轮询是一个简单的并发模型。它只允许把每个事件添加到事件队列的队尾，而这个队列是先进先出的。当条件允许时，回调函数就会被运行。 同步情况下的异步在JS中编写异步代码一个巧妙但是烦恼的问题是JS引擎实际执行代码的方式跟我们看上去不大一样。例如：123makeAjaxRequest(url,function(response)&#123; alert(\"Response:\" + response) ;&#125;) ; 你会怎么描述这段代码的流程呢？大多数开发者大概会这么说： 发送Ajax请求 等到请求完成的时候，弹出提示框但是这跟JS引擎实际的执行情况相比还不够准确。这个问题主要是因为我们大脑习惯同步的方式。在上面这个描述中，我们使用“等到。。。的时候”来解释，这就也是说我们会阻塞等待Ajax请求，然后继续执行后面的程序。JS在步骤1和步骤2之间不会阻塞。一个更准确的描述上面这段代码的方式是： 发送Ajax请求 注册回调函数 继续向下执行 在未来某个时间点，惊呼“Oh，我刚才得到一个返回！”。现在，返回去执行注册的那个回调函数。这两个解释的区别似乎没什么大不了的，但是我们跳过第三步的思考方式是一个大问题。源代码是给开发者的而不是计算机的。计算机只关心1和0.有无限种程序能产生一样的1和0序列。我们编写源代码为了使得我们能够以一种有含义并且准确的方式理解代码是干嘛的。由于我们的大脑很难处理异步，所以我们需要找出一种更加同步的方式来编写异步代码，隐藏具体的异步实现。例如，如果下面这段代码能像我们需要的那样运行并且不会阻塞，那么它是不是更好理解了呢？12response = makeAjaxRequest(url) ;alert(\"Response:\" + response) ; 如果我们可以像这样编码，那么我们就可以隐藏或者抽象makeAjaxRequest()的异步本质，不需要担心具体细节。换句话说，我们能使得异步代码只出现在具体的实现上，把这些烦人的东西埋在属于它的地方。 总结我们还没有解决问题。但是至少我们知道了问题是什么：用异步的方式来表达异步的代码是艰难的，甚至很难用我们的大脑来理解。我们需要的只是一种以同步的代码来尽可能隐藏具体的异步实现的方式，这样我们的大脑更好理解。我们的目标是以同步的方式来编码而不需要关系它的实现的同步还是异步。在第二部分:转换的问题中，我会着手处理“回调地狱”来解释这些问题，我们也将看到Promises是如何搞定它的 深入理解Promise五部曲–1.异步问题深入理解Promise五部曲–2.转换问题深入理解Promise五部曲–3.可靠性问题深入理解Promise五部曲–4.扩展性问题深入理解Promise五部曲–5.乐高问题 原文地址：http://blog.getify.com/promises-part-1/","categories":[],"tags":[{"name":"promise","slug":"promise","permalink":"/tags/promise/"}]},{"title":"前端优化-Javascript篇(4.DOM优化)","slug":"frontend-optimization-javascript-dom","date":"2014-06-16T06:44:11.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/06/16/frontend-optimization-javascript-dom/","link":"","permalink":"/2014/06/16/frontend-optimization-javascript-dom/","excerpt":"上篇我介绍了Javascript标识符查找方面的优化，可以看出在这方面的优化给性能带来的提升并不明显，甚至可以说基本没有影响。但是，我今天要分享的是前端Javascript优化的一个大头。众所周知，在浏览器端Javascript中DOM操作相比普通Javascript代码来说是比较耗时的，所以在DOM优化上下功夫可以收到相当可观的性能优化。下面我将分享几个DOM方面的性能优化策略。","text":"上篇我介绍了Javascript标识符查找方面的优化，可以看出在这方面的优化给性能带来的提升并不明显，甚至可以说基本没有影响。但是，我今天要分享的是前端Javascript优化的一个大头。众所周知，在浏览器端Javascript中DOM操作相比普通Javascript代码来说是比较耗时的，所以在DOM优化上下功夫可以收到相当可观的性能优化。下面我将分享几个DOM方面的性能优化策略。 耗时的DOM操作浏览器中的Javascript可以分为两个部分：ECMAScript和DOM API。而相比原生的ECMAScript来说，DOM API会耗时很多。我们可以把这两部分想象成两个通过桥梁连接的小岛，在ECMAScript小岛上进行的操作运行速度比在DOM小岛上面的操作要快很多，每次在进行DOM操作的时候你都需要从ECMAScript这个小岛通过这个桥梁到达DOM小岛上然后在上面进行耗时的操作。所以大量的DOM操作就会降低性能。大家先看看下面这个例子:1234567891011121314//优化前var start = new Date().getTime() ;for(var i = 0 ; i &lt; length ; i ++)&#123; document.getElementById(\"test\").innerHTML += \"a\" ;&#125;console.log(\"Before:\" + (new Date().getTime() - start)) ;//优化后start = new Date().getTime() ;var content = \"\" ;for(var i = 0 ; i &lt; length ; i ++)&#123; content += \"a\" ;&#125;document.getElementById(\"test\").innerHTML += content ;console.log(\"After:\" + (new Date().getTime() - start)) ; 从运行结果来看，可以说差距那是相当明显啊： 优化前的代码每一次循环都进行了DOM操作，而优化之后，只在最后一步进行了DOM操作，这就是DOM优化的力量啊。所以，我们应该在操作的时候尽量避免对DOM的操作，能少操作DOM就少操作。按照上面的比喻就好比是，我们通过桥梁从ECMAScript小岛到达DOM小岛，然后找出需要进行操作的元素，把它再带回到ECMAScript小岛进行操作，通过这个方式，可以加快操作的速度，我们应该尽可能多的把元素带回到ECMAScript小岛进行操作。 innerHTML还是createElement在页面上动态添加结点一般有两个方法:innerHTML和createElement方法。这两个方法在性能上也有一点差别，具体差别在哪儿呢？上代码:12345678910111213141516171819202122var start = new Date().getTime() ;var content = \"&lt;div&gt;\" ;for(var i = 0 ; i &lt; 1000 ; i ++)&#123; content += \"&lt;div&gt;&lt;/div&gt;\" ;&#125;content += \"&lt;/div&gt;\" ;document.getElementById(\"test\").innerHTML += content ;console.log(\"innerHTML:\" + (new Date().getTime() - start)) ;document.getElementById(\"test\").innerHTML = \"\" ;start = new Date().getTime() ;//为了避免直接往test节点上面添加节点引起的页面重画，所以使用一个div节点来存储添加的节点，最后把div添加到页面中var div = document.createElement(\"div\") ;for(var i = 0 ; i &lt; 1000 ; i ++)&#123; div.appendChild(document.createElement(\"div\")) ;&#125;document.getElementById(\"test\").appendChild(div) ;console.log(\"createElement:\" + (new Date().getTime() - start)) ; 这段代码在不同浏览器上的运行结果是不一样的： 在Chrome上createElement比innerHTML快，而在Firefoxhe和IE上结果则相反，从结果上看似乎是innerHTML以2:1赢了，可是我还是建议大家使用createElement，我把上面的代码改成下面这样：1234567891011121314151617var start = new Date().getTime() ;var test = document.getElementById(\"test\") ;for(var i = 0 ; i &lt; 1000 ; i ++)&#123; test.innerHTML += \"&lt;div&gt;&lt;/div&gt;\" ;&#125;console.log(\"innerHTML:\" + (new Date().getTime() - start)) ;document.getElementById(\"test\").innerHTML = \"\" ;start = new Date().getTime() ;for(var i = 0 ; i &lt; 1000 ; i ++)&#123; test.appendChild(document.createElement(\"div\")) ;&#125;console.log(\"createElement:\" + (new Date().getTime() - start)) ; 上面这段代码的运行结果 可以看出来innerHTML和createElement差很多。为了测试我用了比较大的数据1000，在实际开发中一般不会出现这种情况，所以性能上的差异也就不会那么明显，但是除了考虑性能问题以外，我们还应该考虑代码的可读性以及可维护下方面的问题，而考虑到这些的话，我个人还是比较推荐使用createElement，如果大家有什么别的看法，欢迎一起讨论。 HTMLCollectionHTMLCollection是若干个DOM节点的集合，它具有数组的一些特性，比如length属性、通过下标访问，但是它并不是数组，它没有push和slice方法。在DOM操作中我们经常会用到HTMLCollection，下面的方法都会返回HTMLCollection: getElementsByName getElementsByTagName getElementsByClassName document.forms document.images document.links 还有一些别的方法和属性会返回HTMLCollection，在这里就不一一列举了。如何处理它们也是影响性能的一个方面。优化策略跟上面的大同小异，就是用局部变量缓存集合以及集合的长度，我就不进行实际测试了。HTMLCollection还有一个很重要的特性就是它是根据页面的情况动态更新的，如果你更新的页面那么它的内容也会发生变化。比如下面这段代码：1234var divs = document.getElementsByTagName(\"div\") ;for(var i = 0 ; i &lt; divs.length ; i ++)&#123; document.body.appendChild(document.createElement(\"div\")) ;&#125; 这段代码的原意是向body中添加多一倍的div节点，但是真正的运行会导致死循环，这就是因为divs是动态更新的，每次向body中添加div节点都会使length属性发生变化也就是加1，所以这个循环会一直执行下去，在开发的时候应该注意这个问题。一个理想的办法就是缓存divs的长度，这样就不会引起死循环了。 节点筛选如果需要得到某个节点的所以孩子节点，我们可能会用到childNodes属性；得到第一个孩子，我们可能会用到firstChild；得到下一个兄弟节点，我们可能会用到nextSibling。但是这些属性都存在一些问题就是它们会把一些空格和空行也当作孩子节点返回给我们，而这些经常不是我们所想要的，如果使用这些属性那么我们就需要对它们进行筛选，这样势必会影响效率。所以我们应该用别的属性来替代这些，看下表: 表格左边的是推荐的属性，它们只会返回Element节点。不过并不是所有浏览器都支持，所以在使用之前我们需要先判断一下。 使用选择器方法替代传统方法现代浏览器给我们提供了另外一种方法在获取我们需要的节点，这个方法是querySelectorAll和querySelector。它们通过CSS选择器作为参数，返回满足条件的节点。querySelectorAll方法返回满足条件的所有节点而querySelector返回满足条件的第一个节点。使用这两个方法来替代我们以前经常用的getElementById，getElementsByTagName等方法也是提高性能的一个途径。不过还是老问题，并不是所有浏览器都支持这两个方法，所有还是先做个判断吧。 Reflow 和 Repaint首先，Repaint是指页面上的元素的外观发生了改变但是不影响布局的情况下引起的浏览器重新绘画元素外观的行为，比如修改color，background-color等属性。Reflow是指页面上的元素的大小布局发生的变化从而引起浏览器对页面其他元素位置大小进行重新计算并且布局的行为。Reflow所导致的性能消耗远比Repaint大，所以我们下面重点讨论Reflow情况下的优化策略。在讨论Reflow之前先简单的看一下浏览器加载页面的过程。如下图： 浏览器在收到HTML文档之后对其进行解析，解析过程分为两个部分DOM文档的解析和CSS样式的解析。解析DOM文档生成一个DOM树，DOM树和解析出来的CSS样式组合生成一个渲染树，最后浏览器根据这个渲染树进行页面的排版和绘画。而最后这一步就是会涉及到Reflow和Repaint。以下这几个行为会引起页面的Reflow或Repaint： 添加，删除，更新DOM节点 隐藏/显示DOM节点(display:none或visibility:hidden) 修改样式 改变窗口大小，滚动页面 其实浏览器在这方面已经帮我们做了一些优化了，对于每个触发Reflow的行为浏览器并不会马上就触发，而是把它们保存在一个队列中，当到达一定数量的时候再进行批量的Reflow，这样就不需要每次都进行Reflow。但是，我们的一些行为会影响到浏览器的优化，使得Reflow马上触发。当我们请求下面这些属性的时候发生这种现象： offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop/Left/Width/Height clientTop/Left/Width/Height getComputedStyle(), or currentStyle(IE) 每当我们请求这些属性时，浏览器为了返回实时的情况就必须马上进行Reflow以计算出我们所需要的属性。所以我们应该尽量少的使用这些属性。从上面可以发现，基于所有DOM操作都会引起Reflow或Repaint，所以尽可能避免页面的Reflow或Repaint可以很好的提高DOM性能。那么该怎么做才能最好的避免或最小化Reflow呢？下面有几个有用的建议：1.不要逐一修改样式，而改为通过修改className来批量改变样式，如果样式需要动态计算，那么也要使用cssText属性来批量添加样式。例如： 1234567891011// 错误的做法var left = 10, top = 10;el.style.left = left + \"px\";el.style.top = top + \"px\";// 使用修改className来进行优化el.className += \" theclassname\";// 如果需要动态修改css，那么就使用cssTextel.style.cssText += \"; left: \" + left + \"px; top: \" + top + \"px;\"; 2.批量处理DOM操作并且让元素脱离文档流，等操作结束后再放回文档流中。有以下几种办法： 使用display：none隐藏element，然后进行操作，最后再显示出来 使用documentFragment ，把新增的节点放在documentFragment中，最后再把documentFragment放到DOM中，因为把documentFragment放到DOM中，它只会把它的孩子节点放到DOM中，就好像documentFragment不存在。 通过cloneNode复制节点，然后离线进行操作，最后再替换DOM中的节点。 3.尽量少的访问会引起马上Reflow的属性，使用局部变量来缓存这些属性，比如：123456789var left = el.offsetLeft, top = el.offsetTop esty = el.style;for(big; loop; here) &#123; left += 10; top += 10; esty.left = left + \"px\"; esty.top = top + \"px\";&#125; 4.对于需要动画的元素，尽量让它脱离文档流，这样就能尽量引起尽量小的Reflow 5.尽量少使用table布局 事件代理事件代理我想这个大家应该都知道了。越多的事件绑定页面就加载越慢并且占用更多内存，同时绑定太多事件也会使得代码的可读性降低。使用事件代理的方法原理就是把事件绑定到元素的父节点，然后在处理函数中判断target，根据不同的target执行不同的逻辑。这样能很大程度的减少绑定是事件数量并且提高代码的简洁度。 总结看了这么多其实总结起来还是比较简单的，在进行DOM操作的时候尽量把DOM操作转换为本地的Javascript操作，使用时先缓存一些DOM元素或者属性，缓存长度。在需要进行大量DOM操作的时候，先让元素脱离文档，等操作结束再把元素放回文档中。优化策略还是需要在实践中不断尝试，不断摸索，找出最优的解决方案。 最近准备毕设没什么时间更新博客，后面尽量安排好时间做到一周一篇，前端优化Javascript篇未完待续。。。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"前端优化","slug":"前端优化","permalink":"/tags/前端优化/"}]},{"title":"前端优化-Javascript篇(3.标识符查找优化)","slug":"frontend-optimization-javascript-identifier","date":"2014-06-05T06:43:45.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/06/05/frontend-optimization-javascript-identifier/","link":"","permalink":"/2014/06/05/frontend-optimization-javascript-identifier/","excerpt":"前面两篇文章介绍了Javascript文件在页面中位置以及异步加载问题对前端性能的影响。不过受限于单线程的原因，不管采用哪种方法，只要Javascript进行了耗时的工作，就都会引起页面的阻塞。所以在写代码的过程中应该注意一些会影响代码性能的问题，这样才能让我们的优化尽量做到极致。下面我跟大家分享关于标识符查找方面的优化问题。","text":"前面两篇文章介绍了Javascript文件在页面中位置以及异步加载问题对前端性能的影响。不过受限于单线程的原因，不管采用哪种方法，只要Javascript进行了耗时的工作，就都会引起页面的阻塞。所以在写代码的过程中应该注意一些会影响代码性能的问题，这样才能让我们的优化尽量做到极致。下面我跟大家分享关于标识符查找方面的优化问题。 函数中变量的查找作用域链 每个函数都有一个[[Scope]]属性，指向函数的作用域链，作用域链由多个变量对象组成。这个作用域链在函数定义的时候被创建，在函数定义时，会创建一个变量对象，这个变量对象包括了函数包含块所能访问到的变量，其实就是函数包含块的执行上下文。这个变量对象会首先被放入作用域链中。1234function add(num1,num2)&#123; var sum = num1 + num2 ; return sum ;&#125; 在函数执行的时候，会创建一个叫做执行上下文的对象，这个执行上下文会用来进行函数的变量查找。执行上下文也有一个作用域链，这个作用域链就是用来进行变量查找的。当执行上下文创建时，它的作用域链会用函数的[[Scope]]属性来初始化。创建完执行上下文之后，又会创建一个叫做活动对象的变量对象并且放入作用域链的头部。这个活动对象包括所有局部变量，函数参数，arguments和this。这也说明了一个问题，就是this的值是在运行的时候决定的，而不是定义的时候。1var sum = add(1,2) ; 每次进行变量查找时，我们都要遍历执行上下文的作用域链，直到找到为止或者返回undefined。在这个过程中，变量查找的深度就会对性能产生影响。变量查找得越深，性能就越低。 由于现代浏览器对于JS的执行已经进行了优化，所以经过我的测试发现，变量查找的优化对于性能的提升不会产生太大的影响。虽然这么说，但是关于变量查找的优化方法还是可以借鉴的。 作用域扩大 对于正常的情况，函数执行上下文的作用域在函数执行的时候是不会发生变化的，但是有几个特例情况会使作用域发生变化，这种现象叫做动态作用域。 with with语句用来在特定作用域中引入变量对象，比如下面这段代码:12345function test()&#123; with(document)&#123; var link = getElementsByTagName(\"a\") ; &#125;&#125; 通过with语句，在with作用域内的代码都可以直接访问document中的属性和方法。这个方法虽然可以方便得访问属性，但是也带来了一些副作用。在使用with语句时，会向函数执行上下文的作用域链的头部插入一个变量对象，这个变量对象的值就是with中包含的对象，这就意味着原来在作用域中的变量对象都被往后移了一位，也就是说查找这些变量要遍历更深一层作用域链。所以我们应该尽量避免使用with语句，可以通过声明局部变量然后赋值为document的方式来取代with语句。 try catch try catch语句跟with一样，也会产生同样的影响，只是这次插入到作用域链中的变量对象是catch括号中的对象，一般就是错误对象e。 eval eval函数的坏处我想大家都应该知道了，通过eval执行的代码会污染全局变量,进而也会拉长变量的查找深度。 对象属性查找原型和原型链 每个对象都有一个指向原型prototype的属性__proto__，多个对象的继承就形成了原型链。下图是一个关于原型和原型链的图： 关于原型链的介绍网上已经有很多了，我这里就不做介绍了。Javascript中的继承是通过原型链实现的，这就会导致一个问题，就是经过多次继承之后，原型链会变得很长，然后对于对象属性的查找就需要遍历更长的原型链，而遍历的越深效率必然就会越低。这就是对象属性查找的时候需要优化的一个地方。 上图是一个book对象的原型继承图，很容易发现如果要访问title属性那么只要直接再book对象上查找就可以了，但是如果要访问toString方法的话，那么就需要遍历到原型链最深处，这样的话效率肯定更低。一个常用的优化的方法就是用局部变量来保存对象的属性，后面只要直接访问这个局部变量就可以了。这方法跟函数中变量查找是一个道理。 现代浏览器对于对象属性的查找同样进行了优化，所以通过测试性能方面也没有太大的差别。 总结 上面所说的是Javascript代码优化方面常见的两个问题，虽然现代浏览器对它们都进行了优化，但是如果要适配一些比较老旧的浏览器的话，还是需要注意的。而且上面说到的优化策略也是一个很好的编程规范。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"前端优化","slug":"前端优化","permalink":"/tags/前端优化/"}]},{"title":"前端优化-Javascript篇(2.异步加载脚本)","slug":"frontend-optimization-javascript-async-load","date":"2014-06-02T06:43:19.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/06/02/frontend-optimization-javascript-async-load/","link":"","permalink":"/2014/06/02/frontend-optimization-javascript-async-load/","excerpt":"上篇博客说过脚本后置可以使页面更快的加载，可是这样的优化还是有限的，如果脚本需要执行一个耗时的操作，就算后置了它还是会阻塞后续脚本加载和执行并且阻塞整个页面。下面介绍非阻塞加载脚本技术也就是异步加载。","text":"上篇博客说过脚本后置可以使页面更快的加载，可是这样的优化还是有限的，如果脚本需要执行一个耗时的操作，就算后置了它还是会阻塞后续脚本加载和执行并且阻塞整个页面。下面介绍非阻塞加载脚本技术也就是异步加载。 非阻塞加载脚本1.defer(关于defer的一篇好文) 目前所有浏览器都支持defer属性，但是Chrome和Firefox中只有在加载外部脚本时defer才会生效，行内脚本使用defer是没有作用的。而IE中不论什么情况，defer都有效。 defer的作用就是阻止脚本在下载完成后立刻执行，它会让脚本延迟到所有脚本加载执行完成后，在DOMContentLoaded之前执行，通俗的说就是顺序加载延迟执行。虽然都是在DOMContentLoaded之前执行，但是在不同浏览器之间，执行的各种脚本执行的顺序还是不一样的。看下面这个例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;html&gt; &lt;meta charset=\"utf-8\"&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt; var result = \"\" ; var head = document.getElementsByTagName(\"head\")[0] ; //DOMContentLoaded if(window.addEventListener)&#123; document.addEventListener(\"DOMContentLoaded\",function()&#123; result += \"DOMContentLoaded\\n\" ; &#125;) ; &#125;else&#123; document.attachEvent(\"onDOMContentLoaded\",function()&#123; result += \"DOMContentLoaded\\n\" ; &#125;) ; &#125; window.onload = function()&#123; result += \"window loaded\\n\"; //console.log(\"window loaded\") ; &#125; ; &lt;/script&gt; &lt;!--头部行内延迟脚本--&gt; &lt;script type=\"text/javascript\" defer = \"defer\"&gt; result += \"Head Inline Script defer\\n\" ; &lt;/script&gt; &lt;!--头部行内脚本--&gt; &lt;script type=\"text/javascript\"&gt; result += \"Head Inline Script\\n\" ; &lt;/script&gt; &lt;!--头部外部延迟脚本 External Head Script defer--&gt; &lt;script type=\"text/javascript\" src = \"external_head_defer.js\" defer=\"defer\"&gt;&lt;/script&gt; &lt;!--头部行内脚本 External Head Script--&gt; &lt;script type=\"text/javascript\" src = \"external_head.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;SHOW&lt;/button&gt; &lt;!--Body行内延迟脚本--&gt; &lt;script type=\"text/javascript\" defer = \"defer\"&gt; result += \"Body Inline Script defer\\n\" ; &lt;/script&gt; &lt;!--Body行内脚本--&gt; &lt;script type=\"text/javascript\"&gt; result += \"Body Inline Script\\n\" ; &lt;/script&gt; &lt;!--Body外部延迟脚本 External Body Script defer--&gt; &lt;script type=\"text/javascript\" defer = \"defer\" src = \"external_body_defer.js\"&gt;&lt;/script&gt; &lt;!--Body外部脚本 External Body Script--&gt; &lt;script type=\"text/javascript\" src = \"external_body.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; document.getElementsByTagName(\"button\")[0].onclick = function()&#123;console.log(result);&#125; ; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果如下：从上面可以看出几个问题： 首先，IE9以下不支持DOMContentLoaded(后面会说明这个情况) 其次，验证了上面说的Chrome和Firefox行内脚本不支持defer属性 最后，defer确实达到了延迟执行的目的，没有阻塞后面脚本的加载和执行。但是耗时的操作还是会阻塞DOMContentLoaded事件，而大多数情况下大家都会把页面初始化的脚本附加在DOMContentLoaded事件上，所以defer方法还是不能很好解决这个问题。 2.Script DOM 这是最常用也是现在普遍的解决方法。它只需要简单几句话就可以实现脚本的异步加载，并且所有浏览器都支持这个方法。但是在每个浏览器中，执行还是略有不同。看下面这个例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;html&gt; &lt;meta charset=\"utf-8\"&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt; var result = \"\\n\" ; var head = document.getElementsByTagName(\"head\")[0] ; //DOMContentLoaded if(window.addEventListener)&#123; document.addEventListener(\"DOMContentLoaded\",function()&#123; alert(\"DOMContentLoaded\") ; result += \"DOMContentLoaded\\n\" ; &#125;) ; &#125;else&#123; document.attachEvent(\"onDOMContentLoaded\",function()&#123; alert(\"DOMContentLoaded\") ; result += \"DOMContentLoaded\\n\" ; &#125;) ; &#125; window.onload = function()&#123; result += \"window loaded\\n\"; &#125; ; &lt;/script&gt; &lt;!--头部外部延迟脚本 External Head Script defer--&gt; &lt;script type=\"text/javascript\" src = \"external_head_defer.js\" defer=\"defer\"&gt;&lt;/script&gt; &lt;!--头部行内脚本 External Head Script--&gt; &lt;script type=\"text/javascript\" src = \"external_head.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;SHOW&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; document.getElementsByTagName(\"button\")[0].onclick = function()&#123;console.log(result);&#125; ; &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; result += \"start\\n\" ; var head = document.getElementsByTagName(\"head\")[0] ; var script8 = document.createElement(\"script\") ; script8.type = \"text/javascript\" ; script8.onload = function()&#123;alert(\"done\");&#125; ; script8.readystatechange = function()&#123; if(script8.readyState == \"loaded\" || script8.readyState == \"complete\")&#123; alert(\"done\") ; &#125; &#125; ; //Body Dynamic Script script8.src = \"dynamic_body.js\" ; head.appendChild(script8) ; result += \"end\\n\" ; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果如下: 下面这张图是在ScriptDom脚本后面加入一个耗时的脚本，使得这个脚本执行完成后，保证ScriptDOM的脚本处于可执行状态：1234567&lt;script type=\"text/javascript\"&gt; function doSomething(length)&#123; var start = new Date().getTime() ; while((new Date().getTime() - start) &lt; 1000 * length)&#123;&#125; &#125; doSomething(3) ;&lt;/script&gt; 结果如下：运行结果同时也说明了几个问题： 首先，ScriptDOM不会阻塞后续脚本的执行，根据start和end 的位置可以很容易看出。 其次，在第二张图的情况下，ScriptDOM和defer同时都可以执行，在不同浏览器中它们的优先级的不一样的。在Firfox和Chrome中，ScriptDOM的优先级比defer低，而在IE中情况则相反。 最后，通过两种情况的对比发现，在Chrome中ScriptDOM不会阻塞DOMContentLoaded事件但是会阻塞onload事件；在Firefox中ScriptDOM既会阻塞DOMContentLoaded事件也会阻塞onload事件；而在IE中，情况则要根据代码执行情况来决定。如果在DOMContentLoaded事件或者onload事件触发之前，ScriptDOM代码处于可执行状态，那么就会阻塞两个事件；如果在DOMContentLoaded事件或者onload事件触发之前，ScriptDOM代码处于不可执行状态，那么就不会阻塞两个事件。总结的来说就是在Chrome和IE中DOMContentLoaded事件不需要等待ScriptDOM执行，而在Firefox中需要等待ScriptDOM执行。 通过上面两种方法的对比发现，defer和ScriptDOM都不会阻塞后续脚本的执行。但是相对来说，ScriptDOM在使用上更加灵活而且并不总是阻塞DOMContentLoaded事件，并且ScriptDOM的使用场景主要是在按需加载和模块加载器上，而一般使用这些技术的时候，页面已经处于加载完成的状态，所以对于性能不会有影响。 DOMContentLoaded 上面说到DOMContentLoaded事件，DOMcontentLoaded是现代浏览器才支持的一个事件，万恶的IE从IE9开始才支持这个事件。那么在什么情况下才会触发DOMContentLoaded事件呢？DOMContentLoaded会在浏览器接收到服务器传过来的HTML文档，整个页面DOM结构加载完成并且所有行内脚本和外部脚本执行完成后触发 (通过上面异步脚本的例子可以看出，ScriptDOM异步加载脚本不会阻塞DOMContentLoaded，或者说DOMContentLoaded不需要等待ScriptDOM执行就可以出发) ，它跟onload事件的区别是，DOMContentLoaded事件不需要等待图片，ifram和样式表等资源加载完成就会触发，而onload事件需要等待整个页面都加载完成包括各种资源才会触发。所以对于我们来说DOMContentLoaded是一个更有用的事件，因为只要DOM结构加载完成，我们就可以通过Javasscript来操作页面上的DOM节点。 但是上面关于DOMContentLoaded事件触发条件的定义只是官方文档的说法，具体情况并不总是这样。 有时样式表的加载会阻塞脚本的执行从而阻塞DOMContentLoaded事件，这种情况一般出现在样式表后面跟着脚本。也就是说如果把脚本放在样式表后面，那么脚本就必须等到样式表加载完成才能开始执行，这样就会阻塞页面的DOMContentLoaded事件。但是这样做也是有道理的，因为有时候我们的脚本会处理DOM样式方面的东西。 这种阻塞情况在不同浏览器上表现也会不一样。在IE和Firefox中，不管样式表后面跟着是行内脚本还是外部脚本，都会发生阻塞。在Chrome中，只有外部脚本才会发生阻塞。 由于IE在IE9以下不支持DOMContentLoaded事件，所以我们需要用一些Hack技术来实现这个功能。分两种情况来实现： 1.网页不嵌套在iframe中 在IE中我们可以通过一个方式来判断DOM是否加载完成，就是doScroll方法。如果DOM加载完成，那么我们就可以调用document的doScroll方法，否则就会抛出异常。我们可以利用这个特性不断轮询来做Hack。123456789101112131415161718function bindReady(handle)&#123; //判断是否在iframe中 try&#123; var isFrame = window.frameElement != null ; &#125;catch(e)&#123;&#125; if(document.documentElement.doScroll &amp;&amp; !isFrame)&#123; //轮询是否可以调用doScroll方法 function tryScroll()&#123; try&#123; document.documentElement.doScroll(\"left\"); handle() ; &#125;catch(e)&#123; setTimeout(tryScroll,10) ; &#125; &#125; tryScroll() ; &#125;&#125; 2.网页嵌套在iframe中 如果网页嵌套在iframe中，那么是无法通过doScroll的方法来Hack实现DOMContentLoaded的。我们可以通过另外一种方式来实现—readystatechange，代码如下：1234567function bindReady(handle)&#123; document.onreadystatechange = function()&#123; if(document.readyState === \"complete\" || document.readyState === \"loaded\")&#123; handle() ; &#125; &#125;&#125; 结合上面的讨论，我们可以得出一个通用的bindReady方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//绑定DOMContentLoaded事件，支持绑定多个处理函数var handleList = [] ;function onReady(handle)&#123; //按顺序执行处理函数 var doHandles = function()&#123; var length = handleList.length ; for(var i = 0 ; i &lt; length ; i ++)&#123; handleList[i]() ; &#125; &#125; if(handleList.length == 0)&#123; //在还没有处理函数时，把doHandles注册到ready上，这样后面加入的处理函数就可以一并执行 bindReady(doHandles) ; &#125; //把处理函数加入到函数列表中 handleList.push(handle) ;&#125;function bindReady(handle)&#123; var called = false ; var ready = function()&#123; //防止重复调用 if(!called)&#123; called = true ; handle() ; &#125; &#125; if(document.addEventListener)&#123; //支持DOMcontentLoaded document.addEventListener(\"DOMContentLoaded\",ready,false); &#125;else if(document.attachEvent)&#123; //IE try&#123; var isFrame = window.frameElement != null ; &#125;catch(e)&#123;&#125; //网页不在iframe中 if(document.documentElement.doScroll &amp;&amp; !isFrame)&#123; function tryScroll()&#123; try&#123; document.documentElement.doScroll(\"left\") ; ready() ; &#125;catch(e)&#123; setTimeout(tryScroll,10) ; &#125; &#125; tryScroll() ; &#125;else&#123; //网页在iframe中 document.onreadystatechange = function()&#123; if(document.readyState === \"complete\" || document.readyState === \"loaded\")&#123; ready() ; &#125; &#125; &#125; &#125; //老式浏览器不支持上面两种事件 if(window.addEventListener)&#123; window.addEventListener(\"load\",ready,false) ; &#125;else if(window.attachEvent)&#123; window.attachEvent(\"onload\",ready) ; &#125;else&#123; //允许绑定多个处理函数 var fn = window.onload ; window.onload = function()&#123; fn &amp;&amp; fn() ; ready() ; &#125; &#125;&#125; 说在最后 说了这么多，虽然通过脚本后置和异步加载可以降低脚本加载对页面的影响，但是就算是实现了异步加载，但是由于浏览器的脚本解析的单线程的，所以脚本执行的时候仍然会阻塞整个页面(当然除了使用Web Worker)，这时候用户是无法完成正常交互的，所以要想真正彻底的优化页面加载，还需要从代码的优化开始。从下一篇开始，我会分享关于这方面的学习。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"前端优化","slug":"前端优化","permalink":"/tags/前端优化/"}]},{"title":"前端优化-Javascript篇(1.脚本放在底部)","slug":"frontend-optimization-javascript-bottom","date":"2014-05-24T06:42:52.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/05/24/frontend-optimization-javascript-bottom/","link":"","permalink":"/2014/05/24/frontend-optimization-javascript-bottom/","excerpt":"从本篇博客开始，我会跟大家分享下我关于前端优化方面的学习，由于时间原因每篇博客只能分享一小点内容，一点点深入前端优化的细节。 做过前端的人都知道，前端优化是一个永远都不会停止的话题(当然，不管是哪个技术，优化总是无止境的)。在前端优化这个问题上，最被大家熟知的应该就是雅虎前端优化14条军规以及雅虎前端优化34条规则。大部分也都已经应用到了实际开发中。而我的分享并不是按照优化建议来进行的，我的计划是整个优化按照不同模块进行划分，分别是Javascript，CSS，HTML还有其他的一些细节。今天就先从Javascript开始。","text":"从本篇博客开始，我会跟大家分享下我关于前端优化方面的学习，由于时间原因每篇博客只能分享一小点内容，一点点深入前端优化的细节。 做过前端的人都知道，前端优化是一个永远都不会停止的话题(当然，不管是哪个技术，优化总是无止境的)。在前端优化这个问题上，最被大家熟知的应该就是雅虎前端优化14条军规以及雅虎前端优化34条规则。大部分也都已经应用到了实际开发中。而我的分享并不是按照优化建议来进行的，我的计划是整个优化按照不同模块进行划分，分别是Javascript，CSS，HTML还有其他的一些细节。今天就先从Javascript开始。 Javascript开篇就跟大家分享一个比较简单的规则————脚本后置，这个是一个最基本的优化策略，我想大家都应该知道，可是我还是想通过实际的例子来加深一下自己的理解，也许在这个简单的事情后面可以挖掘出更多有意思的东西。 为了验证脚本后置对前端优化究竟会有多大的影响，我把我的博客作为测试对象，在首页插入下面这个脚本:1234567function doSomething(n)&#123; //模拟一个需要执行n秒的脚本 var start = new Date().getTime() ; while((new Date().getTime() - start) &lt; 1000 * n)&#123;&#125;&#125;//执行5秒doSomething(5) ; 我把这个脚本命名为doSomething.js 首先，先来看看脚本前置的情况，下图是脚本前置情况下的网络瀑布图 其次，再来看看脚本后置的情况，下图是脚本后置情况下的网络瀑布图 通过上面两幅图，结果已经很明显了，虽然现代浏览器已经支持资源的并行下载，但是当脚本阻塞时仍然会阻止其他图片资源和页面的加载，如果站点是一个有很多图片的网站那么这种情况将严重影响用户体验；而脚本后置的话，图片和脚本是并行下载，然后先加载图片和页面然后才执行耗时的脚本，这样就不会阻塞图片和页面的加载。 从上面的瀑布图我们还可以看出很多浏览器加载策略方面的东西，通过对比不同浏览器的瀑布图也可以看出各自的加载策略，这方面的知识还需要在摸索，也希望有了解的人来说说不同浏览器之间加载策略的不同。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"前端优化","slug":"前端优化","permalink":"/tags/前端优化/"}]},{"title":"Hexo搭建个人博客","slug":"build-blog-with-hexo","date":"2014-05-24T06:38:03.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/05/24/build-blog-with-hexo/","link":"","permalink":"/2014/05/24/build-blog-with-hexo/","excerpt":"一直想搭建一个自己的博客来记录自己的一些学习笔记，由于是学生党经济上有些吃紧所以一直没办法搭建起自己的博客。最近在网上无意中看到了可以借助GitHub来搭建自己的个人博客，于是就折腾了起来。我搭建博客用到的是GitHub+Hexo的搭配，下面就让我来介绍下我的博客搭建的整个过程。","text":"一直想搭建一个自己的博客来记录自己的一些学习笔记，由于是学生党经济上有些吃紧所以一直没办法搭建起自己的博客。最近在网上无意中看到了可以借助GitHub来搭建自己的个人博客，于是就折腾了起来。我搭建博客用到的是GitHub+Hexo的搭配，下面就让我来介绍下我的博客搭建的整个过程。 Hexo Hexo是一个基于Node.js的快速简单的静态博客框架，利用它通过简单的几个命令就可以搭建一个个人博客。 A fast, simple &amp; powerful blog framework,powered by Node.js. 安装Hexo 我是在Windows上面进行搭建的，所以我这里就介绍下Windows上面的安装方法。安装Hexo首先需要下面两个条件: - Node.js - Git 这两个的安装方法大家Google下就好了，一堆堆的。有了这些我们就可以利用npm命令来安装hexo了。1npm install hexo -g 安装完hexo之后可以开始初始化博客了。 初始化博客 初始化Hexo博客只需要进入博客目录，然后执行下面这条命令就可以了1hexo init 生成博客 初始化博客之后博客目录下会产生一些配置文件和模板文件，现在就要利用这些模板文件来生成我们的静态博客文件，通过下面这条命令就可以生成我们的博客1hexo generate 执行完命令之后，在博客目录下会产生一个public文件夹，这里面存放的就是我们的博客静态文件。 本地部署 生成博客之后我们就可以开始在本地部署我们的博客1hexo server 现在我们打开浏览器访问http://localhost:4000 就可以看到我们的博客了。 部署到GitHub 通过上面这些步骤我们只是在本地搭建起了博客，要让别人看到还需要把它部署到GitHub上。 首先，当然是需要申请一个GitHub账号，然后新建一个Repository，接着在命名的时候需要注意，GitHubPage的名字必须用户名.github.com或者用户名.github.io。 创建完Repository之后，我们要配置Hexo的github地址然后才可以把我们的博客部署到GitHub上面。在博客目录底下打开_congig.yml，这就是Hexo的配置文件。找到下面这段代码1234# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy:type: 把上面的内容替换成你刚才创建的Repository地址，如下:123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy:type: githubrepository: https://github.com/用户名/用户名.github.io.gitbranch: master 创建Repository并且修改配置文件之后我们就可以把我们的博客部署到GitHub上面了，通过下面这个命令，过程中需要输入Git账号和密码:1hexo deploy 打开浏览器访问http://用户名.github.com 或者 http://用户名.github.io ，部署之后大约十分钟就可以看到博客效果了。 配置博客 通过上面的步骤我们完成了博客的基本搭建工作，我们还可以通过修改配置文件来进行博客的个性化定制。 首先是博客的标题以及作者，通过修改_congig.yml中相应的字段就可以设置标题和作者，如下: 1234567# Sitetitle: &lt;h1&gt;My Coding Life&lt;/h1&gt; //标题subtitle: Better Wife , Better Life //副标题description: Better Wife , Better Life //描述内容author: Bin //作者email: lakb248@163.com //邮箱language: zh-CN //语言 其次是博客的主题，Hexo有许多现成的主题可以选择，在这里可以得到。下载相应的主题放到博客目录底下的themes文件夹底下。最后需要修改_config.yml中theme字段的值，如下:1234# Extensions## Plugins: https://github.com/tommy351/hexo/wiki/Plugins## Themes: https://github.com/tommy351/hexo/wiki/Themestheme: 主题名 通过上面这一系列步骤，我们的个人博客可以正式上线了。Hexo还有很多其他的功能，比如评论，RSS。更多内容大家请看官方文档。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"}]},{"title":"Markdown初探","slug":"overview-of-markdown","date":"2014-05-24T06:34:25.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/05/24/overview-of-markdown/","link":"","permalink":"/2014/05/24/overview-of-markdown/","excerpt":"听说Markdown是在很早以前了，可是一直不知道这是用来干嘛的。这次由于使用Hexo搭建了博客需要使用Markdown来写博客，专门了解了一下。","text":"听说Markdown是在很早以前了，可是一直不知道这是用来干嘛的。这次由于使用Hexo搭建了博客需要使用Markdown来写博客，专门了解了一下。 何为Markdown 下面是Markdown的官网解释 Markdown is a text-to-HTML conversion tool for web writers. Markdown allows you to write using an easy-to-read, easy-to-write plain text format, then convert it to structurally valid XHTML. 大致意思就是说Markdown是一个把文本转换成html的工具，它可以让我们用易于读写的文本格式在写作，然后转换为格式化的XHML。按我自己的理解，Markdown就是一种标签语言，和HTML一样，它可以用简单的符号来表示不同的文本格式，最后显示成HTML。它最大的特点就是易于读写，不管你是否了解编程，都可以用Markdown来写作。 基本语法 下面这段文本涵盖了Markdown一些比较常用比较基本的语法，看完大家也就会对Markdown的语法有大致的了解。 1234567891011121314151617181920212223242526272829303132333435363738# 一级标题## 二级标题### 三级标题以此类推最多可以有六级标题在文本两边加上*号表示 *斜体*在文本两边加上两个*号表示 **粗体**在文本两边加上三个* 号表示 ***粗体并且斜体***一个空行表示一个段落*/-/+号后面加个空格表示无序列表* 列表1- 列表2+ 列表3数字点后面加上空格表示有序列表1. 有序列表12. 有序列表2&gt;加空格表示引用&gt;引用内容一个Tab代表代码块代码块可是代码块更适合用三个`包含来实现链接用[]包含然后跟上()括号中写上链接地址[链接](http://lakb248.github.io) 一级标题二级标题三级标题以此类推最多可以有六级标题 在文本两边加上 号表示 斜体* 在文本两边加上两个 号表示 *粗体 在文本两边加上三个 号表示 **粗体并且斜体*，注意星号和文本之间没有空格 一个空行表示一个段落 */-/+号后面加个空格表示无序列表 列表1 列表2 列表3 阿拉伯数字点后面加上空格表示有序列表 有序列表1 有序列表2 有序列表3 &gt;加空格表示引用 引用内容 一个Tab代表代码块 代码块 可是代码块更适合用三个`包含来实现 123var javascript = function()&#123; for(var i = 0 ; i &lt; length ; i ++)&#123;&#125;&#125; 链接用[]包含然后跟上()括号中写上链接地址链接 基本的语法就是上面这些，更多的语法请看这里。当然要熟练这些语法还是需要自己通过不断的使用来达到。","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"/tags/markdown/"}]},{"title":"(译)ECMAScript 6 特性速览","slug":"overview-of-es6","date":"2014-05-24T01:50:00.000Z","updated":"2016-09-06T14:46:02.000Z","comments":true,"path":"2014/05/24/overview-of-es6/","link":"","permalink":"/2014/05/24/overview-of-es6/","excerpt":"原文地址:http://www.frontendjournal.com/javascript-es6-learn-important-features-in-a-few-minutes/ 下一个Javascript版本，也就是ECMAScript 6(ES6或者Harmony)，给我们带来了很多令人兴奋的特性。下面我们来快速看看这些特性。下面列出的这些特性是我觉得很可能会在你日常工作中用到的。 如果你是一个Javascript新手或者原来是做服务器端开发的，那么你也不必担心，我相信现在是学习Javascript的最好时机，因为ES6有很多简介并且友好的特性。","text":"原文地址:http://www.frontendjournal.com/javascript-es6-learn-important-features-in-a-few-minutes/ 下一个Javascript版本，也就是ECMAScript 6(ES6或者Harmony)，给我们带来了很多令人兴奋的特性。下面我们来快速看看这些特性。下面列出的这些特性是我觉得很可能会在你日常工作中用到的。 如果你是一个Javascript新手或者原来是做服务器端开发的，那么你也不必担心，我相信现在是学习Javascript的最好时机，因为ES6有很多简介并且友好的特性。 类 总所周知，Javascript不像其他面向对象语言那样支持类，但是Javascript可以通过函数和原型来模拟类。 下面是一个创建类的新语法。如果你学习过Java或者其他面向对象语言的话，你会觉得很熟悉。123456789101112class Project &#123; constructor(name) &#123; this.name = name; &#125; start() &#123; return \"Project \" + this.name + \" starting\"; &#125;&#125;var project = new Project(\"Journal\"); project.start(); // \"Project Journal starting\" 所有你在类里面声明的方法都会添加到类的原型中。 ES6和原型中的继承 正如前面说的，Javascript不支持类。所以，既然它不支持类，那么它支持继承吗？ 的确，Javascript中的继承大部分是通过原型实现。如果你对原型不熟悉，那么一个好消息就是在ES6中你没必要了解原型就可以使用类和继承。原型并不难学习但是在这里你只要知道原型是javascript中实现继承的一种方式就可以了。 下面我创建了一个Project的子类，命名为WebProject并且继承Project中的属性和方法123456789101112131415161718class WebProject extends Project &#123; constructor(name, technologies) &#123; super(name); this.technologies = technologies; &#125; info() &#123; return this.name + \" uses \" + arrayToString(this.technology); &#125;&#125;function arrayToString(param) &#123; // ... some implementation&#125;var webJournal = new WebProject(\"FrontEnd Journal\", \"javascript\"); webJournal.start(); // \"FrontEnd Journal starting\" webJournal.info(); // \"FrontEnd Journal uses javascript\" 注意到在WebProject的构造函数中调用了Project的构造函数，然后就可以使用它的属性和方法了。 模块 如果你不想把你的JS代码都放在一个文件中或者你想在你的应用中的其他部分重用一些功能，那么你就很可能要用到模块。你需要记住的一个变量是export，只要在你要暴露出来的方法前面加上export就可以了。 下面是我们应用的结构。Project类和WebProject类被放在application.js中。1234567myproject (folder) | -- modules (folder) | | | -- helpers.js | -- application.js 让我们把arrayToString()方法从application.js中分离出来然后放在modules/helpers.js模块中，这样我们就可以在其他地方重用它了。1234// modules/helper.jsexport function arrayToString(param) &#123; // some implementation&#125; 现在我们只需要在application.js中导入我们的模块就可以了。123456789101112131415// application.jsimport &#123; arrayToString &#125; from 'modules/helpers';class WebProject extends Project &#123; constructor(name, technologies) &#123; super(name); this.technologies = technology; &#125; info() &#123; return this.name + \" uses \" + arrayToString(this.technology); &#125;&#125;// ... ES6的其他特性 下面两个ES6中的特性就比较有趣了。let和const。 let 为了理解let，首先我们需要记住var创建的是函数作用域的变量:123456function printName() &#123; if(true) &#123; var name = \"Rafael\"; &#125; console.log(name); // Rafael&#125; 注意到，不像Java或者许多其他语言那样，Javascript中任何在一个函数内部创建的变量都会被提升到函数的顶部。这就意味着无论你在哪里声明的变量，效果就像都是在函数顶部声明的一样。这种行为就叫做提升 所以上面的函数可以理解成下面这样：1234567function printName() &#123; var name; // variable declaration is hoisted to the top if(true) &#123; name = \"Rafael\"; &#125; console.log(name); // Rafael&#125; 那么，let是如何工作的呢？ 我们用同样的例子来看看:123456function printName() &#123; if(true) &#123; let name = \"Rafael\"; &#125; console.log(name); // ReferenceError: name is not defined&#125; 由于let是在块内部，所以name变量只能在块中访问。12345678function printName() &#123; var name = \"Hey\"; if(true) &#123; let name = \"Rafael\"; console.log(name); // Rafael &#125; console.log(name); // Hey&#125; 在这个例子中，由于let引用了已经声明的变量，所以”Rafael”只在块内部合法。在块的外部name的值是”Hey”。 总之，var是函数作用域的而let是块级作用域的。 const Javascript在过去很长一段时间都不支持创建常量。随着ES6的到来，你将可以创建常量并且保证它的值不会被改变。 创建常量的语法如下:1const SERVER_URL = \"http://frontendjournal.com\" 其他有趣的特性 ECMAScript 6 同时还带来了很多其他特性:Map，WeakMap，Generators和Proxies。 什么时候可以开始使用ES6？ Firefoxs是支持最多特性的浏览器而Juriy Zaytsev已经把主要浏览器的支持列出来了。 http://kangax.github.com/es5-compat-table/es6/ 一些ES6特性在NodeJS中也可以使用。可以查看Alex Young的博客ES6 for Node。 结论 下一个版本的Javascript会带来一个更加简单更加友好的语法来帮助那些从面向对象语言转过来的开发者的学习。现在的唯一的问题就是主要浏览器对ES6的全面支持还需要一些时间。 译者注: 目前对ECMAScript 6支持比较好的两个浏览器就是Chrome和Firefox，为了更好地体验ES6，我们需要下载开发者版本的浏览器，Chrome Canary 下载地址，Firefox Aurora 下载地址。 要在Firfox中开启ECMAScript 6，需要把&lt;script type= &quot;text/javascript&quot;&gt;标签改为&lt;script type=&quot;applicationjavascript;version=1.8&quot;&gt;。1.8是Firefox现在支持的版本最高的javascript。 在Chrome中开启ECMAScript 6，只需要使用严格模式就可以了，也就是在脚本前面加上&quot;use strict&quot;。不过在这之前还需要在地址栏中输入chrome://flags/，然后启用实验性 JavaScript。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"/tags/es6/"}]}]}