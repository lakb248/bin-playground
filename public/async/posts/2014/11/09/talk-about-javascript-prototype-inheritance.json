{"tags":[{"name":"javascript","permalink":"/tags/javascript/","url":"/async/tags/javascript.json","count":8}],"categories":[],"url":"/async/posts/2014/11/09/talk-about-javascript-prototype-inheritance.json","date":1415515550000,"path":{"year":2014,"month":11,"day":9,"name":"talk-about-javascript-prototype-inheritance"},"title":"再谈Javascript原型继承","permalink":"/2014/11/09/talk-about-javascript-prototype-inheritance/","content":"<p>真正意义上来说Javascript并不是一门面向对象的语言，没有提供传统的继承方式，但是它提供了一种原型继承的方式，利用自身提供的原型属性来实现继承。Javascript原型继承是一个被说烂掉了的话题，但是自己对于这个问题一直没有彻底理解，今天花了点时间又看了一遍《Javascript模式》中关于原型实现继承的几种方法，下面来一一说明下，在最后我根据自己的理解提出了一个关于继承比较完整的实现，如果大家有不同意见，欢迎建议。<br><a id=\"more\"></a></p>\n<h2 id=\"原型与原型链\"><a href=\"#原型与原型链\" class=\"headerlink\" title=\"原型与原型链\"></a>原型与原型链</h2><p>说原型继承之前还是要先说说原型和原型链，毕竟这是实现原型继承的基础。<br>在Javascript中，每个函数都有一个原型属性<code>prototype</code>指向自身的原型，而由这个函数创建的对象也有一个<code>__proto__</code>属性指向这个原型，而函数的原型是一个对象，所以这个对象也会有一个<code>__proto</code>__指向自己的原型，这样逐层深入直到<code>Object</code>对象的原型，这样就形成了原型链。下面这张图很好的解释了Javascript中的原型和原型链的关系。<br><img src=\"https://segmentfault.com/img/bVco7f\" alt=\"图片描述\"></p>\n<p>每个函数都是Function函数创建的对象，所以每个函数也有一个<code>__proto__</code>属性指向Function函数的原型。这里需要指出的是，真正形成原型链的是每个对象的<code>__proto__</code>属性，而不是函数的<code>prototype</code>属性，这是很重要的。</p>\n<h2 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h2><h3 id=\"基本模式\"><a href=\"#基本模式\" class=\"headerlink\" title=\"基本模式\"></a>基本模式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'parent'</span> ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.obj = &#123;a : <span class=\"number\">1</span>&#125; ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Child = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'child'</span> ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent() ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent() ;</div><div class=\"line\"><span class=\"keyword\">var</span> child = <span class=\"keyword\">new</span> Child() ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(parent.getName()) ; <span class=\"comment\">//parent</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(child.getName()) ; <span class=\"comment\">//child</span></div></pre></td></tr></table></figure>\n<p>这种是最简单实现原型继承的方法，直接把父类的对象赋值给子类构造函数的原型，这样子类的对象就可以访问到父类以及父类构造函数的<code>prototype</code>中的属性。 这种方法的原型继承图如下：<br><img src=\"https://segmentfault.com/img/bVdnzS\" alt=\"图片描述\"></p>\n<p>这种方法的优点很明显，实现十分简单，不需要任何特殊的操作；同时缺点也很明显，如果子类需要做跟父类构造函数中相同的初始化动作，那么就得在子类构造函数中再重复一遍父类中的操作：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'parent'</span> ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.obj = &#123;a : <span class=\"number\">1</span>&#125; ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Child = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'child'</span> ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent() ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent(<span class=\"string\">'myParent'</span>) ;</div><div class=\"line\"><span class=\"keyword\">var</span> child = <span class=\"keyword\">new</span> Child(<span class=\"string\">'myChild'</span>) ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(parent.getName()) ; <span class=\"comment\">//myParent</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(child.getName()) ; <span class=\"comment\">//myChild</span></div></pre></td></tr></table></figure></p>\n<p>上面这种情况还只是需要初始化<code>name</code>属性，如果初始化工作不断增加，这种方式是很不方便的。因此就有了下面一种改进的方式。</p>\n<h3 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'parent'</span> ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.obj = &#123;a : <span class=\"number\">1</span>&#125; ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Child = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  Parent.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>) ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent() ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent(<span class=\"string\">'myParent'</span>) ;</div><div class=\"line\"><span class=\"keyword\">var</span> child = <span class=\"keyword\">new</span> Child(<span class=\"string\">'myChild'</span>) ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(parent.getName()) ; <span class=\"comment\">//myParent</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(child.getName()) ; <span class=\"comment\">//myChild</span></div></pre></td></tr></table></figure>\n<p>上面这种方法在子类构造函数中通过<code>apply</code>调用父类的构造函数来进行相同的初始化工作，这样不管父类中做了多少初始化工作，子类也可以执行同样的初始化工作。但是上面这种实现还存在一个问题，父类构造函数被执行了两次，一次是在子类构造函数中，一次在赋值子类原型时，这是很多余的，所以我们还需要做一个改进：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'parent'</span> ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.obj = &#123;a : <span class=\"number\">1</span>&#125; ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Child = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  Parent.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>) ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Child.prototype = Parent.prototype ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent(<span class=\"string\">'myParent'</span>) ;</div><div class=\"line\"><span class=\"keyword\">var</span> child = <span class=\"keyword\">new</span> Child(<span class=\"string\">'myChild'</span>) ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(parent.getName()) ; <span class=\"comment\">//myParent</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(child.getName()) ; <span class=\"comment\">//myChild</span></div></pre></td></tr></table></figure></p>\n<p>这样我们就只需要在子类构造函数中执行一次父类的构造函数，同时又可以继承父类原型中的属性，这也比较符合原型的初衷，就是把需要复用的内容放在原型中，我们也只是继承了原型中可复用的内容。上面这种方式的原型图如下：<br><img src=\"https://segmentfault.com/img/bVdnzU\" alt=\"图片描述\"></p>\n<h3 id=\"临时构造函数模式-圣杯模式\"><a href=\"#临时构造函数模式-圣杯模式\" class=\"headerlink\" title=\"临时构造函数模式(圣杯模式)\"></a>临时构造函数模式(圣杯模式)</h3><p>上面借用构造函数模式最后改进的版本还是存在问题，它把父类的原型直接赋值给子类的原型，这就会造成一个问题，就是如果对子类的原型做了修改，那么这个修改同时也会影响到父类的原型，进而影响父类对象，这个肯定不是大家所希望看到的。为了解决这个问题就有了临时构造函数模式。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'parent'</span> ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.obj = &#123;a : <span class=\"number\">1</span>&#125; ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Child = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  Parent.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>) ;</div><div class=\"line\">&#125; ;</div><div class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>()&#123;&#125; ;</div><div class=\"line\">F.prototype = Parent.prototype ;</div><div class=\"line\">Child.prototype = <span class=\"keyword\">new</span> F() ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent(<span class=\"string\">'myParent'</span>) ;</div><div class=\"line\"><span class=\"keyword\">var</span> child = <span class=\"keyword\">new</span> Child(<span class=\"string\">'myChild'</span>) ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(parent.getName()) ; <span class=\"comment\">//myParent</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(child.getName()) ; <span class=\"comment\">//myChild</span></div></pre></td></tr></table></figure></p>\n<p>该方法的原型继承图如下：<br><img src=\"https://segmentfault.com/img/bVdnzV\" alt=\"图片描述\"><br>很容易可以看出，通过在父类原型和子类原型之间加入一个临时的构造函数<code>F</code>，切断了子类原型和父类原型之间的联系，这样当子类原型做修改时就不会影响到父类原型。</p>\n<h3 id=\"我的方法\"><a href=\"#我的方法\" class=\"headerlink\" title=\"我的方法\"></a>我的方法</h3><p>《Javascript模式》中到圣杯模式就结束了，可是不管上面哪一种方法都有一个不容易被发现的问题。大家可以看到我在’Parent’的<code>prototype</code>属性中加入了一个<code>obj</code>对象字面量属性，但是一直都没有用。我们在圣杯模式的基础上来看看下面这种情况：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'parent'</span> ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.obj = &#123;a : <span class=\"number\">1</span>&#125; ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Child = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  Parent.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>) ;</div><div class=\"line\">&#125; ;</div><div class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>()&#123;&#125; ;</div><div class=\"line\">F.prototype = Parent.prototype ;</div><div class=\"line\">Child.prototype = <span class=\"keyword\">new</span> F() ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent(<span class=\"string\">'myParent'</span>) ;</div><div class=\"line\"><span class=\"keyword\">var</span> child = <span class=\"keyword\">new</span> Child(<span class=\"string\">'myChild'</span>) ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(child.obj.a) ; <span class=\"comment\">//1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(parent.obj.a) ; <span class=\"comment\">//1</span></div><div class=\"line\">child.obj.a = <span class=\"number\">2</span> ;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(child.obj.a) ; <span class=\"comment\">//2</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(parent.obj.a) ; <span class=\"comment\">//2</span></div></pre></td></tr></table></figure></p>\n<p>在上面这种情况中，当我修改<code>child</code>对象<code>obj.a</code>的时候，同时父类的原型中的<code>obj.a</code>也会被修改，这就发生了和共享原型同样的问题。出现这个情况是因为当访问<code>child.obj.a</code>的时候，我们会沿着原型链一直找到父类的<code>prototype</code>中，然后找到了<code>obj</code>属性，然后对<code>obj.a</code>进行修改。再看看下面这种情况：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'parent'</span> ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.obj = &#123;a : <span class=\"number\">1</span>&#125; ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Child = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  Parent.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>) ;</div><div class=\"line\">&#125; ;</div><div class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>()&#123;&#125; ;</div><div class=\"line\">F.prototype = Parent.prototype ;</div><div class=\"line\">Child.prototype = <span class=\"keyword\">new</span> F() ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent(<span class=\"string\">'myParent'</span>) ;</div><div class=\"line\"><span class=\"keyword\">var</span> child = <span class=\"keyword\">new</span> Child(<span class=\"string\">'myChild'</span>) ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(child.obj.a) ; <span class=\"comment\">//1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(parent.obj.a) ; <span class=\"comment\">//1</span></div><div class=\"line\">child.obj.a = <span class=\"number\">2</span> ;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(child.obj.a) ; <span class=\"comment\">//2</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(parent.obj.a) ; <span class=\"comment\">//2</span></div></pre></td></tr></table></figure></p>\n<p>这里有一个关键的问题，当对象访问原型中的属性时，原型中的属性对于对象来说是只读的，也就是说<code>child</code>对象可以读取<code>obj</code>对象，但是无法修改原型中<code>obj</code>对象引用，所以当<code>child</code>修改<code>obj</code>的时候并不会对原型中的<code>obj</code>产生影响，它只是在自身对象添加了一个<code>obj</code>属性，覆盖了父类原型中的<code>obj</code>属性。而当<code>child</code>对象修改<code>obj.a</code>时，它先读取了原型中<code>obj</code>的引用，这时候<code>child.obj</code>和<code>Parent.prototype.obj</code>是指向同一个对象的，所以<code>child</code>对<code>obj.a</code>的修改会影响到<code>Parent.prototype.obj.a</code>的值，进而影响父类的对象。<code>AngularJS</code>中关于<code>$scope</code>嵌套的继承方式就是模范Javasript中的原型继承来实现的。<br>根据上面的描述，只要子类对象中访问到的原型跟父类原型是同一个对象，那么就会出现上面这种情况，所以我们可以对父类原型进行拷贝然后再赋值给子类原型，这样当子类修改原型中的属性时就只是修改父类原型的一个拷贝，并不会影响到父类原型。具体实现如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> deepClone = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source,target</span>)</span>&#123;</div><div class=\"line\">  source = source || &#123;&#125; ;</div><div class=\"line\">  target = target || &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">var</span> toStr = <span class=\"built_in\">Object</span>.prototype.toString ,</div><div class=\"line\">      arrStr = <span class=\"string\">'[object array]'</span> ;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> source)&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(source.hasOwnProperty(i))&#123;</div><div class=\"line\">          <span class=\"keyword\">var</span> item = source[i] ;</div><div class=\"line\">          <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> item === <span class=\"string\">'object'</span>)&#123;</div><div class=\"line\">              target[i] = (toStr.apply(item).toLowerCase() === arrStr) ? [] : &#123;&#125; ;</div><div class=\"line\">              deepClone(item,target[i]) ;    </div><div class=\"line\">          &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">              target[i] = item;</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> target ;</div><div class=\"line\">&#125; ;</div><div class=\"line\"><span class=\"keyword\">var</span> Parent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'parent'</span> ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Parent.prototype.obj = &#123;a : <span class=\"string\">'1'</span>&#125; ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Child = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  Parent.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>) ;</div><div class=\"line\">&#125; ;</div><div class=\"line\">Child.prototype = deepClone(Parent.prototype) ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> child = <span class=\"keyword\">new</span> Child(<span class=\"string\">'child'</span>) ;</div><div class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> Parent(<span class=\"string\">'parent'</span>) ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(child.obj.a) ; <span class=\"comment\">//1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(parent.obj.a) ; <span class=\"comment\">//1</span></div><div class=\"line\">child.obj.a = <span class=\"string\">'2'</span> ;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(child.obj.a) ; <span class=\"comment\">//2</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(parent.obj.a) ; <span class=\"comment\">//1</span></div></pre></td></tr></table></figure></p>\n<p>综合上面所有的考虑，Javascript继承的具体实现如下，这里只考虑了Child和Parent都是函数的情况下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> deepClone = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source,target</span>)</span>&#123;</div><div class=\"line\">  source = source || &#123;&#125; ;</div><div class=\"line\">  target = target || &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">var</span> toStr = <span class=\"built_in\">Object</span>.prototype.toString ,</div><div class=\"line\">      arrStr = <span class=\"string\">'[object array]'</span> ;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> source)&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(source.hasOwnProperty(i))&#123;</div><div class=\"line\">          <span class=\"keyword\">var</span> item = source[i] ;</div><div class=\"line\">          <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> item === <span class=\"string\">'object'</span>)&#123;</div><div class=\"line\">              target[i] = (toStr.apply(item).toLowerCase() === arrStr) ? [] : &#123;&#125; ;</div><div class=\"line\">              deepClone(item,target[i]) ;    </div><div class=\"line\">          &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">              target[i] = item;</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> target ;</div><div class=\"line\">&#125; ;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> extend = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Parent,Child</span>)</span>&#123;</div><div class=\"line\">  Child = Child || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125; ;</div><div class=\"line\">  <span class=\"keyword\">if</span>(Parent === <span class=\"literal\">undefined</span>)</div><div class=\"line\">      <span class=\"keyword\">return</span> Child ;</div><div class=\"line\">  <span class=\"comment\">//借用父类构造函数</span></div><div class=\"line\">  Child = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      Parent.apply(<span class=\"keyword\">this</span>,argument) ;</div><div class=\"line\">  &#125; ;</div><div class=\"line\">  <span class=\"comment\">//通过深拷贝继承父类原型    </span></div><div class=\"line\">  Child.prototype = deepClone(Parent.prototype) ;</div><div class=\"line\">  <span class=\"comment\">//重置constructor属性</span></div><div class=\"line\">  Child.prototype.constructor = Child ;</div><div class=\"line\">&#125; ;</div></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>说了这么多，其实Javascript中实现继承是十分灵活多样的，并没有一种最好的方法，需要根据不同的需求实现不同方式的继承，最重要的是要理解Javascript中实现继承的原理，也就是原型和原型链的问题，只要理解了这些，自己实现继承就可以游刃有余。</p>\n"}