{"tags":[{"name":"ApplicationCache","permalink":"http://bin-playground.top/blog/tags/ApplicationCache/","url":"\\async\\tags\\ApplicationCache.json","count":1}],"categories":[],"url":"\\async\\posts\\2014\\10\\21\\html5-offline-cache.json","date":1413856244000,"path":{"year":2014,"month":10,"day":21,"name":"html5-offline-cache"},"title":"有趣的HTML5：离线存储","permalink":"http://bin-playground.top/blog/2014/10/21/html5-offline-cache/","content":"<p>最近由于找工作一直没时间也没有精力更新博客，找工作真是一件苦逼的事情啊。。。不抱怨了，我们来看看HTML5的新特性—离线存储吧。</p>\n<p>随着Web App的发展，越来越多的移动端App使用HTML5的方式来开发，除了一些HybridApp以外，其他一部分Web App还是通过浏览器来访问的，通过浏览器访问就需要联网发送请求，这样就使得用户在离线的状态下无法使用App，同时Web App中一部分资源并不是经常改变，并不需要每次都向服务器发出请求，出于这些原因，HTML5提出的一个新的特性：离线存储。通过离线存储，我们可以通过把需要离线存储在本地的文件列在一个manifest配置文件中，这样即使在离线的情况下，用户也可以正常使用App。<br><a id=\"more\"></a></p>\n<h2 id=\"怎么用\"><a href=\"#怎么用\" class=\"headerlink\" title=\"怎么用\"></a>怎么用</h2><p>首先来讲解下离线存储的使用方法，说起来也很简单。只要在你的页面头部像下面一样加入一个<code>manifest</code>的属性就可以了。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE HTML&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">manifest</span> = \"<span class=\"attr\">cache.manifest</span>\"&gt;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>然后<code>cache.manifest</code>文件的书写方式，就像下面这样：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\">#v0.11</span><br><span class=\"line\"></span><br><span class=\"line\">CACHE:</span><br><span class=\"line\"></span><br><span class=\"line\">js/app.js</span><br><span class=\"line\">css/style.css</span><br><span class=\"line\"></span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\">resourse/logo.png</span><br><span class=\"line\"></span><br><span class=\"line\">FALLBACK:</span><br><span class=\"line\">/ /offline.html</span><br></pre></td></tr></table></figure></p>\n<p>离线存储的manifest一般由三个部分组成:<br>1.CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。<br>2.NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。<br>3.FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。</p>\n<h2 id=\"浏览器怎么解析manifest\"><a href=\"#浏览器怎么解析manifest\" class=\"headerlink\" title=\"浏览器怎么解析manifest\"></a>浏览器怎么解析manifest</h2><p>那么浏览器是怎么对离线的资源进行管理和加载的呢？这里需要分两种情况来讨论。</p>\n<ul>\n<li>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</li>\n<li>离线的情况下，浏览器就直接使用离线存储的资源。</li>\n</ul>\n<p>这个过程中有几个问题需要注意。</p>\n<ul>\n<li>如果服务器对离线的资源进行了更新，那么必须更新manifest文件之后这些资源才能被浏览器重新下载，如果只是更新了资源而没有更新manifest文件的话，浏览器并不会重新下载资源，也就是说还是使用原来离线存储的资源。</li>\n<li>对于manifest文件进行缓存的时候需要十分小心，因为可能出现一种情况就是你对manifest文件进行了更新，但是http的缓存规则告诉浏览器本地缓存的manifest文件还没过期，这个情况下浏览器还是使用原来的manifest文件，所以对于manifest文件最好不要设置缓存。</li>\n<li>浏览器在下载manifest文件中的资源的时候，它会一次性下载所有资源，如果某个资源由于某种原因下载失败，那么这次的所有更新就算是失败的，浏览器还是会使用原来的资源。</li>\n<li>在更新了资源之后，新的资源需要到下次再打开app才会生效，如果需要资源马上就能生效，那么可以使用<code>window.applicationCache.swapCache()</code>方法来使之生效，出现这种现象的原因是浏览器会先使用离线资源加载页面，然后再去检查manifest是否有更新，所以需要到下次打开页面才能生效。</li>\n</ul>\n<h2 id=\"咱们来试试吧\"><a href=\"#咱们来试试吧\" class=\"headerlink\" title=\"咱们来试试吧\"></a>咱们来试试吧</h2><p>说了这么多，不如自己动手来试试。这里需要说明的是，如果需要看到离线存储的效果，那么你需要把你的网页部署到服务器上，不管是本地还是生产环境服务器中，通过本地文件打开网页是无法体验到离线存储的。<br>我在我的电脑上跑了一个本地node服务器，通过localhost访问。我的manifest文件向下面这样：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\">#v0.11</span><br><span class=\"line\"></span><br><span class=\"line\">CACHE:</span><br><span class=\"line\">lib/ionic/js/ionic.bundle.js</span><br><span class=\"line\">lib/angular-ui-router.js</span><br><span class=\"line\">js/app.js</span><br><span class=\"line\">lib/ionic/css/ionic.css</span><br><span class=\"line\">css/style.css</span><br><span class=\"line\">views/login_header.html</span><br><span class=\"line\">views/login.html</span><br><span class=\"line\">lib/ionic/fonts/ionicons.ttf?v=1.5.2</span><br><span class=\"line\">lib/ionic/fonts/ionicons.woff?v=1.5.2</span><br><span class=\"line\"></span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\">lib/ionic/fonts/ionicons.ttf?v=1.5.2</span><br><span class=\"line\">lib/ionic/fonts/ionicons.woff?v=1.5.2</span><br><span class=\"line\">css/style.css</span><br></pre></td></tr></table></figure></p>\n<p>然后我们访问网页看看效果。</p>\n<p><img src=\"https://segmentfault.com/img/bVdeEM\" alt=\"图片描述\"></p>\n<p>可以看出浏览器根据manifest文件下载相应资源并且缓存在本地，现在我们来试试再次访问网页</p>\n<p><img src=\"https://segmentfault.com/img/bVdeEN\" alt=\"图片描述\"></p>\n<p>资源已经离线存储在本地，所以浏览器不需要再次下载资源，可以直接使用本地缓存的资源。接着，我们更新下服务器上的资源，比如我修改下<code>app.js</code>，结果我这里就不显示了，跟上面那张图是一样的，更新的资源并没有生效，现在我们更新下manifest文件，比如把版本改为<code>0.12</code></p>\n<p><img src=\"https://segmentfault.com/img/bVdeEO\" alt=\"图片描述\"></p>\n<p>很显然，只有更新了manifest文件，对离线资源的更新才能在浏览器上生效。<br>最后，我们来试试离线状态下是什么情况，这才是离线存储的重头戏。通过Chrome设置离线状态，刷新页面</p>\n<p><img src=\"https://segmentfault.com/img/bVdeEP\" alt=\"图片描述\"></p>\n<p>由于在离线状态，所以浏览器无法访问到manifest文件，但是网页还是可以正常访问，这就是离线存储的威力。<br>对于HTML5中离线存储对象<code>window.applicationCache</code>有几个事件需要我们关注下：</p>\n<p><img src=\"https://segmentfault.com/img/bVdeE1\" alt=\"图片描述\"></p>\n<p>1.<code>oncached</code>:当离线资源存储完成之后触发这个事件，这个是文档的说法，我在Chrome上面测试的时候并没有触发这个事件。<br>2.<code>onchecking</code>:当浏览器对离线存储资源进行更新检查的时候会触发这个事件<br>3.<code>ondownloading</code>:当浏览器开始下载离线资源的时候会触发这个事件<br>4.<code>onprogress</code>:当浏览器在下载每一个资源的时候会触发这个事件，每下载一个资源就会触发一次。<br>5.<code>onupdateready</code>:当浏览器对离线资源更新完成之后会触发这个事件<br>6.<code>onnoupdate</code>:当浏览器检查更新之后发现没有资源更新的时候触发这个事件</p>\n<p>参考文章：<br><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache</a><br><a href=\"http://diveintohtml5.info/offline.html\" target=\"_blank\" rel=\"external\">http://diveintohtml5.info/offline.html</a></p>\n"}