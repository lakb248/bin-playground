{"_total":23,"_totalPage":3,"_page":2,"posts":[{"tags":[{"name":"css","permalink":"/tags/css/","url":"/async/tags/css.json","count":1}],"categories":[],"url":"/async/posts/2014/08/02/something-about-css.json","date":1406961909000,"path":{"year":2014,"month":8,"day":2,"name":"something-about-css"},"title":"CSS那些事","permalink":"/2014/08/02/something-about-css/","content":"<p>今天跟大家分享一下CSS中一些比较重要和比较容易被忽略的东西，开始吧。<br>"},{"tags":[{"name":"promise","permalink":"/tags/promise/","url":"/async/tags/promise.json","count":5}],"categories":[],"url":"/async/posts/2014/07/19/understand-promise-5.json","date":1405752288000,"path":{"year":2014,"month":7,"day":19,"name":"understand-promise-5"},"title":"(译)深入理解Promise五部曲：5.LEGO","permalink":"/2014/07/19/understand-promise-5/","content":"<p>在<a href=\"/#/blog/2014/07/09/understand-promise-4/\">Part4:扩展问题</a>中，我讨论了如何扩展和抽象Promise是多么的常见，以及这中间的一些问题。但是为什么promise对于开发者来说不是足够友好的呢？这就是它的设计用意吗？<br>"},{"tags":[{"name":"promise","permalink":"/tags/promise/","url":"/async/tags/promise.json","count":5}],"categories":[],"url":"/async/posts/2014/07/09/understand-promise-4.json","date":1404888286000,"path":{"year":2014,"month":7,"day":9,"name":"understand-promise-4"},"title":"(译)深入理解Promise五部曲：4.扩展问题","permalink":"/2014/07/09/understand-promise-4/","content":"<p>现在，我希望你已经看过深入理解Promise的前三篇文章了。并且假设你已经完全理解Promises是什么以及深入讨论Promises的重要性。<br>"},{"tags":[{"name":"promise","permalink":"/tags/promise/","url":"/async/tags/promise.json","count":5}],"categories":[],"url":"/async/posts/2014/07/02/understand-promise-3.json","date":1404283483000,"path":{"year":2014,"month":7,"day":2,"name":"understand-promise-3"},"title":"(译)深入理解Promise五部曲：3.可靠性问题","permalink":"/2014/07/02/understand-promise-3/","content":"<p>如果你需要赶上我们关于Promise的进度，可以看看这个系列前两篇文章<a href=\"/#/blog/2014/06/23/understand-promise-1/\">深入理解Promise五部曲–1.异步问题</a>和<a href=\"/#/blog/2014/06/29/understand-promise-2/\">深入理解Promise五部曲–2.控制权转移问题</a>。</p>"},{"tags":[{"name":"promise","permalink":"/tags/promise/","url":"/async/tags/promise.json","count":5}],"categories":[],"url":"/async/posts/2014/06/29/understand-promise-2.json","date":1404024415000,"path":{"year":2014,"month":6,"day":29,"name":"understand-promise-2"},"title":"(译)深入理解Promise五部曲：2.控制权转换问题","permalink":"/2014/06/29/understand-promise-2/","content":"<blockquote>\n<p>厦门旅行归来，继续理解Promise</p>\n</blockquote>\n<p>在上一篇<a href=\"/#/blog/2014/06/23/understand-promise-1/\">深入理解Promise五部曲:1.异步问题</a>中，我们揭示了JS的异步事件轮询并发模型并且解释了多任务是如何相互穿插使得它们看起来像是同时运行的。然后我们讨论了为什么我们努力地在我们的代码里表达这些东西以及为什么我们的大脑不善于理解它们。<br>"},{"tags":[{"name":"promise","permalink":"/tags/promise/","url":"/async/tags/promise.json","count":5}],"categories":[],"url":"/async/posts/2014/06/23/understand-promise-1.json","date":1403506013000,"path":{"year":2014,"month":6,"day":23,"name":"understand-promise-1"},"title":"(译)深入理解Promise五部曲：1.异步问题","permalink":"/2014/06/23/understand-promise-1/","content":"<p>在微博上看到有人分享LabJS作者写的关于Promise的博客，看了下觉得写得很好，分五个部分讲解了Promise的来龙去脉。从这篇文章开始，我会陆续把五篇博客翻译出来跟大家分享，在大牛的带领下真正理解Promise。卖个关子，作者看待Promise的角度跟我一直以来看到的讲解Promise的角度完全不一样，不只是定留在解决回调金字塔上，至少我没想到Promise竟然有这么重要的意义。先上第一篇。<br>"},{"tags":[{"name":"javascript","permalink":"/tags/javascript/","url":"/async/tags/javascript.json","count":8},{"name":"前端优化","permalink":"/tags/前端优化/","url":"/async/tags/前端优化.json","count":4}],"categories":[],"url":"/async/posts/2014/06/16/frontend-optimization-javascript-dom.json","date":1402901051000,"path":{"year":2014,"month":6,"day":16,"name":"frontend-optimization-javascript-dom"},"title":"前端优化-Javascript篇(4.DOM优化)","permalink":"/2014/06/16/frontend-optimization-javascript-dom/","content":"<p>上篇我介绍了Javascript标识符查找方面的优化，可以看出在这方面的优化给性能带来的提升并不明显，甚至可以说基本没有影响。但是，我今天要分享的是前端Javascript优化的一个大头。众所周知，在浏览器端Javascript中DOM操作相比普通Javascript代码来说是比较耗时的，所以在DOM优化上下功夫可以收到相当可观的性能优化。下面我将分享几个DOM方面的性能优化策略。<br>"},{"tags":[{"name":"javascript","permalink":"/tags/javascript/","url":"/async/tags/javascript.json","count":8},{"name":"前端优化","permalink":"/tags/前端优化/","url":"/async/tags/前端优化.json","count":4}],"categories":[],"url":"/async/posts/2014/06/05/frontend-optimization-javascript-identifier.json","date":1401950625000,"path":{"year":2014,"month":6,"day":5,"name":"frontend-optimization-javascript-identifier"},"title":"前端优化-Javascript篇(3.标识符查找优化)","permalink":"/2014/06/05/frontend-optimization-javascript-identifier/","content":"<p>前面两篇文章介绍了Javascript文件在页面中位置以及异步加载问题对前端性能的影响。不过受限于单线程的原因，不管采用哪种方法，只要Javascript进行了耗时的工作，就都会引起页面的阻塞。所以在写代码的过程中应该注意一些会影响代码性能的问题，这样才能让我们的优化尽量做到极致。下面我跟大家分享关于标识符查找方面的优化问题。<br>"},{"tags":[{"name":"javascript","permalink":"/tags/javascript/","url":"/async/tags/javascript.json","count":8},{"name":"前端优化","permalink":"/tags/前端优化/","url":"/async/tags/前端优化.json","count":4}],"categories":[],"url":"/async/posts/2014/06/02/frontend-optimization-javascript-async-load.json","date":1401691399000,"path":{"year":2014,"month":6,"day":2,"name":"frontend-optimization-javascript-async-load"},"title":"前端优化-Javascript篇(2.异步加载脚本)","permalink":"/2014/06/02/frontend-optimization-javascript-async-load/","content":"<p>上篇博客说过脚本后置可以使页面更快的加载，可是这样的优化还是有限的，如果脚本需要执行一个耗时的操作，就算后置了它还是会阻塞后续脚本加载和执行并且阻塞整个页面。下面介绍非阻塞加载脚本技术也就是异步加载。<br>"},{"tags":[{"name":"javascript","permalink":"/tags/javascript/","url":"/async/tags/javascript.json","count":8},{"name":"前端优化","permalink":"/tags/前端优化/","url":"/async/tags/前端优化.json","count":4}],"categories":[],"url":"/async/posts/2014/05/24/frontend-optimization-javascript-bottom.json","date":1400913772000,"path":{"year":2014,"month":5,"day":24,"name":"frontend-optimization-javascript-bottom"},"title":"前端优化-Javascript篇(1.脚本放在底部)","permalink":"/2014/05/24/frontend-optimization-javascript-bottom/","content":"<p>从本篇博客开始，我会跟大家分享下我关于前端优化方面的学习，由于时间原因每篇博客只能分享一小点内容，一点点深入前端优化的细节。<br>　　做过前端的人都知道，前端优化是一个永远都不会停止的话题(当然，不管是哪个技术，优化总是无止境的)。在前端优化这个问题上，最被大家熟知的应该就是雅虎前端优化14条军规以及雅虎前端优化34条规则。大部分也都已经应用到了实际开发中。而我的分享并不是按照优化建议来进行的，我的计划是整个优化按照不同模块进行划分，分别是Javascript，CSS，HTML还有其他的一些细节。今天就先从Javascript开始。<br>"}]}